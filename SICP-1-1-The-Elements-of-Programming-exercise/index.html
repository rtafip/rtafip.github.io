<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> SICP 1.1 编程的要素 · 拖鞋党的拖鞋摊</title><meta name="description" content="SICP 1.1 编程的要素 - 拖鞋党"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://en.ors-sro.com/atom.xml" title="拖鞋党的拖鞋摊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/icon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/rss/" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">SICP 1.1 编程的要素</h1><div class="post-info">Nov 12, 2016</div><div class="post-content"><p>开新坑啦！</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很早之前就已经接触 《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs，SICP），也曾经大致看完，不过只是单纯的看，没有做习题。所以过后很快就忘了。这次开坑目的是希望能一字一句仔细阅读，完成课后练习，加深对书中概念的理解。</p>
<p>目前暂定为一个小节如 <strong>1.1</strong> 的笔记和所有习题解答为一篇文章。因为是自己做的，所以不保证答案正确。</p>
<p>目测深坑，可能弃坑，请勿尾随。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><ol>
<li>基本表达式，用于展现语言所关注的最简单的元素。</li>
<li>组合的方式，用于组合最基本的元素。</li>
<li>抽象的方式，用于组合和操作命名的元素。</li>
</ol>
<p>这里说的比较抽象。个人理解是第一个基本表达式就是程序的保留字，操作符和内置函数等，如 <code>if</code> <code>while</code> <code>int</code> <code>=</code> 。第二个组合的方式说的是用第一个基本表达式之间的组合。比如 <code>if</code> 和 <code>while</code> 组合可以实现绝大部分的逻辑。第三个抽象的方式就是第二个组合之后的结果，可以将其命名，形成一个个单元，比如函数。这样编写函数的过程本质就是抽象的过程。</p>
<h3 id="数据和过程"><a href="#数据和过程" class="headerlink" title="数据和过程"></a>数据和过程</h3><p>数据和过程并不是那么严格区分的。在面向过程式编程中，通常数据和过程比较容易区分。程序的输入可以算作一种数据。函数是一种很典型的过程。例如计算阶乘的程序，接收一个 <code>n</code> 作为输入，<code>n</code> 被视为数据。之后计算出 <code>n</code> 的阶乘，返回结果。计算的步骤就是一个过程。在面向对象中也差不多，只不过数据变成了属性，过程变成了成员函数。函数的参数是一种数据，但如果把过程当作参数传递，那么传递的是过程还是数据呢？也就是说当传递函数指针（或者回调）的时候，数据和过程的界限就不是那么清晰了。在 <code>Lisp</code> 系列的语言中，所有的程序都是 S 表达式，也就是列表。过程是一个列表，数据也是一个列表。所以过程和数据在语言看来是一样的。因此在 <code>Lisp</code> 系列的语言中，编写操作数据的过程和编写操作过程的过程难度差不多。元编程，或者说宏，就是自然而然的思想。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>书中约定了教学语言是 <code>Lisp</code> 方言 <code>Scheme</code> 。语言所用的表达式是 <a href="https://en.wikipedia.org/wiki/S-expression" target="_blank" rel="noopener">S 表达式</a>。S 表达式使用<a href="https://en.wikipedia.org/wiki/Polish_notation" target="_blank" rel="noopener">前缀表示法</a>，操作符放在操作数前面。例如 <code>1 + 2</code> 是这么表示</p>
<table>
<thead>
<tr>
<th>表示方式</th>
<th>表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>前缀表达式</td>
<td>+ 1 2</td>
</tr>
<tr>
<td>中缀表达式</td>
<td>1 + 2</td>
</tr>
<tr>
<td>后缀表达式</td>
<td>1 2 +</td>
</tr>
</tbody>
</table>
<p>为什么不用更常用的中缀表达式呢。因为中缀表达式的计算规则有两条，一是先计算优先级大的，二是从左往右计算。你也许听过那个很烂熟的哏：</p>
<p>「一加二乘三等于多少？」</p>
<p>「九啊」</p>
<p>「你个傻〇！是七！」</p>
<p>这个很无聊的哏中展现了 <code>(1 + 2) * 3 = 9</code> ， <code>1 + 2 * 3 = 7</code> 。也就是说如果想要改变计算的顺序，就必须使用优先级更高的括号操作符括住表达式。</p>
<p>如果是使用前缀表达式就只需要一条规则，从左往右计算。没有优先级的说法，自然也不需要有括号。比如 <code>1 + 2 * 3</code> 的前缀表达式是 <code>+ 1 * 2 3</code> 。</p>
<p>从左往右扫描，看到 <code>+ 1</code> 知道要用 1 和其他数字相加，这个数字是多少呢？再看到 <code>* 2 3</code>，原来这个数字是 <code>* 2 3</code> ，也就是 6，最后就是 <code>+ 1 6</code> 也就是 7 。有一点递归返回的感觉。</p>
<p>如果要计算 <code>(1 + 2) * 3</code> ，那么相应的前缀表达式是 <code>* + 1 2 3</code> 。</p>
<p>计算过程也很简单</p>
<p><code>* + 1 2 3</code> ⇒ <code>* 3 3</code> ⇒ 9</p>
<p>那为什么不用<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="noopener">后缀表达式</a>呢？</p>
<p>S 表达式为什么不用不了解。个人觉得后缀表达式真的很丧心病狂，非常反直觉。例如 <code>1 2 + 3 *</code> 是怎么计算的呢？</p>
<p>它不是 <code>1 + 2 * 3</code> ，也不是从右往左计算的 <code>(3 + 2) * 1</code> ，而是 <code>(1 + 2) * 3</code> 。</p>
<p>虽说不用中缀表达式可以节省括号，但是 S 表达式里面全是括号啊！摔！</p>
<p>不使用中缀表达式另外一个优点是可以天然地支持多参数。</p>
<p>例如 1 + 2 + 3 的 S 表达式是 <code>(+ (+ 1 2) 3)</code> 。可以写成 <code>(+ 1 2 3)</code> 。</p>
<p>因为中缀表达式操作符两边要有操作数，所以不能很方便的表达多参数的情况。</p>
<h3 id="好好写代码"><a href="#好好写代码" class="headerlink" title="好好写代码"></a>好好写代码</h3><p>S 表达式无脑嵌套会非常辣眼睛。比如看到 <code>(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))</code> 会一脸懵 X，写成这样就会好很多</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">4</span>)</span><br><span class="line">         (<span class="name"><span class="builtin-name">+</span></span> <span class="number">3</span> <span class="number">5</span>)))</span><br><span class="line">   (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">-</span></span> <span class="number">10</span> <span class="number">7</span>)</span><br><span class="line">      <span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p>也就是操作符在前，操作数垂直对齐。</p>
<h3 id="变量绑定与环境"><a href="#变量绑定与环境" class="headerlink" title="变量绑定与环境"></a>变量绑定与环境</h3><p><code>Scheme</code> 使用 <code>define</code> 绑定全局变量。如果不允许声明和绑定变量，那就只能用递归来写程序了，也就是「纯函数式」编程（大雾）。</p>
<p>出现在函数参数列表中的变量称为绑定变量。如 <code>(define (square x) (* x x))</code> 中的 <code>x</code> 称为绑定变量。</p>
<p>没有被绑定的变量称为自由变量。如 <code>(define (cube x) (* (square x) x))</code> 中的 <code>square</code> 是自由变量。因为参数列表 <code>cube x</code> 中只有 <code>x</code> ，没有 <code>square</code> 。这意味着 <code>x</code> 的值由调用函数 <code>cube</code> 传入的参数决定，与 <code>cube</code> 死死的绑在了一起。而 <code>square</code> 的值则需要去<strong>上下文环境</strong>查找。</p>
<p>上下文环境可以简单的理解为储存变量的地方。既然有储存肯定有读取，读取的时候按规则区分为<strong>词法作用域</strong>和<strong>动态作用域</strong>。</p>
<p>词法作用域，也称为动态作用域，是大部分语言常用的查找规则。</p>
<p>动态作用域，有些反直觉，早期语言使用的规则。因为环境创建的时候什么事都不用干就是天然的动态作用域。熟悉 <code>JavaScript</code> 的都知道 <code>this</code>关键字吧。这个家伙有很多的异常表现就是因为它是动态作用域。还好 <code>Scheme</code> 出现解决了动态作用域的问题。</p>
<p>词法作用域和动态作用域的区别可以用<a href="http://zhihu.com/question/20032419/answer/44059188" target="_blank" rel="noopener">两句话解释清楚</a>。</p>
<p>替换绑定的变量不影响结果。也就是</p>
<p><code>(define (square x) (* x x))</code> 和 <code>(define (square y) (* y y))</code> 结果是一样的。其实这是 $\alpha$ 变换（大雾）。</p>
<p>函数的定义也是一个变量绑定的过程。在 <code>Scheme</code> 中函数默认返回最后一个计算结果，不需要显式地 <code>return</code> 。</p>
<p>还有一个语法细节，定义变量是 <code>(define a 1)</code> ，定义函数是 <code>(define  (square x) (* x x))</code> 。</p>
<p>语法看似不一致，其实是统一的。可以把 <code>define</code> 看作 <code>=</code> 。式子可以这么理解。</p>
<p><code>(define a 1)</code> ⇒ <code>a = 1</code></p>
<p><code>(define (square x) (* x x))</code> ⇒ <code>(square x) = (* x x)</code></p>
<h3 id="求值规则"><a href="#求值规则" class="headerlink" title="求值规则"></a>求值规则</h3><blockquote>
<p>To evaluate a combination, do the following:</p>
<ol>
<li>Evaluate the subexpressions of the combination.</li>
<li>Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (the operands)</li>
</ol>
</blockquote>
<p>求值表达式，按以下规则进行</p>
<ol>
<li>求值子表达式</li>
<li>应用其操作符于该子表达式</li>
</ol>
<p>所以这是一个嵌套的求值过程。嵌套结构用树结构很容易表示。如果用树来表示，那么求值的时候相当于树的遍历。</p>
<p>这里没有似乎没有说清楚参数求值是从左往右还是从右往左。</p>
<p>这种求值方式是传值调用（Call by value），这里说的传值调用强调的是求值的时机。</p>
<p>传值调用，也就是在函数调用前，求出每个参数的值。例如平方函数 <code>(define (square x) (* x x))</code> 在接收参数 5 的调用时是这么求值的。</p>
<p><code>(square 5)</code> ⇒ <code>(* 5 5)</code> ⇒ 25</p>
<p>在接收参数为 <code>(square 2)</code> 时是这么求值的</p>
<p><code>(square (square 2))</code> ⇒ <code>(square (* 2 2))</code> ⇒ <code>(square 4)</code> ⇒ <code>(* 4 4)</code> ⇒ 16</p>
<p>传值调用在书中被称为 <strong>Applicative-order</strong> 。</p>
<p>还有一种求值方式是传名调用（Call by name），在书中被称为 <strong>Normal-order</strong> 。</p>
<p>简单地说是把所有表达式中命名的变量求值完成后，再对整个表达式求值。</p>
<p>比如 <code>(square (square (+ 1 2)))</code> 按传名调用是这样</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">square</span> (<span class="name">square</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> (<span class="name">square</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">   (<span class="name">square</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">   (<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>))))</span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span> <span class="number">3</span>)</span><br><span class="line">   (<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span> <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> <span class="number">9</span> <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>如果是传值调用是这样</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">square</span> (<span class="name">square</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">square</span> (<span class="name">square</span> <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">square</span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span> <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">square</span> <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> <span class="number">9</span> <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>在这里两种方式最后的结果一致。但是在参数求值有副作用或者有求值短路等现象出现时，结果就会不一样。习题 1.5 会给出这样的情况。</p>
<h3 id="递归与循环"><a href="#递归与循环" class="headerlink" title="递归与循环"></a>递归与循环</h3><p>平方根函数 <code>sqrt-iter</code> 在最后调用了<code>sqrt-iter</code>。也就是自己调用自己。这种方式称为递归。</p>
<p>与递归对应的是迭代。实际上递归更符合人类思维，迭代更符合计算机思维。</p>
<p>递归很容易给人一种计算效率低的印象。但并不是所有的递归都是这样。</p>
<p>像平方根函数这种在函数最后一句只调用自身的递归称为尾递归。</p>
<p>普通的递归在计算到出口后会将结果一层层向上返回，所以需要在堆栈中记录返回地址等相关信息，层数一多很可能就爆栈。</p>
<p>而尾递归因为递归放在尾部，返回后也没有后续可执行内容（continuation），所以可以直接抛弃之前的调用信息。也就是尾递归通过抛弃之前的调用信息而防止爆栈。常见的现代编译器都会将尾递归优化为循环。所以尾递归的效率并不低。</p>
<p>然而并不是所有的递归都能转化为循环。</p>
<h3 id="封装与面向对象"><a href="#封装与面向对象" class="headerlink" title="封装与面向对象"></a>封装与面向对象</h3><p><code>Scheme</code> 允许在函数定义中定义函数，所以通常会看到一个函数，内部定义不少小函数和常量，之后调用这些小函数。</p>
<p>这样把数据和过程包装在一个函数的手段称为封装。</p>
<p>说到封装，很自然就想到了面向对象。毕竟面向对象的三大特性是封装，继承，多态。</p>
<p>说到对象就会想到 <code>class</code>，实际上面向对象跟 <code>class</code> 一点关系都没有。</p>
<p><code>class</code>是实现面向对象的一种方式但不是唯一方式。 原型链也是一种实现面向对象方式。</p>
<p>现在的面向对象跟 Alan Kay 的面向对象已经不是同一个东西了。</p>
<p>Alan Kay 的面向对象强调封装与消息发送。他认为每一个对象都要有一个 IP 。</p>
<p>如果按照 Alan Kay 的观点大家的面向对象都跑偏了（逃</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="习题-1-1"><a href="#习题-1-1" class="headerlink" title="习题 1.1"></a>习题 1.1</h3><blockquote>
<p><strong>Exercise 1.1.</strong>  Below is a sequence of expressions. What is the result printed by the interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented.</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">-</span></span> <span class="number">9</span> <span class="number">1</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">/</span></span> <span class="number">6</span> <span class="number">2</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">4</span>) (<span class="name"><span class="builtin-name">-</span></span> <span class="number">4</span> <span class="number">6</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a <span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> b (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">1</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> a b (<span class="name"><span class="builtin-name">*</span></span> a b))</span><br><span class="line">(<span class="name"><span class="builtin-name">=</span></span> a b)</span><br><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> b a) (<span class="name"><span class="builtin-name">&lt;</span></span> b (<span class="name"><span class="builtin-name">*</span></span> a b)))</span><br><span class="line">    b</span><br><span class="line">    a)</span><br><span class="line">(<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> a <span class="number">4</span>) <span class="number">6</span>)</span><br><span class="line">      ((<span class="name"><span class="builtin-name">=</span></span> b <span class="number">4</span>) (<span class="name"><span class="builtin-name">+</span></span> <span class="number">6</span> <span class="number">7</span> a))</span><br><span class="line">      (<span class="name"><span class="builtin-name">else</span></span> <span class="number">25</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> b a) b a))</span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&gt;</span></span> a b) a)</span><br><span class="line">         ((<span class="name"><span class="builtin-name">&lt;</span></span> a b) b)</span><br><span class="line">         (<span class="name"><span class="builtin-name">else</span></span> <span class="number">-1</span>))</span><br><span class="line">   (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>这道题所有表达式都不存在命名的函数，所以直接求值，不用考虑求值方式。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">;; 10 规则 1.1.3 第一条：字面量的值为它们相应的值</span></span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"><span class="comment">;; 12 规则 1.1.3 第二条：内置操作符为它们相应的操作符</span></span><br><span class="line">(<span class="name"><span class="builtin-name">-</span></span> <span class="number">9</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;; 8 是 9 - 1 不是 1 - 9 。参考前缀表达式定义</span></span><br><span class="line">(<span class="name"><span class="builtin-name">/</span></span> <span class="number">6</span> <span class="number">2</span>)</span><br><span class="line"><span class="comment">;; 6/2 = 3</span></span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">4</span>) (<span class="name"><span class="builtin-name">-</span></span> <span class="number">4</span> <span class="number">6</span>))</span><br><span class="line"><span class="comment">;; (+ 8 (- 2)) = 6</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a <span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> b (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">1</span>))</span><br><span class="line"><span class="comment">;; 注意此时 b 已经被赋值为 a + 1 = 3 + 1 = 4</span></span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> a b (<span class="name"><span class="builtin-name">*</span></span> a b))</span><br><span class="line"><span class="comment">;;规则 1.1.3 第三条：命名的符号值从环境中获取</span></span><br><span class="line"><span class="comment">;;这里使用了参数从左往右求值的顺序</span></span><br><span class="line"><span class="comment">;;(+ 3 b (* a b))</span></span><br><span class="line"><span class="comment">;;(+ 3 4 (* a b))</span></span><br><span class="line"><span class="comment">;;(+ 3 4 (* 3 b))</span></span><br><span class="line"><span class="comment">;;(+ 3 4 (* 3 4))</span></span><br><span class="line"><span class="comment">;;(+ 3 4 12)</span></span><br><span class="line"><span class="comment">;;19</span></span><br><span class="line">(<span class="name"><span class="builtin-name">=</span></span> a b)</span><br><span class="line"><span class="comment">;;(= 3 b)</span></span><br><span class="line"><span class="comment">;;(= 3 4)</span></span><br><span class="line"><span class="comment">;; #f Scheme 用 #t 和 #f 表示 true 和 false。在脚注 17 中有提到</span></span><br><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> b a) (<span class="name"><span class="builtin-name">&lt;</span></span> b (<span class="name"><span class="builtin-name">*</span></span> a b)))</span><br><span class="line">    b</span><br><span class="line">    a)</span><br><span class="line"><span class="comment">;;(if (and (&gt; 4 3) (&lt; b (* a b))) b a)</span></span><br><span class="line"><span class="comment">;;(if (and #t (&lt; b (* a b))) b a)</span></span><br><span class="line"><span class="comment">;;(if (and #t (&lt; 4 (* a b))) b a)</span></span><br><span class="line"><span class="comment">;;(if (and #t (&lt; 4 (* 3 4))) b a)</span></span><br><span class="line"><span class="comment">;;(if (and #t (&lt; 4 12)) b a)</span></span><br><span class="line"><span class="comment">;;(if (and #t #t) b a)</span></span><br><span class="line"><span class="comment">;;b</span></span><br><span class="line"><span class="comment">;;4</span></span><br><span class="line">(<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> a <span class="number">4</span>) <span class="number">6</span>)</span><br><span class="line">      ((<span class="name"><span class="builtin-name">=</span></span> b <span class="number">4</span>) (<span class="name"><span class="builtin-name">+</span></span> <span class="number">6</span> <span class="number">7</span> a))</span><br><span class="line">      (<span class="name"><span class="builtin-name">else</span></span> <span class="number">25</span>))</span><br><span class="line"><span class="comment">;;(cond ((= 3 4) 6) ((= b 4) (+ 6 7 a)) (else 25))</span></span><br><span class="line"><span class="comment">;;(cond (#f 6) ((= b 4) (+ 6 7 a)) (else 25))</span></span><br><span class="line"><span class="comment">;;(cond (#f 6) (#t (+ 6 7 a)) (else 25))</span></span><br><span class="line"><span class="comment">;;(+ 6 7 a)</span></span><br><span class="line"><span class="comment">;;(+ 6 7 3)</span></span><br><span class="line"><span class="comment">;;16</span></span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> b a) b a))</span><br><span class="line"><span class="comment">;;(+ 2 (if (&gt; 4 a) b a))</span></span><br><span class="line"><span class="comment">;;(+ 2 (if (&gt; 4 3) b a))</span></span><br><span class="line"><span class="comment">;;(+ 2 (if #t b a))</span></span><br><span class="line"><span class="comment">;;(+ 2 b)</span></span><br><span class="line"><span class="comment">;;(+ 2 4)</span></span><br><span class="line"><span class="comment">;;6</span></span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&gt;</span></span> a b) a)</span><br><span class="line">         ((<span class="name"><span class="builtin-name">&lt;</span></span> a b) b)</span><br><span class="line">         (<span class="name"><span class="builtin-name">else</span></span> <span class="number">-1</span>))</span><br><span class="line">   (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">1</span>))</span><br><span class="line"><span class="comment">;;(* (cond ((&gt; 3 4) a) ((&lt; a b) b) (else -1)) (+ a 1))</span></span><br><span class="line"><span class="comment">;;(* (cond (#f a) ((&lt; a b) b) (else -1)) (+ a 1))</span></span><br><span class="line"><span class="comment">;;(* (cond (#f a) ((&lt; 3 4) b) (else -1)) (+ a 1))</span></span><br><span class="line"><span class="comment">;;(* (cond (#f a) (#t b) (else -1)) (+ a 1))</span></span><br><span class="line"><span class="comment">;;(* (cond (#f a) (#t b) (else -1)) (+ a 1))</span></span><br><span class="line"><span class="comment">;;(* b (+ a 1))</span></span><br><span class="line"><span class="comment">;;(* 4 (+ a 1))</span></span><br><span class="line"><span class="comment">;;(* 4 (+ 3 1))</span></span><br><span class="line"><span class="comment">;;(* 4 4)</span></span><br><span class="line"><span class="comment">;;16</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-2"><a href="#习题-1-2" class="headerlink" title="习题 1.2"></a>习题 1.2</h3><blockquote>
<p><strong>Exercise 1.2.</strong>  Translate the following expression into prefix form<br>$$<br>\frac {5+4+(2-(3-(6+ \frac 4 3)))} {3(6-2)(2-7)}<br>$$</p>
</blockquote>
<p>先把分子和分母转成前缀表达式，利用前缀表达式<a href="#表达式">支持多参数的特性</a>简化式子，再用 <code>(/ 分子 分母)</code> 连起来即可。</p>
<p><strong>这里说明中缀表达式转前缀表达式的过程</strong></p>
<p>分子</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">5</span> </span><br><span class="line">   <span class="number">4</span></span><br><span class="line">   (<span class="name"><span class="builtin-name">-</span></span> <span class="number">2</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">-</span></span> <span class="number">3</span></span><br><span class="line">         (<span class="name"><span class="builtin-name">+</span></span> <span class="number">6</span></span><br><span class="line">            (<span class="name"><span class="builtin-name">/</span></span> <span class="number">4</span></span><br><span class="line">               <span class="number">3</span>)))))</span><br></pre></td></tr></table></figure>
<p>分母</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span></span><br><span class="line">   (<span class="name"><span class="builtin-name">-</span></span> <span class="number">6</span></span><br><span class="line">      <span class="number">2</span>)</span><br><span class="line">   (<span class="name"><span class="builtin-name">-</span></span> <span class="number">2</span></span><br><span class="line">      <span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<p>所以答案是</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">5</span> <span class="number">4</span> (<span class="name"><span class="builtin-name">-</span></span> <span class="number">2</span> (<span class="name"><span class="builtin-name">-</span></span> <span class="number">3</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">6</span> (<span class="name"><span class="builtin-name">/</span></span> <span class="number">4</span> <span class="number">3</span>)))))</span><br><span class="line">   (<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span> (<span class="name"><span class="builtin-name">-</span></span> <span class="number">6</span> <span class="number">2</span>) (<span class="name"><span class="builtin-name">-</span></span> <span class="number">2</span> <span class="number">7</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="习题-1-3"><a href="#习题-1-3" class="headerlink" title="习题 1.3"></a>习题 1.3</h3><blockquote>
<p><strong>Exercise 1.3.</strong>  Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.</p>
</blockquote>
<p>从动词可以判断有多少个函数</p>
<ol>
<li>a procedure that take … return ..</li>
<li>sum of …</li>
<li>squares…</li>
</ol>
<p>从下往上一个个写回去，<code>square</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br></pre></td></tr></table></figure>
<p><code>sum</code>求和</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum</span> a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> a b))</span><br></pre></td></tr></table></figure>
<p>接收三个参数返回最大和次大的两个数。因为加法满足交换律 <code>a + b = b + a</code> 所以只需要确定出最小的数，把比较大的两个数求平方和即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-larger-square</span> a b c)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> b c)</span><br><span class="line">          (<span class="name">sum</span> (<span class="name">square</span> a) (<span class="name">square</span> b))</span><br><span class="line">          (<span class="name">sum</span> (<span class="name">square</span> a) (<span class="name">square</span> c)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a c)</span><br><span class="line">          (<span class="name">sum</span> (<span class="name">square</span> b) (<span class="name">square</span> a))</span><br><span class="line">          (<span class="name">sum</span> (<span class="name">square</span> b) (<span class="name">square</span> c)))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">sum-larger-square</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="comment">;; 13</span></span><br><span class="line">(<span class="name">sum-larger-square</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span>)</span><br><span class="line"><span class="comment">;; 61</span></span><br><span class="line">(<span class="name">sum-larger-square</span> <span class="number">7</span> <span class="number">9</span> <span class="number">8</span>)</span><br><span class="line"><span class="comment">;; 145</span></span><br><span class="line">(<span class="name">sum-larger-square</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;; 2</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-4"><a href="#习题-1-4" class="headerlink" title="习题 1.4"></a>习题 1.4</h3><blockquote>
<p><strong>Exercise 1.4.</strong>  Observe that our model of evaluation allows for combinations whose operators are compound expressions. Use this observation to describe the behavior of the following procedure:</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">a-plus-abs-b</span> a b)</span><br><span class="line">  ((<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> b <span class="number">0</span>) + -) a b))</span><br></pre></td></tr></table></figure>
<p>描述函数行为。按语句翻译即可。首先看到函数定义 <code>(define (a-plus-abs-b a b) (...)</code> 这是一个接收两个参数的函数，再看函数体 <code>((if (&gt; b 0) + -) a b)</code> 如果 <code>b</code> 大于 0 则结果为 <code>+</code> 操作符，否则为 <code>-</code> 操作符。然后将该操作符应用到参数 <code>a</code> <code>b</code> 上。所以答案是</p>
<p><code>a</code> 加上 <code>b</code> 的绝对值。 （虽然函数名字已经提示得够明显了。）</p>
<p>这道题展示了过程（函数）是可以作为结果返回的。根据<code>b</code> 的正负，返回<code>+</code> 或 <code>-</code> 。这种做法在 <code>Scheme</code> 中很常见。因为过程（函数）和数据在语言看来没有区别。既然可以返回数字（典型的数据），也自然可以返回函数（典型的过程）。</p>
<h3 id="习题-1-5"><a href="#习题-1-5" class="headerlink" title="习题 1.5"></a>习题 1.5</h3><blockquote>
<p><strong>Exercise 1.5.</strong>  Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">p</span>) (<span class="name">p</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">test</span> x y)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      y))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Then he evaluates the expression<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">test</span> <span class="number">0</span> (<span class="name">p</span>))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)</p>
</blockquote>
<p>先回顾一下概念</p>
<p><strong>Applicative-order</strong>: evaluate the arguments and then apply. 求值参数并应用。</p>
<p><strong>Normal-order</strong>: fully expand and then reduce. 完全展开后规约。</p>
<p>先按 applicative-order 展开</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; applicative-order</span></span><br><span class="line">(<span class="name">test</span> <span class="number">0</span> (<span class="name">p</span>))</span><br><span class="line"><span class="comment">;; 挨个求值参数 0 (p)</span></span><br><span class="line"><span class="comment">;; 求值 0 结果为 0 1.1.3 第一条：字面量的值为它们相应的值</span></span><br><span class="line">(<span class="name">test</span> <span class="number">0</span> (<span class="name">p</span>))</span><br><span class="line"><span class="comment">;; 求值 (p) 规则 1.1.3 第三条：命名的符号值从环境中获取</span></span><br><span class="line"><span class="comment">;; 环境中 (define (p) (p))</span></span><br><span class="line">(<span class="name">test</span> <span class="number">0</span> ((<span class="name">p</span>)))</span><br><span class="line"><span class="comment">;; 求值后又出现 p ，再次对 p 求值</span></span><br><span class="line">(<span class="name">test</span> <span class="number">0</span> (((<span class="name">p</span>))))</span><br><span class="line"><span class="comment">;; 递归，没有办法获得具体的值。无限循环</span></span><br></pre></td></tr></table></figure>
<p>按 normal-order 展开</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; normal-order</span></span><br><span class="line">(<span class="name">test</span> <span class="number">0</span> (<span class="name">p</span>))</span><br><span class="line"><span class="comment">;; 先完全展开定义的函数，在规约求值</span></span><br><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> <span class="number">0</span>) <span class="number">0</span> (<span class="name">p</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">if</span></span> <span class="literal">#t</span> <span class="number">0</span> (<span class="name">p</span>))</span><br><span class="line"><span class="comment">;; 题目中提到 if 语句中的条件判断优先执行，结果只执行相应的分支</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>所以答案是按 applicative-order 执行会无限循环，按 normal-order 执行结果是 0 。</p>
<h3 id="习题-1-6"><a href="#习题-1-6" class="headerlink" title="习题 1.6"></a>习题 1.6</h3><blockquote>
<p><strong>Exercise 1.6.</strong>  Alyssa P. Hacker doesn’t see why if needs to be provided as a special form. <code></code>Why can’t I just define it as an ordinary procedure in terms of cond?’’ she asks. Alyssa’s friend Eva Lu Ator claims this can indeed be done, and she defines a new version of if:</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">new-if</span> predicate then-clause else-clause)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name">predicate</span> then-clause)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> else-clause)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Eva demonstrates the program for Alyssa:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">new-if</span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">2</span> <span class="number">3</span>) <span class="number">0</span> <span class="number">5</span>)</span><br><span class="line">*5*</span><br><span class="line">(<span class="name">new-if</span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">1</span> <span class="number">1</span>) <span class="number">0</span> <span class="number">5</span>)</span><br><span class="line">*0*</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Delighted, Alyssa uses new-if to rewrite the square-root program:</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-iter</span> guess x)</span><br><span class="line">  (<span class="name">new-if</span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">          guess</span><br><span class="line">          (<span class="name">sqrt-iter</span> (<span class="name">improve</span> guess x)</span><br><span class="line">                     x)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>What happens when Alyssa attempts to use this to compute square roots? Explain.</p>
</blockquote>
<p>按默认的 applicative-order 展开</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">sqrt-iter</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line"><span class="comment">;; 根据 applicative-order 先求参数的值</span></span><br><span class="line">(<span class="name">new-if</span> (<span class="name">good-enough?</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name">sqrt-iter</span> (<span class="name">improve</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">                   <span class="number">2</span>))</span><br><span class="line"><span class="comment">;; 求 (good-enough 1 2) 的值</span></span><br><span class="line">(<span class="name">new-if</span> (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">square</span> <span class="number">1</span>) <span class="number">2</span>) <span class="number">0.001</span>))</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name">sqrt-iter</span> (<span class="name">improve</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">                   <span class="number">2</span>))</span><br><span class="line"><span class="comment">;; 2 - 1 &gt; 0.001 所以结果是 #f</span></span><br><span class="line">(<span class="name">new-if</span> <span class="literal">#f</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name">sqrt-iter</span> (<span class="name">improve</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">                   <span class="number">2</span>))</span><br><span class="line"><span class="comment">;;接着求 (sqrt-iter (improve 1 2)2)</span></span><br><span class="line">(<span class="name">new-if</span> <span class="literal">#f</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name">sqrt-iter</span> (<span class="name">average</span> <span class="number">1</span> (<span class="name"><span class="builtin-name">/</span></span> <span class="number">2</span> <span class="number">1</span>))</span><br><span class="line">                   <span class="number">2</span>))</span><br><span class="line"><span class="comment">;;1 和 2 的平均值为 1.5</span></span><br><span class="line">(<span class="name">new-if</span> <span class="literal">#f</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name">sqrt-iter</span> <span class="number">1.5</span> </span><br><span class="line">                   <span class="number">2</span>))</span><br><span class="line"><span class="comment">;; 求值 (sqrt-iter 1.5 2)</span></span><br><span class="line">(<span class="name">new-if</span> <span class="literal">#f</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name">new-if</span> (<span class="name">good-enough?</span> <span class="number">1.5</span> <span class="number">2</span>)</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">                (<span class="name">sqrt-iter</span> (<span class="name">improve</span> <span class="number">1.5</span> <span class="number">2</span>)</span><br><span class="line">                           <span class="number">2</span>)))</span><br><span class="line"><span class="comment">;; 又回到开始的地方。无穷无尽的求值</span></span><br></pre></td></tr></table></figure>
<p>所以答案是会一直递归下去。无穷无尽。</p>
<p>解决方法是使用<strong>宏</strong>，宏在求值会先展开后求参数的值。这个后面章节应该会讲。</p>
<h3 id="习题-1-7"><a href="#习题-1-7" class="headerlink" title="习题 1.7"></a>习题 1.7</h3><blockquote>
<p><strong>Exercise 1.7.</strong>  The good-enough? test used in computing square roots will not be very effective for finding the square roots of very small numbers. Also, in real computers, arithmetic operations are almost always performed with limited precision. This makes our test inadequate for very large numbers. Explain these statements, with examples showing how the test fails for small and large numbers. An alternative strategy for implementing good-enough? is to watch how guess changes from one iteration to the next and to stop when the change is a very small fraction of the guess. Design a square-root procedure that uses this kind of end test. Does this work better for small and large numbers?</p>
</blockquote>
<p>这道题有两个问题。</p>
<p>第一个问题是解释为什么遇到特别小的数和特别大的数时候 <code>good-enough</code> 失效？第二个问题是请设计一个 <code>good-enough</code></p>
<p>先来看第一个问题。</p>
<p>在遇到特别小的数如0.0001的时候</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">sqrt</span></span> <span class="number">0.0004</span>)</span><br><span class="line"><span class="comment">;;(guess next-guess)</span></span><br><span class="line"><span class="comment">;;(1 0.5002)</span></span><br><span class="line"><span class="comment">;;(0.5002 0.2504998400639744)</span></span><br><span class="line"><span class="comment">;;(0.2504998400639744 0.12604832373535454)</span></span><br><span class="line"><span class="comment">;;(0.12604832373535454 0.06461085492374607)</span></span><br><span class="line"><span class="comment">;;(0.06461085492374607 0.0354008825558513)</span></span><br><span class="line"><span class="comment">;;(0.0354008825558513 0.023350017942701275)</span></span><br><span class="line"><span class="comment">;;0.0354008825558513</span></span><br></pre></td></tr></table></figure>
<p>正确结果应该是 0.01。那为什么结果是 0.03 呢。</p>
<p>因为在 <code>(if good-enough? guess x)</code> 中 $|0.035^2 - 0.0004| = 0.0008 &lt; 0.001$ </p>
<p>也就是误差范围太大了。</p>
<p>在遇到特别大的数$10^{50}$的时候</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">sqrt</span></span> <span class="number">1000000000000000000000000000000000000000000000000000</span>)</span><br><span class="line"><span class="comment">;;(guess next-guess)</span></span><br><span class="line"><span class="comment">;;(1 5e+50)</span></span><br><span class="line"><span class="comment">;;(5e+50 2.5e+50)</span></span><br><span class="line"><span class="comment">;;(2.5e+50 1.25e+50)</span></span><br><span class="line"><span class="comment">;;(1.25e+50 6.25e+49)</span></span><br><span class="line"><span class="comment">;;(6.25e+49 3.125e+49)</span></span><br><span class="line"><span class="comment">;;......</span></span><br><span class="line"><span class="comment">;;(8.275835485684287e+26 4.143959428915591e+26)</span></span><br><span class="line"><span class="comment">;;(4.143959428915591e+26 2.084045469651032e+26)</span></span><br><span class="line"><span class="comment">;;(2.084045469651032e+26 1.066014533818449e+26)</span></span><br><span class="line"><span class="comment">;;(1.066014533818449e+26 5.799109426226321e+25)</span></span><br><span class="line"><span class="comment">;;(5.799109426226321e+25 3.7617560672361973e+25)</span></span><br><span class="line"><span class="comment">;;(3.7617560672361973e+25 3.2100444948749963e+25)</span></span><br><span class="line"><span class="comment">;;(3.2100444948749963e+25 3.1626330556312044e+25)</span></span><br><span class="line"><span class="comment">;;(3.1626330556312044e+25 3.1622776801368567e+25)</span></span><br><span class="line"><span class="comment">;;(3.1622776801368567e+25 3.1622776601683795e+25) </span></span><br><span class="line"><span class="comment">;;(3.1622776601683795e+25 3.1622776601683795e+25)</span></span><br><span class="line"><span class="comment">;;(3.1622776601683795e+25 3.1622776601683795e+25)</span></span><br><span class="line"><span class="comment">;;(3.1622776601683795e+25 3.1622776601683795e+25)</span></span><br><span class="line"><span class="comment">;;(3.1622776601683795e+25 3.1622776601683795e+25)</span></span><br></pre></td></tr></table></figure>
<p>可以发现某个时刻开始猜测的下一个更好的值和原来是同一个值。</p>
<p>这是因为如果要精确的话应该在3.1622…3795e25 的 …3795继续精确下去。但是浮点数的精确度不够用了，不能再表示更长的小数了。</p>
<p>所以这就是出错的原因。</p>
<p>接下来第二个问题是怎么改进。题目中已经提示观察近似值和下一个近似值之间的变化，当变化足够小的时候停止。</p>
<p>变化足够小可以考虑用差来表示，但是考虑到遇到特别小的数时会出现问题。</p>
<p>所以使用比值判断是否变化足够小，也就是只需要改进 <code>good-enough?</code> 即可</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line"> (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> <span class="number">1</span> </span><br><span class="line">            (<span class="name"><span class="builtin-name">/</span></span> guess (<span class="name">improve</span> guess x)))) </span><br><span class="line">    <span class="number">0.001</span>))</span><br></pre></td></tr></table></figure>
<p>判断近似值的比值是否足够靠近 1 。也就是两个近似值是否足够接近。</p>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">sqrt</span></span> <span class="number">4</span>)</span><br><span class="line"><span class="comment">;;(1 2.5)</span></span><br><span class="line"><span class="comment">;;(2.5 2.05)</span></span><br><span class="line"><span class="comment">;;(2.05 2.000609756097561)</span></span><br><span class="line"><span class="comment">;;(2.000609756097561 2.0000000929222947)</span></span><br><span class="line"><span class="comment">;;2.000609756097561</span></span><br><span class="line">(<span class="name"><span class="builtin-name">sqrt</span></span> <span class="number">0.0004</span>)</span><br><span class="line"><span class="comment">;;(1 0.5002)</span></span><br><span class="line"><span class="comment">;;(0.5002 0.2504998400639744)</span></span><br><span class="line"><span class="comment">;;(0.2504998400639744 0.12604832373535454)</span></span><br><span class="line"><span class="comment">;;(0.12604832373535454 0.06461085492374607)</span></span><br><span class="line"><span class="comment">;;(0.06461085492374607 0.0354008825558513)</span></span><br><span class="line"><span class="comment">;;(0.0354008825558513 0.023350017942701275)</span></span><br><span class="line"><span class="comment">;;(0.023350017942701275 0.02024031288207058)</span></span><br><span class="line"><span class="comment">;;(0.02024031288207058 0.020001426615330147)</span></span><br><span class="line"><span class="comment">;;(0.020001426615330147 0.020000000050877154)</span></span><br><span class="line"><span class="comment">;;0.020001426615330147</span></span><br><span class="line">(<span class="name"><span class="builtin-name">sqrt</span></span> <span class="number">1000000000000000000000000000000000000000000000000000</span>)</span><br><span class="line"><span class="comment">;;(1 5e+50)</span></span><br><span class="line"><span class="comment">;;(5e+50 2.5e+50)</span></span><br><span class="line"><span class="comment">;;(2.5e+50 1.25e+50)</span></span><br><span class="line"><span class="comment">;;(1.25e+50 6.25e+49)</span></span><br><span class="line"><span class="comment">;;(6.25e+49 3.125e+49)</span></span><br><span class="line"><span class="comment">;;(3.125e+49 1.5625e+49)</span></span><br><span class="line"><span class="comment">;;(1.5625e+49 7.8125e+48)</span></span><br><span class="line"><span class="comment">;;(7.8125e+48 3.90625e+48)</span></span><br><span class="line"><span class="comment">;;(3.90625e+48 1.953125e+48)</span></span><br><span class="line"><span class="comment">;;(1.953125e+48 9.765625e+47)</span></span><br><span class="line"><span class="comment">;;......</span></span><br><span class="line"><span class="comment">;;(8.275835485684287e+26 4.143959428915591e+26)</span></span><br><span class="line"><span class="comment">;;(4.143959428915591e+26 2.084045469651032e+26)</span></span><br><span class="line"><span class="comment">;;(2.084045469651032e+26 1.066014533818449e+26)</span></span><br><span class="line"><span class="comment">;;(1.066014533818449e+26 5.799109426226321e+25)</span></span><br><span class="line"><span class="comment">;;(5.799109426226321e+25 3.7617560672361973e+25)</span></span><br><span class="line"><span class="comment">;;(3.7617560672361973e+25 3.2100444948749963e+25)</span></span><br><span class="line"><span class="comment">;;(3.2100444948749963e+25 3.1626330556312044e+25)</span></span><br><span class="line"><span class="comment">;;(3.1626330556312044e+25 3.1622776801368567e+25)</span></span><br><span class="line"><span class="comment">;;3.1626330556312044e+25</span></span><br></pre></td></tr></table></figure>
<p>程序没有卡死，也能求出近似值。现在程序还有问题吗？有的，很明显是 <code>(sqrt 0)</code>，千万不要轻易尝试后果很严重（认真脸）</p>
<h3 id="习题-1-8"><a href="#习题-1-8" class="headerlink" title="习题 1.8"></a>习题 1.8</h3><blockquote>
<p><strong>Exercise 1.8.</strong>  Newton’s method for cube roots is based on the fact that if <em>y</em> is an approximation to the cube root of <em>x</em>, then a better approximation is given by the value<br>$$<br>\frac{x/y^2 + 2y}{3}<br>$$<br>Use this formula to implement a cube-root procedure analogous to the square-root procedure. (In section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.4" target="_blank" rel="noopener">1.3.4</a> we will see how to implement Newton’s method in general as an abstraction of these square-root and cube-root procedures.)</p>
</blockquote>
<p>题目中已经给出从一个近似值得到更好的近似值的式子。仿造 <code>sqrt</code> 函数，修改 <code>improve</code> 即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube</span> x) (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">square</span> x) x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.0001</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">cube</span> guess) x)) tolerance))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span> guess x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">/</span></span> x (<span class="name">square</span> guess))</span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> guess))</span><br><span class="line">     <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube-root-iter</span> guess x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">      guess</span><br><span class="line">      (<span class="name">cube-root-iter</span> (<span class="name">improve</span> guess x) x)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube-root</span> x)</span><br><span class="line">  (<span class="name">cube-root-iter</span> <span class="number">1.0</span> x))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cube-root</span> <span class="number">8</span>)</span><br><span class="line"><span class="comment">;; 2</span></span><br><span class="line">(<span class="name">cube-root</span> <span class="number">27</span>)</span><br><span class="line"><span class="comment">;; 3</span></span><br><span class="line">(<span class="name">cube-root</span> (<span class="name">cube</span> <span class="number">27</span>))</span><br><span class="line"><span class="comment">;; 27</span></span><br></pre></td></tr></table></figure>
<p>也可以写成封装的形式</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube-root</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube</span> x) (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">square</span> x) x))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.0001</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">cube</span> guess) x)) tolerance))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">/</span></span> x (<span class="name">square</span> guess))</span><br><span class="line">          (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> guess))</span><br><span class="line">       <span class="number">3</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube-root-iter</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span> guess)</span><br><span class="line">        guess</span><br><span class="line">        (<span class="name">cube-root-iter</span> (<span class="name">improve</span> guess))))</span><br><span class="line">  (<span class="name">cube-root-iter</span> <span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>
<p>注意到第二行 <code>(define (square x) (* x x))</code> 中的 <code>x</code> 产生了变量覆盖（shadowing），所以<code>(* x x)</code> 的 <code>x</code>其实是 <code>square</code> 的 <code>x</code> 而不是 <code>cube-root</code> 的 <code>x</code> 。编译器会正确区分，不会混淆。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本小节讲述了编程的几个要素。一是语言所关注的最基本元素，例如数字，算数操作符，变量定义等。二是元素的组合。如求平方，求平方根等都是最基本元素的组合。最后是抽象，阐述了一个问题是如何拆分成几个小问题，又是如何用基本元素组合解决。</p>
</div></article></div></main><footer><div class="paginator"><a href="/Recursive-lambda/" class="prev">上一篇</a><a href="/Non-alpha-Javascript/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://en.ors-sro.com">拖鞋党</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold; animation: breathe 3s infinite">Coding Pages</a></p></div></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [ ['$','$'], ["\\\(","\\)"] ],
    processEscapes: true
    }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});
</script></body></html>