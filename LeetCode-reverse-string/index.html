<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LeetCode -- Reverse String · 拖鞋党的拖鞋摊</title><meta name="description" content="LeetCode -- Reverse String - 拖鞋党"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://en.ors-sro.com/atom.xml" title="拖鞋党的拖鞋摊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/icon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/rss/" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">LeetCode -- Reverse String</h1><div class="post-info">Jul 18, 2016</div><div class="post-content"><p>找不到工作，刷刷 Leetcode 来保持一下写代码的手感。从最简单的开始，也就是 Acceptance 最高的开始。目前接受率最高的是<a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">逆序字符串</a></p>
<a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>编写一个函数能够逆序输出字符串<br><strong> 例子 </strong><br>给定 <code>s = &quot;hello&quot;</code> 返回 <code>olleh</code></p>
</blockquote>
<p>总的来说是一个很简单的题目。<code>CS</code> 的学生估计都做过这道练手题。</p>
<h2 id="In-Haskell-Way"><a href="#In-Haskell-Way" class="headerlink" title="In Haskell Way"></a>In Haskell Way</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到这个题目就很自然的想到使用<strong>分治</strong>的思想。如果是空字符串则不需要逆序，直接返回即可。如果是长度为1的字符串</p>
<ol>
<li>如果是空字符串，不需要逆序，直接返回即可</li>
<li>如果不是空字符串，将除了第一个字符外的子字符串逆序，之后拼接上第一个字符串即可。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s.length() == <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> reverseString(s.substr(<span class="number">1</span>, s.length())) + s[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>在遇到超长字符时提示 <code>Memory Limit Exceeded</code> 。估计是因为递归的次数太多，调用次数太多而产生 <code>StackOverflow</code> （栈溢出）。所以下一步是要优化递归。通常的解决方案是将递归优化为<strong>尾递归</strong>。递归通常需要全部展开之后才能计算值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reverseString(&quot;Hello&quot;)</span><br><span class="line"></span><br><span class="line">	reverseString(&quot;ello&quot;) + &apos;H&apos;</span><br><span class="line"></span><br><span class="line">		reverseString(&quot;llo&quot;) + &apos;e&apos; + &apos;H&apos;</span><br><span class="line"></span><br><span class="line">			reverseString(&quot;lo&quot;) + &apos;l&apos; + &apos;e&apos; + &apos;H&apos;</span><br><span class="line"></span><br><span class="line">				reverseString(&apos;o&apos;) + &apos;l&apos; + &apos;l&apos; + &apos;e&apos; + &apos;H&apos;</span><br><span class="line"></span><br><span class="line">				&apos;o&apos; + &apos;l&apos; + &apos;l&apos; + &apos;e&apos; + &apos;H&apos; // 完全展开 开始计算</span><br><span class="line"></span><br><span class="line">			&quot;ol&quot; + &apos;l&apos; + &apos;e&apos; + &apos;H&apos;</span><br><span class="line"></span><br><span class="line">		&quot;oll&quot; + &apos;e&apos; + &apos;H&apos;</span><br><span class="line"></span><br><span class="line">	&quot;olle&quot; + &apos;H&apos;</span><br><span class="line"></span><br><span class="line">&quot;olleH&quot;</span><br></pre></td></tr></table></figure>
<p>尾递归是将计算结果传递到下一次递归中。因此之前的任何信息都不需要保存了，清理栈中的参数和返回地址等。这样就不会出现 <code>StackOverflow</code> 。当然这一步是编译器做的优化工作。</p>
<h2 id="In-Tail-Recursion-Way"><a href="#In-Tail-Recursion-Way" class="headerlink" title="In Tail Recursion Way"></a>In Tail Recursion Way</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>尾递归需要把计算结果传递到下一次递归中。纯函数的唯一输入只有参数。所以需要通过传递参数的方式将计算结果传递。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseStringTailRecursion</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> result = <span class="string">""</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> reverseStringTailRecursion(s.substr(<span class="number">1</span>, s.length()), s[<span class="number">0</span>] + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> reverseStringTailRecursion(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>先来看一下尾递归版本的计算过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">reverseString(&quot;Hello&quot;)</span><br><span class="line"></span><br><span class="line">reverseStringTailRecursion(&quot;Hello&quot;,&quot;&quot;)</span><br><span class="line"></span><br><span class="line">reverseStringTailRecursion(&quot;ello&quot;,&apos;H&apos; + &quot;&quot;)</span><br><span class="line"></span><br><span class="line">reverseStringTailRecursion(&quot;llo&quot;,&apos;e&apos; + &apos;H&apos;)</span><br><span class="line"></span><br><span class="line">reverseStringTailRecursion(&quot;lo&quot;,&apos;l&apos; + &quot;eH&quot;)</span><br><span class="line"></span><br><span class="line">reverseStringTailRecursion(&apos;o&apos;,&apos;l&apos; + &quot;leH&quot;)</span><br><span class="line"></span><br><span class="line">reverseStringTailRecursion(&quot;&quot;,&apos;o&apos; + &quot;lleH&quot;)</span><br><span class="line"></span><br><span class="line">&quot;olleH&quot;</span><br></pre></td></tr></table></figure>
<p>可以发现每一次的计算都与之前的函数不再有关系，只与参数有关。从形状上来看，普通递归是一个箭头型 <code>&gt;</code> 。而尾递归是一个直筒型 <code>≡</code> 。信心满满的提交。最后报错，错误和上次一样 <code>StackOverflow</code> 。 看来编译环境没有开启尾递归优化。只好另行他法。既然不允许递归，那就想办法消除递归。通过观察普通递归的计算过程发现其分为<strong>展开</strong>和<strong>计算</strong>两个阶段。展开阶段会栈溢出。所以想办法去掉展开阶段，转为普通的循环即可。观察计算的过程，发现是从尾部开始拼接字符串。那么循环从尾部开始即可。</p>
<h2 id="In-Loop-Way"><a href="#In-Loop-Way" class="headerlink" title="In Loop Way"></a>In Loop Way</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>从尾部开始去字符串，一直拼接，拼接到字符串第一个字符。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		result += s[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>通过 476 个测试用例，用时 13ms 。超过 25.5% 的人（C++）。总算是通过了。不过似乎成绩不是很理想，居然连一半的人都没有超过。仔细想想还是有优化空间的。现在的时间复杂度是 <code>O(n)</code>, 空间复杂度是 <code>O(1)</code> 。看起来似乎是很优秀的数据。但是逆序的过程需要额外的一个字符串来承载结果。能否做成原地（In Place）的呢？答案是肯定的。</p>
<h2 id="In-Place-Way"><a href="#In-Place-Way" class="headerlink" title="In Place Way"></a>In Place Way</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>交换首尾字符直至完成。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = s.length() - <span class="number">1</span>; <span class="comment">//s.length() 位置是 '\0'</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(s[i++], s[j--]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><p>通过 476 个测试用例，用时 12ms 。超过 29% 的人（C++）。噗，只提升了 5% 。不知道前面的人是不是用了什么稀奇古怪的 <code>Hack</code> 。 尝试了传递参数时传递引用。发现时间没有变化。又尝试了其他方法，都没有什么效果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先是根据直觉写出递归的方式，然后优化为尾递归，发现编译环境没有做优化。于是改为循环，此时时间复杂度为 <code>O(n)</code> 。之后使用原地交换的方法将时间复杂度降为 <code>O(n/2)</code> 。最后还是没有找到更快的解决方案。如果有更快的方案，欢迎交流。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.zhihu.com/question/20761771/answer/19996299" target="_blank" rel="noopener">什么是尾递归</a></li>
<li><a href="http://stackoverflow.com/questions/33923/what-is-tail-recursion" target="_blank" rel="noopener">What is tail recursion</a></li>
<li><a href="http://blog.csdn.net/luoweifu/article/details/51470998" target="_blank" rel="noopener">C++ 性能分析</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/Remove-redundant-switch/" class="prev">PREV</a><a href="/Airbnb-es6-style-guide/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://en.ors-sro.com">拖鞋党</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold; animation: breathe 3s infinite">Coding Pages</a></p></div></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [ ['$','$'], ["\\\(","\\)"] ],
    processEscapes: true
    }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});
</script></body></html>