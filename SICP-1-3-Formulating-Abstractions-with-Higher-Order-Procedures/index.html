<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> SICP 1.3 用更高阶的过程阐述抽象 · 拖鞋党的拖鞋摊</title><meta name="description" content="SICP 1.3 用更高阶的过程阐述抽象 - 拖鞋党"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://en.ors-sro.com/atom.xml" title="拖鞋党的拖鞋摊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/icon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/rss/" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">SICP 1.3 用更高阶的过程阐述抽象</h1><div class="post-info">Jan 29, 2017</div><div class="post-content"><p>再次填坑。<br><a id="more"></a></p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>本章主要讲了过程作为第一公民的用法与作用。</p>
<p>主要有四点</p>
<ul>
<li>过程可以通过变量命名</li>
<li>过程可以通过参数传递</li>
<li>过程可以通过过程返回</li>
<li>过程可以包含在结构中</li>
</ul>
<p>Scheme 语言在这方面比较灵活。不像有的语言想要传递一个过程还得要先封装一个类通过实例才能传递。更不像有的语言一个 lambda 语法设计得那么复杂又没有品味。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="习题-1-29"><a href="#习题-1-29" class="headerlink" title="习题 1.29"></a>习题 1.29</h3><blockquote>
<p><strong>Exercise 1.29.</strong>  Simpson’s Rule is a more accurate method of numerical integration than the method illustrated above. Using Simpson’s Rule, the integral of a function $f$ between $a$ and $b$ is approximated as<br>$$<br>\frac{h}{3}[y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + …+ 2y_{n-2} + 4y_{n-1} + y_n]<br>$$<br>where $h = (b - a)/n$ , for some even integer $n$, and $y_k = f(a + kh)$. (Increasing $n$ increases the accuracy of the approximation.) Define a procedure that takes as arguments $f$, $a$, $b$, and $n$ and returns the value of the integral, computed using Simpson’s Rule. Use your procedure to integrate cube between 0 and 1 (with $n = 100$ and $n = 1000$), and compare the results to those of theintegral procedure shown above.</p>
</blockquote>
<p>这道题要用到之前的求和函数。</p>
<p>显然需要的求和的部分就是一系列的 $y$ 。</p>
<p>范围为 $[0,n]$ 。</p>
<p>通过观察可以发现 $y_m$ 前面的系数 $times$ 的规律为<br>$$<br>times =<br>\begin{cases}<br>1, &amp; m = 0,n<br>\2, &amp; m \bmod 2 = 0<br>\4, &amp; m \bmod 2 = 1<br>\end{cases}<br>$$<br>然后按照公式翻译成代码就可以了。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum</span> term a next b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">term</span> a)</span><br><span class="line">         (<span class="name">sum</span> term (<span class="name">next</span> a) next b))))</span><br><span class="line">         </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">integral</span> f a b n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> h (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">-</span></span> b a) n))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">y</span> k) (<span class="name">f</span> (<span class="name"><span class="builtin-name">+</span></span> a (<span class="name"><span class="builtin-name">*</span></span> k h))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">times</span> m)</span><br><span class="line">            (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">even?</span></span> m) <span class="number">2</span> <span class="number">4</span>))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">item</span> m)</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> m <span class="number">0</span>) (<span class="name">y</span> m))</span><br><span class="line">              ((<span class="name"><span class="builtin-name">=</span></span> m n) (<span class="name">y</span> n))</span><br><span class="line">              (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">times</span> m) (<span class="name">y</span> m)))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">/</span></span> h <span class="number">3</span>) (<span class="name">sum</span> item <span class="number">0</span> inc n)))</span><br><span class="line">    </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x x))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">integral</span> cube <span class="number">0</span> <span class="number">1</span> <span class="number">100</span>)</span><br><span class="line"><span class="comment">; 1/4</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-30"><a href="#习题-1-30" class="headerlink" title="习题 1.30"></a>习题 1.30</h3><blockquote>
<p><strong>Exercise 1.30.</strong>  The sum procedure above generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum</span> term a next b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> a result)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> &lt;??&gt;</span><br><span class="line">        &lt;??&gt;</span><br><span class="line">        (<span class="name">iter</span> &lt;??&gt; &lt;??&gt;)))</span><br><span class="line">  (<span class="name">iter</span> &lt;??&gt; &lt;??&gt;))</span><br></pre></td></tr></table></figure>
<p>这道题只需要找出迭代的退出边界和迭代的等式就可以了。</p>
<p>显然退出的条件与递归一致，当下边界 $a$ 大于上边界 $b$ 时退出。</p>
<p>递推式为<br>$$<br>result = result + term(a)<br>$$<br>所以答案是</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum</span> term a next b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> a result)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">        result</span><br><span class="line">        (<span class="name">iter</span> (<span class="name">next</span> a) (<span class="name"><span class="builtin-name">+</span></span> result (<span class="name">term</span> a)))))</span><br><span class="line">  (<span class="name">iter</span> a <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">identity</span> x) x)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br><span class="line">(<span class="name">sum</span> identity <span class="number">1</span> inc <span class="number">100</span>)</span><br><span class="line"><span class="comment">; 5050</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-31"><a href="#习题-1-31" class="headerlink" title="习题 1.31"></a>习题 1.31</h3><blockquote>
<p><strong>Exercise 1.31.</strong><br>a.  The sum procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures.<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#footnote_Temp_95" target="_blank" rel="noopener">51</a> Write an analogous procedure called product that returns the product of the values of a function at points over a given range. Show how to define factorial in terms of product. Also use product to compute approximations to $\pi$ using the formula <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#footnote_Temp_96" target="_blank" rel="noopener">52</a></p>
<p>$$<br>\frac{\pi}{4} = \frac{2 \cdot 4 \cdot 4 \cdot 6 \cdot 6 \cdot 8 \cdot …}{3 \cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \cdot …}<br>$$<br>b.  If your product procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p>
</blockquote>
<p>仿照 <code>sum</code> 编写，把其中的 <code>+</code> 替换成 <code>*</code> 即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">product</span> term a next b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">term</span> a)</span><br><span class="line">            (<span class="name">product</span> term (<span class="name">next</span> a) next b))))</span><br></pre></td></tr></table></figure>
<p>接着求 $\pi$ 的近似值。</p>
<p>$\frac{\pi}{4}$ 的展开式可以拆成一个个分数连乘，也可以看作两个连乘做除法。</p>
<p>这里选择当作两个连乘序列来处理。</p>
<p>分子序列 $n_k$ 通过观察可得<br>$$<br>n_k =  \lfloor k / 2\rfloor \times 2 + 2<br>$$<br>分母序列 $m_k$ 通过观察可得<br>$$<br>m_k = \lfloor (k+1)/2 \rfloor \times 2 + 1<br>$$<br>做除法即可</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">n</span> k) (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">quotient</span></span> k <span class="number">2</span>) <span class="number">2</span>) <span class="number">2.0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">m</span> k) (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">quotient</span></span> (<span class="name"><span class="builtin-name">+</span></span> k <span class="number">1</span>) <span class="number">2</span>) <span class="number">2</span>) <span class="number">1.0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">identity</span> x) x)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">pi</span> k)</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> <span class="number">4</span> (<span class="name"><span class="builtin-name">/</span></span> (<span class="name">product</span> n <span class="number">1</span> inc k)</span><br><span class="line">            (<span class="name">product</span> m <span class="number">1</span> inc k))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">pi</span> <span class="number">100</span>)</span><br><span class="line"><span class="comment">; 3.1570301764551667</span></span><br><span class="line"><span class="comment">; 收敛得很慢</span></span><br></pre></td></tr></table></figure>
<p>接着实现阶乘。</p>
<p>阶乘的定义为<br>$$<br>n! = n \times (n-1) \times (n-2) \times … \times 2 \times 1<br>$$<br>所以从 $1$ 乘到 $n$ 即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">identity</span> x) x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br><span class="line">    (<span class="name">product</span> identity <span class="number">1</span> inc n))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">factorial</span> <span class="number">5</span>)</span><br><span class="line"><span class="comment">; 120</span></span><br></pre></td></tr></table></figure>
<p>然后把递归形式改成迭代形式。参照 <code>sum</code> 可得</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">product</span> term a next b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> a result)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">            result</span><br><span class="line">            (<span class="name">iter</span> (<span class="name">next</span> a) (<span class="name"><span class="builtin-name">*</span></span> result (<span class="name">term</span> a)))))</span><br><span class="line">    (<span class="name">iter</span> a <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="习题-1-32"><a href="#习题-1-32" class="headerlink" title="习题 1.32"></a>习题 1.32</h3><blockquote>
<p><strong>Exercise 1.32.</strong>  a. Show that sum and product(exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_thm_1.31" target="_blank" rel="noopener">1.31</a>) are both special cases of a still more general notion called accumulate that combines a collection of terms, using some general accumulation function:</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">accumulate</span> combiner null-value term a next b)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Accumulate takes as arguments the same term and range specifications as sum and product, together with a combiner procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a null-value that specifies what base value to use when the terms run out. Write accumulate and show how sum and product can both be defined as simple calls to accumulate.</p>
<p>b. If your accumulate procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p>
</blockquote>
<p>提取出 <code>sum</code> 和 <code>product</code> 的共同部分即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">accumulate</span> combiner null-value term a next b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">        null-value</span><br><span class="line">        (<span class="name">combiner</span> (<span class="name">term</span> a)</span><br><span class="line">                  (<span class="name">accumulate</span> combiner null-value term (<span class="name">next</span> a) next b))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">product</span> term a next b)</span><br><span class="line">    (<span class="name">accumulate</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x y) (<span class="name"><span class="builtin-name">*</span></span> x y)) <span class="number">1</span> term a next b))</span><br></pre></td></tr></table></figure>
<p>迭代版</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">accumulate</span> combiner null-value term a next b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> a result)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">            result</span><br><span class="line">            (<span class="name">iter</span> (<span class="name">next</span> a) (<span class="name">combiner</span> result (<span class="name">term</span> a)))))</span><br><span class="line">    (<span class="name">iter</span> a null-value))</span><br></pre></td></tr></table></figure>
<h3 id="习题-1-33"><a href="#习题-1-33" class="headerlink" title="习题 1.33"></a>习题 1.33</h3><blockquote>
<p><strong>Exercise 1.33.</strong>  You can obtain an even more general version of accumulate (exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_thm_1.32" target="_blank" rel="noopener">1.32</a>) by introducing the notion of a <strong>filter</strong> on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting filtered-accumulate abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write filtered-accumulate as a procedure. Show how to express the following using filtered-accumulate:</p>
<p>a. the sum of the squares of the prime numbers in the interval $a$ to $b$ (assuming that you have a prime? predicate already written)</p>
<p>b. the product of all the positive integers less than $n$ that are relatively prime to $n$ (i.e., all positive integers $i &lt; n$ such that $GCD(i,n) = 1$).</p>
</blockquote>
<p>先实现 <code>filtered-accumulate</code> </p>
<p>这个只需要在 <code>accumulate</code> 的基础上加上一个 filter 如果通过过滤则 <code>(term a)</code> 没有就是 <code>null-value</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">filtered-accumulate</span> filter combiner null-value term a next b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">        null-value</span><br><span class="line">        (<span class="name">combiner</span> (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">filter</span> a) (<span class="name">term</span> a) null-value)</span><br><span class="line">                  (<span class="name">filtered-accumulate</span> filter combiner null-value term (<span class="name">next</span> a) next b))))</span><br></pre></td></tr></table></figure>
<p>用 <code>filtered-accumulate</code> 实现 <code>accumulate</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">accumulate</span> combiner null-value term a next b)</span><br><span class="line">  	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">no-filter</span> x) <span class="literal">#t</span>)</span><br><span class="line">    (<span class="name">filtered-accumulate</span> no-filter combiner null-value term a next b))</span><br></pre></td></tr></table></figure>
<p>再用 <code>accumulate</code> 实现 <code>sum</code> 和 <code>product</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum</span> term a next b)</span><br><span class="line">  	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">plus</span> x y) (<span class="name"><span class="builtin-name">+</span></span> x y))</span><br><span class="line">  	(<span class="name">accumulate</span> plus <span class="number">1</span> term a next b))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">product</span> term a next b)</span><br><span class="line">  	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">times</span> x y) (<span class="name"><span class="builtin-name">*</span></span> x y))</span><br><span class="line">    (<span class="name">accumulate</span> times <span class="number">1</span> term a next b))</span><br></pre></td></tr></table></figure>
<p>现在解决第一个问题，求 a 到 b 所有素数的平方和</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-of-square-primes</span> primes? a b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">plus</span> x y) (<span class="name"><span class="builtin-name">+</span></span> x y))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br><span class="line">  (<span class="name">filtered-accumulate</span> primes? plus <span class="number">0</span> square a inc b))</span><br></pre></td></tr></table></figure>
<p>然后解决第二个问题</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">product-of-all-positive-integer-less-than</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">relative-prime?</span> x) (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> (<span class="name"><span class="builtin-name">remainder</span></span> x n))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">times</span> x y) (<span class="name"><span class="builtin-name">*</span></span> x y))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">identity</span> x) x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br><span class="line">    (<span class="name">filtered-accumulate</span> relative-prime? times <span class="number">1</span> identity <span class="number">0</span> inc n))</span><br></pre></td></tr></table></figure>
<h3 id="习题-1-34"><a href="#习题-1-34" class="headerlink" title="习题 1.34"></a>习题 1.34</h3><blockquote>
<p><strong>Exercise 1.34.</strong>  Suppose we define the procedure<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> g)</span><br><span class="line">  (<span class="name">g</span> <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Then we have<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">f</span> square)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">(<span class="name">f</span> (<span class="name"><span class="builtin-name">lambda</span></span> (z) (<span class="name"><span class="builtin-name">*</span></span> z (<span class="name"><span class="builtin-name">+</span></span> z <span class="number">1</span>))))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>What happens if we (perversely) ask the interpreter to evaluate the combination <code>(f f)</code>? Explain.</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">f</span> f)</span><br><span class="line"><span class="comment">; 先对一个 f 求值，返回函数</span></span><br><span class="line"><span class="comment">; 对第二个 f 求值，返回函数</span></span><br><span class="line"><span class="comment">; 应用整个列表</span></span><br><span class="line"><span class="comment">; 将第二个 f 当作参数传给第一个 f</span></span><br><span class="line">(<span class="name">f</span> <span class="number">2</span>)</span><br><span class="line">(<span class="name">2</span> <span class="number">2</span>)</span><br><span class="line"><span class="comment">; 非法调用，2 不是一个函数。</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-35"><a href="#习题-1-35" class="headerlink" title="习题 1.35"></a>习题 1.35</h3><blockquote>
<p><strong>Exercise 1.35.</strong>  Show that the golden ratio $\phi$ (section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2" target="_blank" rel="noopener">1.2.2</a>) is a fixed point of the transformation $  x \rightarrow 1 + 1/x$, and use this fact to compute $\phi$ by means of the fixed-point procedure.</p>
</blockquote>
<p>直接调用<code>fixed-point</code>即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fixed-point</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">/</span></span> <span class="number">1</span> x))) <span class="number">1</span>)</span><br><span class="line"><span class="comment">; 987/610 = 1.618032786885246</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-36"><a href="#习题-1-36" class="headerlink" title="习题 1.36"></a>习题 1.36</h3><blockquote>
<p><strong>Exercise 1.36.</strong>  Modify fixed-point so that it prints the sequence of approximations it generates, using the newline and display primitives shown in exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_thm_1.22" target="_blank" rel="noopener">1.22</a>. Then find a solution to $x^x = 1000$ by finding a fixed point of $x \rightarrow \log{1000}/\log{x}$. (Use Scheme’s primitive log procedure, which computes natural logarithms.) Compare the number of steps this takes with and without average damping. (Note that you cannot start fixed-point with a guess of 1, as this would cause division by $\log{1} = 0$.)</p>
</blockquote>
<p>直接套用<code>fixed-point</code>即可。初始值不要选 $1$ 。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fixed-point</span> f first-guess)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough?</span> v1 v2)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> v1 v2)) tolerance))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">try</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">display</span></span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">next</span> (<span class="name">f</span> guess)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">close-enough?</span> guess next)</span><br><span class="line">          next</span><br><span class="line">          (<span class="name">try</span> next))))</span><br><span class="line">  (<span class="name">try</span> first-guess))</span><br><span class="line"></span><br><span class="line">(<span class="name">fixed-point</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">log</span></span> <span class="number">1000</span>) (<span class="name"><span class="builtin-name">log</span></span> x))) <span class="number">1.1</span>)</span><br><span class="line"><span class="comment">; 4.555538934848503</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-37"><a href="#习题-1-37" class="headerlink" title="习题 1.37"></a>习题 1.37</h3><blockquote>
<p><strong>Exercise 1.37.</strong>  a. An infinite <em>continued fraction</em>is an expression of the form<br>$$<br>f = \cfrac{N_1}{D_1+\cfrac{N_2}{D_2 + \cfrac{N_3}{D_3+ …}}}<br>$$<br>As an example, one can show that the infinite continued fraction expansion with the $N_i$ and the $D_i$ all equal to 1 produces $1/\phi$ , where $\phi$ is the golden ratio (described in section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2" target="_blank" rel="noopener">1.2.2</a>). One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms. Such a truncation – a so-called <em>k-term finite continued fraction</em> – has the form<br>$$<br>\cfrac{N_1}{D_1+\cfrac{N_2}{… + \cfrac{N_K}{D_K}}}<br>$$</p>
<p>Suppose that $n$ and $d$ are procedures of one argument (the term index $i$) that return the $N_i$ and $D_i$ of the terms of the continued fraction. Define a procedure cont-frac such that evaluating <code>(cont-frac n d k)</code> computes the value of the <em>k</em>-term finite continued fraction. Check your procedure by approximating  $1/\phi$ using<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cont-frac</span> (<span class="name"><span class="builtin-name">lambda</span></span> (i) <span class="number">1.0</span>)</span><br><span class="line">           (<span class="name"><span class="builtin-name">lambda</span></span> (i) <span class="number">1.0</span>)</span><br><span class="line">           k)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>for successive values of $k$. How large must you make $k$ in order to get an approximation that is accurate to 4 decimal places?</p>
<p>b. If your cont-frac procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p>
</blockquote>
<p>先根据递推式编写连分数代码。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cont-frac</span> n d k)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;=</span></span> k <span class="number">1</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">/</span></span> (<span class="name">n</span> <span class="number">1</span>) (<span class="name">d</span> <span class="number">1</span>))</span><br><span class="line">        (<span class="name"><span class="builtin-name">/</span></span> (<span class="name">n</span> k) (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">d</span> k) (<span class="name">cont-frac</span> n d (<span class="name"><span class="builtin-name">-</span></span> k <span class="number">1</span>))))))</span><br></pre></td></tr></table></figure>
<p>黄金分割率的 $D_i$ 和 $N_i$ 都是 $1$ </p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cont-frac-golden-ratio</span> k)</span><br><span class="line">    (<span class="name">cont-frac</span> (<span class="name"><span class="builtin-name">lambda</span></span> (i) <span class="number">1.0</span>)</span><br><span class="line">               (<span class="name"><span class="builtin-name">lambda</span></span> (i) <span class="number">1.0</span>)</span><br><span class="line">               k))</span><br></pre></td></tr></table></figure>
<p>接着解决精度问题。</p>
<p>计算不同的 $k$ 当两个值的差在误差之内则是想要的结果。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.00001</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">how-much</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> tolerance (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">cont-frac-golden-ratio</span> guess)</span><br><span class="line">                             (<span class="name">cont-frac-golden-ratio</span> (<span class="name"><span class="builtin-name">+</span></span> guess <span class="number">1</span>)))))</span><br><span class="line">        guess</span><br><span class="line">        (<span class="name">how-much</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> guess))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">how-much</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">; 12</span></span><br><span class="line"></span><br><span class="line">(<span class="name">cont-frac-golden-ratio</span> <span class="number">12</span>)</span><br><span class="line"><span class="comment">; 0.6180257510729613</span></span><br></pre></td></tr></table></figure>
<p>迭代版</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cont-frac</span> n d k)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> n d k result)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;=</span></span> k <span class="number">0</span>)</span><br><span class="line">            result</span><br><span class="line">            (<span class="name">iter</span> n d (<span class="name"><span class="builtin-name">-</span></span> k <span class="number">1</span>) (<span class="name"><span class="builtin-name">/</span></span> (<span class="name">n</span> k) (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">d</span> k) result)))))</span><br><span class="line">    (<span class="name">iter</span> n d k <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="习题-1-38"><a href="#习题-1-38" class="headerlink" title="习题 1.38"></a>习题 1.38</h3><blockquote>
<p><strong>Exercise 1.38.</strong>  In 1737, the Swiss mathematician Leonhard Euler published a memoir <strong>De Fractionibus Continuis</strong>, which included a continued fraction expansion for $e - 2$, where $e$ is the base of the natural logarithms. In this fraction, the $N_i$ are all 1, and the $D_i$ are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, …. Write a program that uses your cont-frac procedure from exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_thm_1.37" target="_blank" rel="noopener">1.37</a> to approximate $e$, based on Euler’s expansion.</p>
</blockquote>
<p>观察 $D_i$ 可得<br>$$<br>D_i =<br>\begin{cases}<br>1, &amp; i = 1, i \bmod 3 \ne 2<br>\2 \times (\lfloor i/3 \rfloor + 1),  &amp;\text{otherwise}<br>\end{cases}<br>$$<br>程序如下</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">d</span> i)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> i <span class="number">1</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">remainder</span></span> i <span class="number">3</span>) <span class="number">2</span>)</span><br><span class="line">            (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">quotient</span></span> i <span class="number">3</span>)))</span><br><span class="line">            <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">euler-method</span> k)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> (<span class="name">cont-frac</span> (<span class="name"><span class="builtin-name">lambda</span></span> (i) <span class="number">1.0</span>)</span><br><span class="line">                    d</span><br><span class="line">                    k)))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">euler-method</span> <span class="number">100</span>)</span><br><span class="line"><span class="comment">; 2.7182818284590455</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-39"><a href="#习题-1-39" class="headerlink" title="习题 1.39"></a>习题 1.39</h3><blockquote>
<p><strong>Exercise 1.39.</strong>  A continued fraction representation of the tangent function was published in 1770 by the German mathematician J.H. Lambert:<br>$$<br>\tan x = \cfrac{x}{1-\cfrac{x^2}{3-\cfrac{x^2}{5-…}}}<br>$$<br>where $x$ is in radians. Define a procedure <code>(tan-cf x k)</code> that computes an approximation to the tangent function based on Lambert’s formula. K specifies the number of terms to compute, as in exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_thm_1.37" target="_blank" rel="noopener">1.37</a>.</p>
</blockquote>
<p>观察分子 $n_i$  可得<br>$$<br>n_i =<br>\begin{cases}<br>x &amp; i = 1<br>\x^2 &amp; i \ne 1<br>\end{cases}<br>$$<br>$D_i$ 规律为<br>$$<br>D_i = (i - 1) \times 2 + 1<br>$$<br>仿照上面 <code>cont-frac</code> 的代码得</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cont-frac</span> n d k)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> n d k result)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;=</span></span> k <span class="number">0</span>)</span><br><span class="line">            result</span><br><span class="line">            (<span class="name">iter</span> n d (<span class="name"><span class="builtin-name">-</span></span> k <span class="number">1</span>) (<span class="name"><span class="builtin-name">/</span></span> (<span class="name">n</span> k) (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">d</span> k) result)))))</span><br><span class="line">    (<span class="name">iter</span> n d k <span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">tan-cf</span> x k)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">n</span> i)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> i <span class="number">1</span>)</span><br><span class="line">            x</span><br><span class="line">            (<span class="name"><span class="builtin-name">*</span></span> x x)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">d</span> i) (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2.0</span> (<span class="name"><span class="builtin-name">-</span></span> i <span class="number">1</span>))))</span><br><span class="line">    (<span class="name">cont-frac</span> n d k))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">tan-cf</span> <span class="number">1</span> <span class="number">100</span>)</span><br><span class="line"><span class="comment">; 1.557407724654902</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-40"><a href="#习题-1-40" class="headerlink" title="习题 1.40"></a>习题 1.40</h3><blockquote>
<p><strong>Exercise 1.40.</strong>  Define a procedure cubic that can be used together with the newtons-method procedure in expressions of the form<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">newtons-method</span> (<span class="name">cubic</span> a b c) <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>to approximate zeros of the cubic $x^3 + ax^2 + bx +c$ .</p>
</blockquote>
<p>将多项式写成代码即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.00001</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fixed-point</span> f first-guess)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough?</span> v1 v2)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> v1 v2)) tolerance))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">try</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">next</span> (<span class="name">f</span> guess)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">close-enough?</span> guess next)</span><br><span class="line">          next</span><br><span class="line">          (<span class="name">try</span> next))))</span><br><span class="line">  (<span class="name">try</span> first-guess))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> dx <span class="number">0.00001</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">deriv</span> g)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">g</span> (<span class="name"><span class="builtin-name">+</span></span> x dx)) (<span class="name">g</span> x))</span><br><span class="line">       dx)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">newton-transform</span> g)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">-</span></span> x (<span class="name"><span class="builtin-name">/</span></span> (<span class="name">g</span> x) ((<span class="name">deriv</span> g) x)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">newtons-method</span> g guess)</span><br><span class="line">  (<span class="name">fixed-point</span> (<span class="name">newton-transform</span> g) guess))</span><br><span class="line">  </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cubic</span> a b c )</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> x x x)</span><br><span class="line">                   (<span class="name"><span class="builtin-name">*</span></span> a (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line">                   (<span class="name"><span class="builtin-name">*</span></span> b x)</span><br><span class="line">                   c)))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">newtons-method</span> (<span class="name">cubic</span> <span class="number">1</span> <span class="number">1</span> (<span class="name"><span class="builtin-name">-</span></span> <span class="number">39</span>)) <span class="number">1.0</span>)</span><br><span class="line"><span class="comment">; 3.00000000000019504</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-41"><a href="#习题-1-41" class="headerlink" title="习题 1.41"></a>习题 1.41</h3><blockquote>
<p><strong>Exercise 1.41.</strong>  Define a procedure double that takes a procedure of one argument as argument and returns a procedure that applies the original procedure twice. For example, if inc is a procedure that adds 1 to its argument, then <code>(double inc)</code> should be a procedure that adds 2. What value is returned by<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((<span class="name">double</span> (<span class="name">double</span> double)) inc) <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">double</span> f)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name">f</span> (<span class="name">f</span> x))))</span><br><span class="line">    </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">(((<span class="name">double</span> (<span class="name">double</span> double)) inc) <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>分析</p>
<p><code>double(f)(x)</code> 等于 $f(f(x))$ 也就是 $f^2(x)$ </p>
<p>所以 <code>(double double)(f)(x)</code> 等于 $f^2(f^2(x))$ 也就是 $f^4(x)$ </p>
<p>那么 <code>(double (double double))(f)(x)</code> 等于 $f^4(f^4(x))$ 也就是 $f^{16}(x)$ </p>
<p><code>inc</code> 应用 16 次 则为 +16 。</p>
<p>$ 16 + 5 = 21 $ </p>
<p>所以答案是 21</p>
<h3 id="习题-1-42"><a href="#习题-1-42" class="headerlink" title="习题 1.42"></a>习题 1.42</h3><blockquote>
<p><strong>Exercise 1.42.</strong>  Let $f$ and $g$ be two one-argument functions. The <strong>composition</strong> $f$ after $g$ is defined to be the function $x \rightarrow  f(g(x))$ . Define a procedure compose that implements composition. For example, if inc is a procedure that adds 1 to its argument<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">compose</span> square inc) <span class="number">6</span>)</span><br><span class="line"><span class="number">49</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>返回一个函数即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compose</span> f g)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name">f</span> (<span class="name">g</span> x))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">compose</span> square inc) <span class="number">6</span>)</span><br><span class="line"><span class="comment">; 49</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-43"><a href="#习题-1-43" class="headerlink" title="习题 1.43"></a>习题 1.43</h3><blockquote>
<p><strong>Exercise 1.43.</strong>  If $f$ is a numerical function and $n$ is a positive integer, then we can form the $n$th repeated application of $f$, which is defined to be the function whose value at $x$ is $f(f(…(f(x))…))$ .  For example, if $f$ is the function $x \rightarrow x + 1$ , then the $n$th repeated application of $f$ is the function $x \rightarrow x + n$. If $f$ is the operation of squaring a number, then the $n$th repeated application of $f$ is the function that raises its argument to the $2^n$th power. Write a procedure that takes as inputs a procedure that computes $f$ and a positive integer $n$ and returns the procedure that computes the $n$th repeated application of $f$. Your procedure should be able to be used as follows:<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">repeated</span> square <span class="number">2</span>) <span class="number">5</span>)</span><br><span class="line"><span class="number">625</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Hint: You may find it convenient to use composefrom exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_thm_1.42" target="_blank" rel="noopener">1.42</a>.</p>
</blockquote>
<p>重复应用的递推式为<br>$$<br>f^n(x) = f(f^{n-1}(x))<br>$$<br>代码如下</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">repeat</span> f n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;=</span></span> n <span class="number">1</span>)</span><br><span class="line">        f</span><br><span class="line">        (<span class="name">compose</span> f (<span class="name">repeat</span> f (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">repeat</span> inc <span class="number">10</span>) <span class="number">2</span>)</span><br><span class="line"><span class="comment">; 12</span></span><br><span class="line">((<span class="name">repeat</span> square <span class="number">2</span>) <span class="number">5</span>)</span><br><span class="line"><span class="comment">; 625</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-44"><a href="#习题-1-44" class="headerlink" title="习题 1.44"></a>习题 1.44</h3><blockquote>
<p><strong>Exercise 1.44.</strong>  The idea of <em>smoothing</em> a function is an important concept in signal processing. If $f$ is a function and $dx$ is some small number, then the smoothed version of $f$ is the function whose value at a point $x$ is the average of $f(x - dx)$ ,$f(x)$, and $f(x + dx)$ . Write a procedure smooth that takes as input a procedure that computes $f$ and returns a procedure that computes the smoothed $f$. It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtained the <em>n-fold smoothed function</em>. Show how to generate the <em>n</em>-fold smoothed function of any given function usingsmooth and repeated from exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_thm_1.43" target="_blank" rel="noopener">1.43</a>.</p>
</blockquote>
<p>这个比较简单，直接按定义写代码即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">smooth</span> f)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> dx <span class="number">0.00001</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> x y z) (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x y z) <span class="number">3</span>))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (x) </span><br><span class="line">        (<span class="name">average</span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">-</span></span> x dx)) (<span class="name">f</span> x) (<span class="name">f</span> (<span class="name"><span class="builtin-name">+</span></span> x dx)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fold-smooth</span> f n)</span><br><span class="line">    ((<span class="name">repeat</span> smooth n) f))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">smooth</span> square) <span class="number">2</span>)</span><br><span class="line"><span class="comment">; 4.000000000006667</span></span><br><span class="line">(fold-smooth square 10) 2)</span><br><span class="line"><span class="comment">; 4.000000000666667</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-1-45"><a href="#习题-1-45" class="headerlink" title="习题 1.45"></a>习题 1.45</h3><blockquote>
<p><strong>Exercise 1.45.</strong>  We saw in section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.3" target="_blank" rel="noopener">1.3.3</a> that attempting to compute square roots by naively finding a fixed point of $y \rightarrow  x/y$  does not converge, and that this can be fixed by average damping. The same method works for finding cube roots as fixed points of the average-damped $y \rightarrow x/y^2$ . Unfortunately, the process does not work forfourth roots – a single average damp is not enough to make a fixed-point search for $y \rightarrow x/y^3$ converge. On the other hand, if we average damp twice (i.e., use the average damp of the average damp of $y \rightarrow x/y^3$) the fixed-point search does converge. Do some experiments to determine how many average damps are required to compute $n$th roots as a fixed-point search based upon repeated average damping of $y \rightarrow x/y^{n-1}$. Use this to implement a simple procedure for computing $n$th roots using fixed-point, average-damp, and the repeatedprocedure of exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_thm_1.43" target="_blank" rel="noopener">1.43</a>. Assume that any arithmetic operations you need are available as primitives.</p>
</blockquote>
<p>组合之前的 <code>repeat</code> <code>fixed-point</code> 和 <code>average-damp</code> 即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.00001</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fixed-point</span> f first-guess)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough?</span> v1 v2)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> v1 v2)) tolerance))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">try</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">next</span> (<span class="name">f</span> guess)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">close-enough?</span> guess next)</span><br><span class="line">          next</span><br><span class="line">          (<span class="name">try</span> next))))</span><br><span class="line">  (<span class="name">try</span> first-guess))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average-damp</span> f)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name">average</span> x (<span class="name">f</span> x))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">nth-root</span> n x)</span><br><span class="line">    (<span class="name">fixed-point</span> ((<span class="name">repeat</span> average-damp n) (<span class="name"><span class="builtin-name">lambda</span></span> (y) (<span class="name"><span class="builtin-name">/</span></span> x (<span class="name"><span class="builtin-name">expt</span></span> y (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))) <span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>
<p>经测试重复 n 次是可以的。</p>
<p>重复 $\frac{n}{2}$ 也是可以的。</p>
<p>但应该还有一个更确切的下界。需要通过数学推导得到。</p>
<h3 id="习题-1-46"><a href="#习题-1-46" class="headerlink" title="习题 1.46"></a>习题 1.46</h3><blockquote>
<p><strong>Exercise 1.46.</strong>  Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as <strong>iterative improvement</strong>. Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess. Write a procedure iterative-improvethat takes two procedures as arguments: a method for telling whether a guess is good enough and a method for improving a guess. Iterative-improveshould return as its value a procedure that takes a guess as argument and keeps improving the guess until it is good enough. Rewrite the sqrtprocedure of section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.7" target="_blank" rel="noopener">1.1.7</a> and the fixed-pointprocedure of section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.3" target="_blank" rel="noopener">1.3.3</a> in terms of iterative-improve.</p>
</blockquote>
<p>提取出共同部分即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iterative-improve</span> good-enough? improve)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> guess)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span> guess)</span><br><span class="line">            guess</span><br><span class="line">            (<span class="name">f</span> (<span class="name">improve</span> guess))))</span><br><span class="line">    f)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fixed-point</span> f first-guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.00001</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> x)</span><br><span class="line">        (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> x (<span class="name">f</span> x))) tolerance))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span> x) (<span class="name">f</span> x))</span><br><span class="line">    ((<span class="name">iterative-improve</span> good-enough? improve) first-guess))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.001</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess next)</span><br><span class="line">        (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> guess next)) tolerance))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span> guess)</span><br><span class="line">        (<span class="name">average</span> guess (<span class="name"><span class="builtin-name">/</span></span> x guess)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> a b)</span><br><span class="line">        (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> a b) <span class="number">2</span>))</span><br><span class="line">    ((<span class="name">iterative-improve</span> good-enough? improve) <span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fixed-point</span> cos <span class="number">1.0</span>)</span><br><span class="line"><span class="comment">; 0.7390822985224024</span></span><br><span class="line">(<span class="name"><span class="builtin-name">sqrt</span></span> <span class="number">9</span>)</span><br><span class="line"><span class="comment">; 3.000000001396984</span></span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/Whitespace/" class="prev">上一篇</a><a href="/Learn-you-a-Haskell-for-great-good-notes/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://en.ors-sro.com">拖鞋党</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold; animation: breathe 3s infinite">Coding Pages</a></p></div></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [ ['$','$'], ["\\\(","\\)"] ],
    processEscapes: true
    }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});
</script></body></html>