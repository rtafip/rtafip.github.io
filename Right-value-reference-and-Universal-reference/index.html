<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 右值引用和通用引用 · 拖鞋党的拖鞋摊</title><meta name="description" content="右值引用和通用引用 - 拖鞋党"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://en.ors-sro.com/atom.xml" title="拖鞋党的拖鞋摊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/icon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/rss/" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">右值引用和通用引用</h1><div class="post-info">Sep 24, 2017</div><div class="post-content"><p>C++ 一到店，所有人都便都看着他笑……「对呀对呀！……引用有四种写法，你知道么？」</p>
<a id="more"></a>
<h2 id="没有引用">没有引用</h2><p>编程初学者写一个交换函数，很可能是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然这样是不起作用的。有些人会从汇编的角度分析，有些人会从调用方式的角度分析。</p>
<p>最后修正后的 C 语言版本使用了指针。（使用宏的都拖出去续了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = *x;</span><br><span class="line">  *x = *y;</span><br><span class="line">  *y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为不恰当的使用指针很容易造成空指针的问题。所以 C++ 引入了引用。</p>
<h2 id="左值引用">左值引用</h2><p>C++ 使用引用版本的交换函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用本质上是自动解引用的指针。所以这段代码跟指针的版本原理差不多。</p>
<p>这时候的 C++ 还是守序善良。短短几年过去却变成了混乱邪恶的 C++ 11 。</p>
<h2 id="右值引用">右值引用</h2><p>C++ 11 引入了右值引用，用 <code>&amp;&amp;</code> 表示，对应的之前的引用称为左值引用，用 <code>&amp;</code> 表示。使用右值引用的交换函数版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp;&amp; x, <span class="keyword">int</span>&amp;&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而内置类型并没有移动构造函数，所以移动退化为复制。C++ 11 之前都是拷贝交换，C++ 11 引入右值引用后才实现了真正上的移动交换。如果使用自定义类区别就会明显一些。</p>
<h2 id="通用引用">通用引用</h2><p>通用的移动交换函数应该是这样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; x, T&amp; y)</span> </span>&#123;</span><br><span class="line">    T temp = <span class="built_in">std</span>::move(x);</span><br><span class="line">    x = <span class="built_in">std</span>::move(y);</span><br><span class="line">    y = <span class="built_in">std</span>::move(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code> 可以是 <code>int</code>  、<code>int &amp;</code>  和 <code>int &amp;&amp;</code> 等等，代入后可能特化为以下版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; &amp;x, <span class="keyword">int</span>&amp; &amp; y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp;&amp; &amp;x, <span class="keyword">int</span>&amp;&amp; &amp;y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样就出现了两个问题。</p>
<p>本来只有左值引用的时候模板函数只需要一两个特化版本。现在引入右值引用后还要写一个版本。</p>
<p>第二个问题是 <code>int&amp;&amp; &amp;</code> 是什么类型？</p>
<p>为了解决第一个问题，C++ 11 引入了通用引用，用 <code>&amp;&amp;</code> 表示。使用通用引用的版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp;&amp; x, T&amp;&amp; y)</span> </span>&#123;</span><br><span class="line">    T temp = <span class="built_in">std</span>::move(x);</span><br><span class="line">    x = <span class="built_in">std</span>::move(y);</span><br><span class="line">    y = <span class="built_in">std</span>::move(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题又来了。通用引用（<code>&amp;&amp;</code>）和右值引用（<code>&amp;&amp;</code>）是一样的吗？</p>
<p>答案是不一样的。那要怎么区分呢？</p>
<p>第二个问题的回答刚好解决了这个新问题。</p>
<p>实际上 C++ 是不允许创建引用的引用的。所以右值引用才可以用 &amp;&amp; 表示，不然到底是左值引用的左值引用还是单纯的右值引用？</p>
<p>但在 C++ 中还是有办法绕过限制，比如上面使用模板的方法来实现 <code>int&amp; &amp;</code> 的效果。</p>
<p>创建引用的引用是没有意义的，直接使用引用即可。所以有以下规约</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&amp; &amp; -&gt; &amp;</span></span><br><span class="line"><span class="meta">&amp;&amp; &amp; -&gt; &amp;&amp;</span></span><br><span class="line"><span class="meta">&amp; &amp;&amp; -&gt; &amp;</span></span><br><span class="line"><span class="meta">&amp;&amp; &amp;&amp; -&gt; &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>&amp; &amp;&amp; -&gt; &amp;</code> 和 <code>&amp;&amp; &amp;&amp; -&gt; &amp;&amp;</code> 都不会改变原有引用的左右性，所以参数声明为 <code>&amp;&amp;</code> 就表示，如果是左值引用，那么传进来还是左值引用。如果是右值引用，那么传进来还是右值引用。</p>
<p>因此 Scott Meyers 把 <code>&amp;&amp;</code> 命名为通用引用。</p>
<p>相应地模板只需要写一个 <code>T&amp;&amp;</code> 的特化版就可以了，这样的特性被称为完璧转发。</p>
<p>从规约上看，具体的类型如 <code>int&amp;&amp;</code> 就是右值引用，通用的类型 <code>T&amp;&amp;</code> 则是通用引用，左右性需要看传入参数的左右性。</p>
<h2 id="文章引用">文章引用</h2><p><a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers" target="_blank" rel="noopener">通用引用的定义</a></p>
<p><a href="https://stackoverflow.com/questions/20364297/why-universal-references-have-the-same-syntax-as-rvalue-references" target="_blank" rel="noopener">右值引用和通用引用的区别</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/APL/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://en.ors-sro.com">拖鞋党</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold; animation: breathe 3s infinite">Coding Pages</a></p></div></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [ ['$','$'], ["\\\(","\\)"] ],
    processEscapes: true
    }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});
</script></body></html>