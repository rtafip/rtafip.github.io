<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拖鞋党的拖鞋摊</title>
  <subtitle>写一些有的没的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://en.ors-sro.com/"/>
  <updated>2017-07-23T07:01:40.613Z</updated>
  <id>http://en.ors-sro.com/</id>
  
  <author>
    <name>拖鞋党</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 所有权借用机制</title>
    <link href="http://en.ors-sro.com/Ownership-and-Borrow-in-Rust/"/>
    <id>http://en.ors-sro.com/Ownership-and-Borrow-in-Rust/</id>
    <published>2017-07-23T06:58:41.000Z</published>
    <updated>2017-07-23T07:01:40.613Z</updated>
    
    <content type="html"><![CDATA[<p>我用裸指针三十年，一共也就崩掉了三（sán）万多个程序。YEAH!</p>
<a id="more"></a>
<h2 id="简介">简介</h2><p><a href="https://zh.wikipedia.org/wiki/Rust" target="_blank" rel="external">Rust</a> 是一个由 Mozilla 开发的，准则为 「安全、并发、实用」的编程语言。</p>
<p>其实就是一个带指针安全的现代版 C++ （大雾）。</p>
<p>Rust 的设计不允许空指针和悬空指针，如果有就会编译失败。</p>
<blockquote>
<p>Rust 有一个检查指针生命期间和指针冻结的系统，可以用来预防在 C++ 中许多的类型错误，甚至是用了<a href="https://zh.wikipedia.org/wiki/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" target="_blank" rel="external">智能指针</a>功能之后会发生的类型错误。</p>
</blockquote>
<h2 id="C++_看了都想打人">C++ 看了都想打人</h2><p>先来看一段 Rust 的代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2 = v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"v[0] is: &#123;&#125;"</span>, v[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>虽然语法跟 C++ 有区别，不过语义是类似的——声明了两个变量，并打印第一个变量中的一部分内容。</p>
<p>如果写成 C++ 这样的代码习以为常。</p>
<p>但是这段代码在 Rust 中会编译失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: use of moved value: `v`&#10;println!(&#34;v[0] is: &#123;&#125;&#34;, v[0]);&#10;                        ^</span><br></pre></td></tr></table></figure>
<h2 id="所有权">所有权</h2><p>在 Rust 中有一个所有权的概念。失去了所有权，将不能进行读取或者修改操作。</p>
<p>变量绑定（变量声明，函数调用等）会获得所有权。</p>
<p>所有权跟作用域绑定（通常是大括号）。离开作用域后，会自动释放资源。</p>
<p>Rust 中也有移动语义，如果将一个变量直接赋值给另一个变量，假设没有实现 Copy trait ，所有权会被移动到新的变量。</p>
<p>所以上面的报错信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: use of moved value: `v`&#10;println!(&#34;v[0] is: &#123;&#125;&#34;, v[0]);&#10;                        ^</span><br></pre></td></tr></table></figure>
<p>说的是使用了移动过的变量 <code>v</code>。一旦变量被移动过了，就禁止使用，就算 <code>v</code> 能指向正确的内容。</p>
<p>这么做是有原因的。</p>
<p>假设允许编译通过，可能会出现这样危险的代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2 = v;</span><br><span class="line"></span><br><span class="line">v2.truncate(<span class="number">2</span>); <span class="comment">// 截取前两个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"v[3] is: &#123;&#125;"</span>, v[<span class="number">3</span>]); <span class="comment">// BOOM!</span></span><br></pre></td></tr></table></figure>
<p>这是因为修改了内容而原来的指针并不知道，所以按照原来看起来正确的方式最终导致了错误。</p>
<h2 id="借用">借用</h2><p>有时候所有权转义会带来麻烦</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(v1: Vec&lt;<span class="keyword">i32</span>&gt;, v2: Vec&lt;<span class="keyword">i32</span>&gt;) -&gt; (Vec&lt;<span class="keyword">i32</span>&gt;, Vec&lt;<span class="keyword">i32</span>&gt;, <span class="keyword">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// 对 v1 和 v2 搞东搞西</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还所有权和返回函数结果</span></span><br><span class="line">    (v1, v2, <span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (v1, v2, answer) = foo(v1, v2);</span><br></pre></td></tr></table></figure>
<p>其实只是需要内容而不是所有权啊。</p>
<p>所以 Rust 还有借用的机制。</p>
<p>使用借用机制后是这样的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(v1: &amp;Vec&lt;<span class="keyword">i32</span>&gt;, v2: &amp;Vec&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 对 v1 和 v2 搞东搞西</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> answer = foo(&amp;v1, &amp;v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后还可以使用 v1 和 v2</span></span><br></pre></td></tr></table></figure>
<p>使用了借用机制之后没有所有权转移，自然就不用归还所有权了。</p>
<p>上面的引用是常数引用，不能修改。想修改需要使用 <code>mut</code> 关键字</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">    *y += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>借用机制类似与 C++ 的引用机制但是又有几个区别。</p>
<ol>
<li>可以有多个常数级借用（&amp;T）</li>
<li>只能有一个可修改借用 (&amp;mut T)</li>
</ol>
<p>而且一个资源只能有一种借用方式，要么是常数级借用，要么是可修改借用。</p>
<p>借用也是跟作用域绑定的。比如以下代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"></span><br><span class="line">    *y += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会编译失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: cannot borrow `x` as immutable because it is also borrowed as mutable&#10;    println!(&#34;&#123;&#125;&#34;, x);&#10;                   ^&#10;note: previous borrow ends here&#10;fn main() &#123;&#10;&#10;&#125;&#10;^</span><br></pre></td></tr></table></figure>
<p>这是因为 x 已经借用给 y 当作可修改借用。然后 <code>println!</code> 传递参数的时候需要常数级借用，前面说过一个资源只能有一种借用方式。 </p>
<p>如果改成这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x; <span class="comment">// y 借用开始</span></span><br><span class="line"></span><br><span class="line">        *y += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">// y 借用结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以了。因为 y 出了借用的作用域，借用就会自动归还。后面不会出现借用冲突的问题。</p>
<h2 id="走开！烦人的空悬指针">走开！烦人的空悬指针</h2><p>空悬指针（dangling pointer）通常是由释放后使用（use after free）产生的。</p>
<p>Rust 的借用机制会防止释放后使用发生。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y: &amp;<span class="keyword">i32</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    y = &amp;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, y);</span><br></pre></td></tr></table></figure>
<p>编译报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: `x` does not live long enough&#10;    y = &#38;x;&#10;         ^&#10;note: reference must be valid for the block suffix following statement 0 at&#10;2:16...&#10;let y: &#38;i32;&#10;&#123;&#10;    let x = 5;&#10;    y = &#38;x;&#10;&#125;&#10;&#10;note: ...but borrowed value is only valid for the block suffix following&#10;statement 0 at 4:18&#10;    let x = 5;&#10;    y = &#38;x;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>错误提示已经说得很清楚了。就是 <code>x</code> 苟活的时间不够长。因为 <code>x</code> 出了作用域后就不再可用，所以 <code>y</code> 也相应的不再可用。因此拒绝编译通过可以避免后面的释放后使用的问题。</p>
<h2 id="最后">最后</h2><p>Rust 的空指针的解决方案是 option type 。这里不再赘述了。</p>
<p>天下没有免费的午餐。Rust 又要高性能，还要零负担抽象（诶怎么说得那么像某语言），那么就只能付出用户心智负担和编译时间的代价了。</p>
<p>从源头上避免空指针和空悬指针是可以做到的，如果你还觉得不可能是因为你用的不是现代编程语言啊，科科！</p>
<p><a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html" target="_blank" rel="external">rust 官方入门</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我用裸指针三十年，一共也就崩掉了三（sán）万多个程序。YEAH!&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Rust" scheme="http://en.ors-sro.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>常见的 option type 评测</title>
    <link href="http://en.ors-sro.com/About-some-option-type-implementation/"/>
    <id>http://en.ors-sro.com/About-some-option-type-implementation/</id>
    <published>2017-07-16T09:08:33.000Z</published>
    <updated>2017-07-16T09:24:08.344Z</updated>
    
    <content type="html"><![CDATA[<p>才不是什么手机评测的格式呢。</p>
<a id="more"></a>
<h2 id="简介">简介</h2><p>option type 是一种用于消灭空指针（null pointer）的和类型（sum type）。</p>
<p>option 类型用于表达可能不存在值的语义，在很多语言中都有<a href="https://en.wikipedia.org/wiki/Option_type" target="_blank" rel="external">相应的实现</a>。</p>
<p>评测选取官方支持的 option ，而不是第三方实现库。</p>
<p>主要从是否杜绝空指针和是否方便做空检查（null check）这两点评测。</p>
<h2 id="C++_的_option">C++ 的 option</h2><p>C++ 17 开始有了 option 的官方实现 <code>std::optional</code></p>
<p>引用 <a href="http://en.cppreference.com/w/cpp/utility/optional" target="_blank" rel="external">cppreference</a> 的一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;optional&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// optional can be used as the return type of a factory that may fail</span></span><br><span class="line"><span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; create(<span class="keyword">bool</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Godzilla"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create(false) returned "</span></span><br><span class="line">              &lt;&lt; create(<span class="keyword">false</span>).value_or(<span class="string">"empty"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// optional-returning factory functions are usable as conditions of while and if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> str = create(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create(true) returned "</span> &lt;&lt; *str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>天啊！居然是手动做空检查！吓得我赶紧看了一下这个类的方法和辅助函数，居然没有 <code>map</code> 或者 <code>flatmap</code>。</p>
<p>这就是那种送到面前抄都抄错的教科书级例子。</p>
<p>为什么说手动做空检查是不受推荐的呢。</p>
<p>先忘掉 <code>std::optional</code> 的存在，回想以前的代码是怎么确保不会因为值不存在而崩溃的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>* pData = GetSomeThingMayReturnNull();</span><br><span class="line"><span class="keyword">if</span> (!pData) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value is "</span> &lt;&lt; *pData &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比上面使用 <code>std::optional</code> 的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> str = create(<span class="keyword">true</span>)) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create(true) returned "</span> &lt;&lt; *str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是做法完全一样？都是先空检查再使用值。没毛病。</p>
<p>但是如果做法都一样为什么还要引入 <code>std::optional</code> 类型？</p>
<p>而且引入 <code>std::optional</code> 对于空指针问题没有明显的改善。</p>
<p>程序员是人，人是会犯错误的。忘记做空检查是最常见的错误。所以才会有因为忘了做空检查导致空指针问题。</p>
<p>使用 <code>std::optional</code> 还是得手动做空检查，那跟直接使用 <code>nullptr</code> 表达空值有什么区别？</p>
<p>也就是使用 <code>std::optional</code> 没有办法杜绝空指针，有出错的可能，除非能证明所有对 <code>std::optional</code> 的使用前都做了空检查。</p>
<p>那是不是没有办法杜绝空指针？</p>
<p>答案是否定的。在强类型语言如 Haskell 中会强迫用户检测，否则编译失败。从而杜绝了运行时空指针。</p>
<p>所以 <code>std::optional</code> 错在没有强制做空检查，没有强制做空检查的原因是编译器没有给予支持而空检查和取值操作是分开的两步操作，而不是一步原子操作。</p>
<p>评测结果：不推荐使用</p>
<h2 id="Java_的_option">Java 的 option</h2><p>Java 8 也引入了 option type ，类名也是 <code>Optional</code></p>
<p>引用<a href="http://www.importnew.com/6675.html" target="_blank" rel="external">介绍 optional </a>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Optional实例，也可以通过方法返回值得到。</span></span><br><span class="line">    Optional&lt;String&gt; name = Optional.of(<span class="string">"Sanaulla"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建没有值的Optional实例，例如值为'null'</span></span><br><span class="line">    Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//isPresent方法用来检查Optional实例是否有值。</span></span><br><span class="line">    <span class="keyword">if</span> (name.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//调用get()返回Optional值。</span></span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//在Optional实例上调用get()抛出NoSuchElementException。</span></span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//ifPresent方法接受lambda表达式参数。</span></span><br><span class="line">    <span class="comment">//如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span></span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"The length of the value is: "</span> + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span></span><br><span class="line">    System.out.println(empty.orElse(<span class="string">"There is no value present!"</span>));</span><br><span class="line">    System.out.println(name.orElse(<span class="string">"There is some value!"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//orElseGet与orElse类似，区别在于传入的默认值。</span></span><br><span class="line">    <span class="comment">//orElseGet接受lambda表达式生成默认值。</span></span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//orElseThrow与orElse方法类似，区别在于返回值。</span></span><br><span class="line">      <span class="comment">//orElseThrow抛出由传入的lambda表达式/方法生成异常。</span></span><br><span class="line">      empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//map方法通过传入的lambda表达式修改Optonal实例默认值。 </span></span><br><span class="line">    <span class="comment">//lambda表达式返回值会包装为Optional实例。</span></span><br><span class="line">    Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//flatMap与map（Funtion）非常相似，区别在于lambda表达式的返回值。</span></span><br><span class="line">    <span class="comment">//map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span></span><br><span class="line">    <span class="comment">//但是flatMap方法的lambda返回值总是Optional类型。</span></span><br><span class="line">    upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//filter方法检查Optiona值是否满足给定条件。</span></span><br><span class="line">    <span class="comment">//如果满足返回Optional实例值，否则返回空Optional。</span></span><br><span class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(longName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//另一个示例，Optional值不满足给定条件。</span></span><br><span class="line">    Optional&lt;String&gt; anotherName = Optional.of(<span class="string">"Sana"</span>);</span><br><span class="line">    Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(shortName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8 的 <code>Optional</code> 有 <code>map</code> 和 <code>flatmap</code> 。很好。</p>
<p>最大的败笔在于提供了 <code>get()</code> 方法。</p>
<p>在没有提供之前可以保证代码不会有空指针。</p>
<p>提供 <code>get()</code> 后，就必须要手动做空检查。</p>
<p>这就跟 C++ 的 <code>std::optional</code> 一样。</p>
<p>根据墨菲定律，可能出错的终将会出错。所以很可能出现直接使用 <code>get()</code> 而忘了做空检查。</p>
<p>如果 <code>get()</code> 抛出的异常是编译时异常还好，这样不做空检查就会编译失败。</p>
<p>但是 <code>get()</code> 抛出的异常 <code>NoSuchElementException</code> 是运行时异常，简直就是变相的 <code>null</code>。</p>
<p>听说 <code>Optional</code> 还<a href="https://zhuanlan.zhihu.com/p/22492722" target="_blank" rel="external">可以是空指针</a>。</p>
<blockquote>
<p>讲个笑话。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Customer&gt; customer = customerService.retriveCustomerById(<span class="number">22492722</span>);</span><br><span class="line"></span><br><span class="line">customer.map(Customer::getName).orElse(<span class="string">"Hello world!"</span>);</span><br></pre></td></tr></table></figure>
<p>「retriveCustomerById返回null没有编译错误」</p>
</blockquote>
<p>哇！这就意味着你要先检查 <code>Optional</code> 是不是空，在检查里面有没有值。</p>
<p>简直是帮倒忙，不解决原有的问题还引入了新的问题。</p>
<p>评测结果：可以使用，不要使用 <code>get()</code> ，更不要使用 <code>orElse(null)</code> 。</p>
<h2 id="没有空指针的未来">没有空指针的未来</h2><p>在有了正确的 option type 后，你离没有空指针的代码只有一个语法糖的距离。</p>
<p>终有一天我们会跨入无空指针的时代。</p>
<p>到时回看这时的代码。</p>
<p>那一天，人类终于回想起了，曾经一度被空指针所支配的恐怖，还有被囚禁于空检查大括号中的那份屈辱。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;才不是什么手机评测的格式呢。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="option" scheme="http://en.ors-sro.com/tags/option/"/>
    
  </entry>
  
  <entry>
    <title>async 和 await</title>
    <link href="http://en.ors-sro.com/async-and-await/"/>
    <id>http://en.ors-sro.com/async-and-await/</id>
    <published>2017-07-09T10:11:19.000Z</published>
    <updated>2017-07-16T09:04:51.753Z</updated>
    
    <content type="html"><![CDATA[<p>你离异步只有一个语法糖的距离。</p>
<a id="more"></a>
<h2 id="syntax_sugar">syntax sugar</h2><p>使用 Promise 编写 JavaScript 异步代码已经司空见惯。</p>
<p>但是 Promise 写多了还是觉得有些繁琐。</p>
<p>对此，有了一个新的语法糖提案。</p>
<p>那就是 async 和 await 。</p>
<h2 id="async">async</h2><p>async 用于标识一个函数为异步函数。被标识的函数返回一个 Promise 。</p>
<p>也就是 async 其实只是一个语法糖。</p>
<p>内部的实现还是 Promise 。</p>
<p>相当于返回 Promise 的同步函数。</p>
<h2 id="await">await</h2><p>await 用于等待一个异步函数。</p>
<p>也就是用于取出 Promise 的值。</p>
<p>举一个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有标识了 async 的函数才能在函数体中使用 await 。不然会报错。</p>
<p>await 后面的代码会在 Promise resolve 后才执行。但是并不会造成程序阻塞。</p>
<p>因为底层还是用 Promise 实现的。</p>
<h2 id="new_era">new era</h2><p>用 async 和 await 改写<a href="/Promise">Promise 异步编程</a>的例子</p>
<p>Promise 的例子代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> data = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"数据拉取成功"</span>);</span><br><span class="line">		callback(data);</span><br><span class="line">	&#125;,<span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"拉取中……"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"处理中……"</span>);</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			data += <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">"处理数据完成"</span>);</span><br><span class="line">			resolve(data);</span><br><span class="line">		&#125;,<span class="number">2000</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"发送中……"</span>);	</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">"数据发送成功"</span>);</span><br><span class="line">			resolve(data);</span><br><span class="line">		&#125;,<span class="number">3000</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showSucess</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"恭喜充值成功游戏时间 +"</span> + data + <span class="string">"s!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">	getData(resolve)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.then(handleData).then(sendData).then(showSucess);</span><br></pre></td></tr></table></figure>
<p>用 async 和 await 改写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TakeSeveralSeconds</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ms = <span class="built_in">Math</span>.random() * <span class="number">1000</span> + <span class="number">1000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"耗时 "</span> + ms + <span class="string">" 毫秒"</span>)</span><br><span class="line">      resolve(ms)</span><br><span class="line">  &#125;, ms))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"拉取中……"</span>)</span><br><span class="line">  <span class="keyword">await</span> TakeSeveralSeconds()</span><br><span class="line">  <span class="keyword">var</span> data = <span class="number">0</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"数据拉取成功"</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"处理中……"</span>)</span><br><span class="line">  <span class="keyword">await</span> TakeSeveralSeconds()</span><br><span class="line">  data += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"处理数据完成"</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sendData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"发送中……"</span>)</span><br><span class="line">  <span class="keyword">await</span> TakeSeveralSeconds()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"数据发送成功"</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showSucess</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"恭喜充值成功游戏时间 +"</span> + data + <span class="string">"s!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="keyword">let</span> handledData = <span class="keyword">await</span> handleData(data)</span><br><span class="line">  <span class="keyword">let</span> sendedData = <span class="keyword">await</span> sendData(handledData)</span><br><span class="line">  showSucess(sendedData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 得到以下输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main()&#10;&#25289;&#21462;&#20013;&#8230;&#8230;&#10;Promise &#123;[[PromiseStatus]]: &#34;pending&#34;, [[PromiseValue]]: undefined&#125;&#10;&#32791;&#26102; 1438.6931921290636 &#27627;&#31186;&#10;&#25968;&#25454;&#25289;&#21462;&#25104;&#21151;&#10;&#22788;&#29702;&#20013;&#8230;&#8230;&#10;&#32791;&#26102; 1511.1830960750424 &#27627;&#31186;&#10;&#22788;&#29702;&#25968;&#25454;&#23436;&#25104;&#10;&#21457;&#36865;&#20013;&#8230;&#8230;&#10;&#32791;&#26102; 1644.7195288709415 &#27627;&#31186;&#10;&#25968;&#25454;&#21457;&#36865;&#25104;&#21151;&#10;&#24685;&#21916;&#20805;&#20540;&#25104;&#21151;&#28216;&#25103;&#26102;&#38388; +1s!</span><br></pre></td></tr></table></figure>
<h2 id="polyfill">polyfill</h2><p>从 Chrome 55 开始，Chrome 默认启用 async 和 await 。其他情况可以使用 babel 转译。</p>
<h2 id="by_the_way">by the way</h2><p>async 和 await 的本质是编译器做了 CPS 变换，新加的两个 Monad 的语法糖。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你离异步只有一个语法糖的距离。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="异步" scheme="http://en.ors-sro.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>邱奇数</title>
    <link href="http://en.ors-sro.com/Church-encoding/"/>
    <id>http://en.ors-sro.com/Church-encoding/</id>
    <published>2017-07-02T08:19:24.000Z</published>
    <updated>2017-07-02T08:28:52.672Z</updated>
    
    <content type="html"><![CDATA[<p>万物皆为 lambda</p>
<a id="more"></a>
<h2 id="定义">定义</h2><p>lambda 的语法和规约定义中都没有定义数字类型。</p>
<p>为了保持 lambda 的简洁性，数字类型的定义不是必须的，可以由定义导出。</p>
<p>根据皮亚诺公理，算数系统的构成由一个起点（1 或者 0），和一个后继函数。</p>
<p>0，1，2，3，4，5，6……只是一种符号，一种自然数的编码。自然数的编码不是唯一的。</p>
<p>如果你愿意你也可以使用零一二三四五六来编码。</p>
<p>邱奇数是一种 lambda 形式的自然数编码。</p>
<p>其中起点为 $ 0 = \lambda f . \lambda x . x$</p>
<p>后继函数为 $succ = \lambda n . \lambda f. \lambda x. f (n f x)$</p>
<p>根据定义 $0$ 的后继为 $1$ 。所以将 $0$ 带入后记函数 $succ$ 中得到</p>
<p>$ (\lambda n . \lambda f . \lambda x. f(n f x) 0)$</p>
<p>将 $0$ 代入得到。</p>
<p>$(\lambda n. \lambda f. \lambda x. f(n f x) (\lambda f . \lambda x . x))$</p>
<p>为了避免混淆，对 $0$ 使用 $\alpha$ 变换。</p>
<p>$(\lambda n. \lambda f. \lambda x .f(n f x) (\lambda a . \lambda b . b))$</p>
<p>应用 $n = \lambda a . \lambda b . b$</p>
<p>$\lambda f. \lambda x. f((\lambda a . \lambda b . b) (f x))$</p>
<p>继续规约 $ a = f $</p>
<p>$\lambda f . \lambda x. f((\lambda b. b)x)$</p>
<p>继续规约 $  b = x $</p>
<p>$\lambda f . \lambda x .f x$</p>
<p>类似的方法可以得到 1 到 n 的定义</p>
<p>$0 = \lambda f . \lambda x . x $</p>
<p>$1 = \lambda f . \lambda x . f x$</p>
<p>$2 = \lambda f . \lambda x . f (f x)$</p>
<p>$3 = \lambda f . \lambda x . f (f (f x))$</p>
<p>$4 = \lambda f . \lambda x . f (f (f (f x)))$</p>
<p>$5 = \lambda f . \lambda x . f (f (f (f (f x))))$</p>
<p>$6 = \lambda f . \lambda x . f (f (f (f (f (f x)))))$</p>
<p>$7 = \lambda f . \lambda x . f (f (f (f (f (f (f x))))))$</p>
<p>$8 = \lambda f . \lambda x . f (f (f (f (f (f (f (f x)))))))$</p>
<p>$9 = \lambda f . \lambda x . f (f (f (f (f (f (f (f (f x))))))))$</p>
<p>$n = \lambda f . \lambda x . f^n x$</p>
<p>邱奇数的编码是将自然数 n 转化为 n 的次方，也就是 n 次函数复合。</p>
<h2 id="运算">运算</h2><p>自然数运算最常见的是加减乘除。</p>
<p>先来定义最简单的加法。</p>
<p>$plus(m,n) = m + n$</p>
<p>因为邱奇数的编码是次方，所以 $f^{m+n}(x) = f^m(x) + f^n (x)$ 。</p>
<p>因此定义加法为 </p>
<p>$ plus = \lambda m . \lambda n. \lambda f. \lambda x . m f (n f x)$</p>
<p>类似的乘法定义为</p>
<p>$mult = \lambda m . \lambda n . \lambda f . n (m f)$</p>
<p>因为减法和除法会产生出界的情况，这里就不展开定义了。有兴趣的烦请移步<a href="https://en.wikipedia.org/wiki/Church_encoding" target="_blank" rel="external">维基百科</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;万物皆为 lambda&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="lambda" scheme="http://en.ors-sro.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>λ 演算</title>
    <link href="http://en.ors-sro.com/Lambda-calculus/"/>
    <id>http://en.ors-sro.com/Lambda-calculus/</id>
    <published>2017-06-25T08:43:56.000Z</published>
    <updated>2017-06-25T08:49:29.555Z</updated>
    
    <content type="html"><![CDATA[<p>是 $\lambda$ 演算不是入演算[滑稽]</p>
<a id="more"></a>
<h2 id="简介">简介</h2><p>lambda 表达式可以简单理解为匿名函数。</p>
<p>现在不少语言都加入了 lambda 表达式。就连名词王国 Java 也忍不住参与了。</p>
<p>一个普通的送命函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Plus</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 Java 中的 lambda 表达式是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>用 JavaScript 中的 lambda 表达式是这样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>用 Scheme 中的 lambda 表达式是这样的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">+</span> x <span class="number">1</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>用 C++ 中的 lambda 表达式是这样的（没错就是要和别的妖艳贱货不一样）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[=](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x + <span class="number">1</span>;&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 lambda 表达式能够方便函数的创建，传递，返回等，大大方便了编程，就不说某不思进取语言之前只能传递匿名类的故事了。</p>
<p>实际上 lambda 表达式源于 $\lambda$ 演算。</p>
<p>对编程有基本了解的人都应该知道图灵机，图灵机是目前能实现的最强计算模型。图灵机的运算是读写头在纸带上运动，可以说是非常工程派了。相应地，学术派中用于研究计算的是 $\lambda$ 演算，它拥有图灵机一样的运算能力。</p>
<h2 id="语法">语法</h2><p>$\lambda$ 演算的语法定义为</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= &lt;var&gt;</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (λ&lt;var&gt;.&lt;exp&gt;)</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (&lt;exp&gt; &lt;exp&gt;)</span><br></pre></td></tr></table></figure>
<p>第一条是变量抽象，即一个 $\lambda$ 项可以是一个变量。</p>
<p>第二条是函数抽象，即一个 $\lambda$ 项可以接收一个变量，返回一个 $\lambda$ 项。</p>
<p>第三条是函数应用，即一个 $\lambda$ 项可以应用一个 $\lambda$ 项。</p>
<p>比如对于 JavaScript 的 lambda 表达式 <code>x =&gt; x + 1</code> 可以表示为 $\lambda x. x + 1$ 。（假设 <code>+</code> 和 $1$ 都是良定的）。</p>
<p>第二条函数抽象限制了函数只有一个参数，那么遇到多个参数怎么办呢？</p>
<p>这里需要用到老生常谈的柯里化。</p>
<p>简单的说是将多参函数转化成多个单参函数的组合。</p>
<p>例如对于 <code>(x, y) =&gt; x + y</code> 相应的 $\lambda$ 项是 $\lambda x. (\lambda y. x + y)$ 。</p>
<p>为了手写方便，可以省略括号 $\lambda x . \lambda y . x + y$ 。</p>
<p>再次为了手写方便，可以省略为 $\lambda x y . x + y$ 。</p>
<h2 id="规约">规约</h2><p>光有语法肯定是不够的。还需要规约规则。</p>
<p>$\lambda$ 演算有三条规约规则。</p>
<p>$\alpha$ 替换（重命名）：替换被绑定变量不改变结果。如 $\lambda x. x + 1$ 和 $\lambda t . t + 1$ 是一样的。类似于编程语言中的函数参数重命名。</p>
<p>$\beta$ 规约（函数应用）：函数应用为函数形参替换为实参的过程。如 $((\lambda x. x + 1) 2)$ 的结果为 $2 + 1 = 3$ 。类似于编程语言中的函数应用。</p>
<p>$\eta$ 转换（外延性相等）：两个函数对于所有的参数得到的结果都一致。之所以称为外延性相等是如果把两个函数当作黑盒，那么它们是一致的。如果查看黑盒中的内容就会发现内容可能不一样。如 $\lambda x . f x$ 与 $f$ 外延性相等。举一个 JavaScript 的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(x =&gt; <span class="built_in">console</span>.log(x))</span><br><span class="line"><span class="comment">// 外延性相等于</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h2 id="例子">例子</h2><p>说了那么多可能只是知道一些概念，可以<a href="https://people.eecs.berkeley.edu/~gongliang13/lambda/" target="_blank" rel="external">在线运算</a>一些例子来加深理解。</p>
<p>想要更加深入了解可以前往<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="external">维基百科</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是 $\lambda$ 演算不是入演算[滑稽]&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="lambda" scheme="http://en.ors-sro.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>柯里-霍华德同构</title>
    <link href="http://en.ors-sro.com/Curry-Howard-correspondence/"/>
    <id>http://en.ors-sro.com/Curry-Howard-correspondence/</id>
    <published>2017-06-18T13:08:03.000Z</published>
    <updated>2017-06-18T13:16:47.631Z</updated>
    
    <content type="html"><![CDATA[<p>这真的只是一种巧合吗？</p>
<a id="more"></a>
<h2 id="命题与类型">命题与类型</h2><p>一个函数的类型可以是 <code>A -&gt; B -&gt; A</code> 。</p>
<p>一个命题的类型可以是 $\alpha \to \beta \to \alpha$ 。</p>
<p>可以发现，这两个类型是类似的。</p>
<p>类型 <code>A</code> 类似于命题 $\alpha$ 。</p>
<p>函数 <code>-&gt;</code> 类似于蕴含 $\to$ 。</p>
<p>实际上这是柯里-霍华德同构。</p>
<h2 id="定义">定义</h2><p><strong>柯里-霍华德同构</strong>揭示了计算机程序和数学证明之间的紧密联系。</p>
<p>类型即命题，程序即证明。</p>
<p>也就是函数的类型相当于命题，函数的实现相当于证明。这在 Coq 中体现得很明显。</p>
<p>用 <a href="https://www.zhihu.com/people/be5invis/answers" target="_blank" rel="external">be5</a> 大大<a href="https://zhihu.com/question/22959608/answer/24770830" target="_blank" rel="external">一针见血的解释</a>来说就是</p>
<blockquote>
<p>Lambda 演算同构为 Gentzen 的自然演绎</p>
<ul>
<li>函数调用就是蕴含消除</li>
<li>函数抽象就是蕴含介入</li>
<li>参数多态就是全称量化</li>
<li>模板类型就是谓词</li>
<li>结构类型就是合取</li>
<li>联合类型就是析取</li>
<li>收参数但不返回就是否定</li>
<li>高洋上的 call/cc 就是双重否定消除</li>
</ul>
</blockquote>
<h2 id="详述">详述</h2><p>函数调用的规则是<br>$$<br>{\Gamma\vdash t:\sigma\to\tau\quad\Gamma\vdash u:\sigma}\over{\Gamma\vdash t\,u : \tau}<br>$$<br>结果从 $\sigma\to\tau$ 变成 $\tau$ ，少了蕴含 $\to$ 所以称为蕴含消除。</p>
<p>相应的函数调用的逆操作函数抽象的规则是<br>$$<br>{\Gamma,x:\sigma\vdash t:\tau}\over{\Gamma\vdash \lambda x : \sigma.t : \sigma \to \tau}<br>$$<br>结果从 $\tau$ 变成 $\sigma\to\tau$ ，多了蕴含 $\to$ 所以称为蕴含介入。</p>
<p>参数多态实际上是对于某个参数不限制类型，相当于逻辑量词 $\forall$ ，也就是全称量化。</p>
<p>联合类型，例如 <code>Maybe Int</code> ，表示可能是 <code>Int</code> 或者是 <code>Nothing</code> 。关系是<strong>或</strong>，也就是析取。</p>
<p>相应地，结构类型表示可以同时是多个类型，关系是<strong>且</strong>，也就是合取。</p>
<p>对于接受参数而不返回的函数，或者返回 Unit 的函数，实际上类似于 $A \to \bot$ ，返回一个底。 </p>
<p>CPS 转换对应的是双重否定转换，也就是双重否定介入。</p>
<p>相应地，<code>call/cc</code> 对应的是双重否定消除。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这真的只是一种巧合吗？&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="同构" scheme="http://en.ors-sro.com/tags/%E5%90%8C%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Coq  入门学习笔记 （1）</title>
    <link href="http://en.ors-sro.com/Coq-Notes-1/"/>
    <id>http://en.ors-sro.com/Coq-Notes-1/</id>
    <published>2017-06-11T08:11:55.000Z</published>
    <updated>2017-06-11T08:20:58.300Z</updated>
    
    <content type="html"><![CDATA[<p>鸡年当然要学习鸡语言啦。</p>
<a id="more"></a>
<h1 id="简介">简介</h1><p><a href="https://zh.wikipedia.org/wiki/Coq" target="_blank" rel="external">Coq</a> 是一个基于<a href="https://zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E6%BC%94%E7%AE%97" target="_blank" rel="external">构造演算</a>的定理证明辅助工具。</p>
<p>在开始玩耍之前需要到官网<a href="https://coq.inria.fr/download" target="_blank" rel="external">下载 Coq</a></p>
<p>安装完成后打开 Coq 的 REPL —— Coq.exe 。</p>
<p>打开后能看到类似内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Coq 8.6 (December 2016)&#10;&#10;Coq &#60;</span><br></pre></td></tr></table></figure>
<p>输入 <code>&quot;Hello World&quot;.</code> 打印 Hello World 。</p>
<p>然而并没有什么 Hello World :P 。</p>
<h2 id="普通的引理">普通的引理</h2><p>先来证明一个普通的引理，算是 Hello World 吧。</p>
<p>在 Coq 中输入一下内容。 被 <code>(*</code> 和 <code>*)</code> 括起来的是注释不用输入。  <code>Coq &lt;</code> 也不用输入。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coq &#60; Section Minimal_Logic. (* &#20197;&#28857;&#21495;&#32467;&#23614;&#65292;&#31867;&#20284; C &#35821;&#35328;&#30340;&#20998;&#21495; *)&#10;&#10;Coq &#60; Variables A B C : Prop. (* &#27809;&#36755;&#20837;&#28857;&#23601;&#25442;&#34892;&#20102;&#21482;&#38656;&#36755;&#20837;&#28857;&#28982;&#21518;&#25442;&#34892; *)&#10;A is assumed&#10;B is assumed&#10;C is assumed&#10;&#10;Coq &#60; Goal (A -&#62; B -&#62; C) -&#62; (A -&#62; B) -&#62; A -&#62; C.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  ============================&#10;  (A -&#62; B -&#62; C) -&#62; (A -&#62; B) -&#62; A -&#62; C&#10;&#10;Unnamed_thm &#60; auto.&#10;No more subgoals.</span><br></pre></td></tr></table></figure>
<p>证明完毕！到此结束，手动再见。</p>
<h2 id="简单的过程">简单的过程</h2><p>既然愿意了解，那么就一步步来。先撤销证明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; Undo. &#65288;* U &#26159;&#22823;&#20889; *&#65289;&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  ============================&#10;  (A -&#62; B -&#62; C) -&#62; (A -&#62; B) -&#62; A -&#62; C</span><br></pre></td></tr></table></figure>
<p>输出的内容中 1 subgoal 说明只有一个目标需要证明</p>
<p><code>A, B, C : Prop</code> 表示 A B C 都是 Prop 。Prop 是命题 （<strong>Prop</strong>osition）的缩写。</p>
<p><code>============================</code> 是分割线。上面的内容是假设和条件。下面的内容是需要证明的部分。</p>
<p><code>(A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C</code> 需要证明的内容。 用 <code>()</code> 括起来表示视为一个整体， <code>-&gt;</code> 为蕴涵。</p>
<p><code>A -&gt; B</code> 读作若 A 则 B。</p>
<p>接下来为了方便证明，需要引入一些假设。</p>
<p>使用 <code>intro</code> 引入<strong>一个</strong>假设。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; intro H.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  ============================&#10;  (A -&#62; B) -&#62; A -&#62; C</span><br></pre></td></tr></table></figure>
<p>引入了假设 <code>H : A -&gt; B -&gt;C</code> 。证明的目标就变成了 <code>(A -&gt; B) -&gt; A -&gt; C</code>。</p>
<p>还可以引入多个假设。</p>
<p>多个假设使用 <code>intros</code> 就是 <code>intro</code> 加了 s 。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; intros H&#39; HA.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  H&#39; : A -&#62; B&#10;  HA : A&#10;  ============================&#10;  C</span><br></pre></td></tr></table></figure>
<p>现在需要证明的目标变成了 <code>C</code> 。</p>
<p>观察已有条件，发现假设 <code>H : A -&gt; B -&gt; C</code> 蕴涵 <code>C</code>。当然演绎出 <code>C</code> 还需要 <code>A -&gt; B</code> 。</p>
<p>可以先应用假设，转化证明的目标。</p>
<p>应用假设使用 <code>apply</code> </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; apply H.&#10;2 subgoals&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  H&#39; : A -&#62; B&#10;  HA : A&#10;  ============================&#10;  A&#10;&#10;subgoal 2 is:&#10; B</span><br></pre></td></tr></table></figure>
<p>现在目标变成了两个，一个 <code>A</code> 一个 <code>B</code> 。</p>
<p>观察已有条件，<code>A</code> 刚好是假设 <code>HA : A</code> 。</p>
<p>使用 <code>exact</code> 表示刚好。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; exact HA.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  H&#39; : A -&#62; B&#10;  HA : A&#10;  ============================&#10;  B</span><br></pre></td></tr></table></figure>
<p>现在目标变成了 <code>B</code> 。</p>
<p>观察已有条件，假设 <code>H&#39; : A -&gt; B</code> 蕴含了 <code>B</code> 。</p>
<p>那么应用 <code>H&#39;</code> 即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; apply H&#39;.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  H&#39; : A -&#62; B&#10;  HA : A&#10;  ============================&#10;  A</span><br></pre></td></tr></table></figure>
<p>现在目标变成了 <code>A</code>。</p>
<p>之前已经证明了 <code>A</code> 。这里可以用 <code>exact HA.</code> 。</p>
<p>也可以直接总结，表示目标已经证明。</p>
<p>总结使用 <code>assumption</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; assumption.&#10;No more subgoals.</span><br></pre></td></tr></table></figure>
<p><code>No more subgoals</code> 说明没有需要证明的目标了。证明结束。</p>
<p>证明可以使用 <code>Save</code> 保存。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; Save trivial_lemma.&#10;intro H.&#10;(intros H&#39; HA).&#10;(apply H).&#10; exact HA.&#10;&#10; (apply H&#39;).&#10; assumption.&#10;&#10;Save trivial_lemma.&#10;trivial_lemma is defined</span><br></pre></td></tr></table></figure>
<p>中间的部分就是证明的过程。</p>
<h2 id="最后">最后</h2><p>这次就简单的写个 Hello World 的笔记。<a href="https://coq.inria.fr/tutorial/1-basic-predicate-calculus" target="_blank" rel="external">后面的内容</a>还需要慢慢整理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鸡年当然要学习鸡语言啦。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Coq" scheme="http://en.ors-sro.com/tags/Coq/"/>
    
  </entry>
  
  <entry>
    <title>用 Flashdevelop 调试 ActionScript</title>
    <link href="http://en.ors-sro.com/Debug-As-in-Flashdevelop/"/>
    <id>http://en.ors-sro.com/Debug-As-in-Flashdevelop/</id>
    <published>2017-06-04T07:20:42.000Z</published>
    <updated>2017-06-10T12:52:32.384Z</updated>
    
    <content type="html"><![CDATA[<p>就算是过气的语言也有使用场景啊（页游）。</p>
<a id="more"></a>
<p>FlashDevelop 调试还要装杂七杂八的东西。</p>
<p>配置过程如下</p>
<h2 id="安装_Java">安装 Java</h2><p>因为大多数人的 FlashDevelop 用的是 32 位版，所以需要下载 32 位版的 Java</p>
<p><a href="https://www.java.com/zh_CN/download/manual.jsp" target="_blank" rel="external">https://www.java.com/zh_CN/download/manual.jsp</a></p>
<p><img src="/img/DebugAsInFlashdevelop/SelectJava.png" alt="SelectJava"></p>
<p>安装完成后打开命令行输入 <code>java</code> 应该返回类似画面</p>
<p><img src="/img/DebugAsInFlashdevelop/Java.png" alt="Java"></p>
<p>如果不是这样，需要<a href="https://jingyan.baidu.com/article/925f8cb836b26ac0dde0569e.html" target="_blank" rel="external">配置 Java_Home 环境变量</a></p>
<p>环境变量生效需要<strong>重启</strong></p>
<h2 id="安装_Flex_SDk">安装 Flex SDk</h2><p>打开 FlashDevelop -&gt; Tool -&gt; Install Software…</p>
<p>勾选 <strong>Flex SDK(OLD)</strong> </p>
<p><img src="/img/DebugAsInFlashdevelop/InstallSDK.png" alt="InstallSDK"></p>
<p>点击 <strong>Install 1 items</strong> 安装</p>
<p>安装完成后<strong>重启 FlashDevelop</strong></p>
<p>如果提示找不到 SDK 描述文件，则需要从刚装好的 SDK 目录下复制 <strong>flex-sdk-description.xml</strong> （可以用 everything 查找）到提示的路径中。</p>
<p><img src="/img/DebugAsInFlashdevelop/Warning.png" alt="Warning"></p>
<p>复制后<strong>重启 FlashDevelop</strong></p>
<h2 id="配置工程">配置工程</h2><p>打开 FlashDevelop -&gt; Project -&gt; Propperties</p>
<p><strong>Compilation Target</strong> 选为 <strong>Other IDE</strong></p>
<p><strong>Test Project</strong> 选为 <strong>Play: External Player</strong></p>
<p><img src="/img/DebugAsInFlashdevelop/ExternalPlayer.png" alt="SelectExternalPlayer"></p>
<p><strong>Install SDK(s)</strong> 选为 <strong>Flex</strong></p>
<p><img src="/img/DebugAsInFlashdevelop/SelectSDK.png" alt="SelectSDK"></p>
<h2 id="配置外部播放器">配置外部播放器</h2><p>打开 FlashDevelop -&gt; Programs Settings… -&gt; 往下拖动找到 FlashViewer</p>
<p>设置 <strong>External Player Path</strong> 为 <code>C:\Program Files (x86)\Adobe\Adobe Flash CS6\Players\Debug\FlashPlayerDebugger.exe</code></p>
<p><img src="/img/DebugAsInFlashdevelop/SetExternalPlayer.png" alt="SetExternalPlayer"></p>
<h2 id="开始调试">开始调试</h2><p>打开想要调试的 <strong>FLA</strong> ，在 FlashDevelop 中打开相应的 as 文件，下个能运行到的断点。</p>
<p>点击运行（F5），Happy Debugging！</p>
<p><img src="/img/DebugAsInFlashdevelop/Play.png" alt="Play"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就算是过气的语言也有使用场景啊（页游）。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="ActionScript" scheme="http://en.ors-sro.com/tags/ActionScript/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下安装 Emacs+Sbcl+Slime</title>
    <link href="http://en.ors-sro.com/Install-Emacs-Sbcl-and-Slime/"/>
    <id>http://en.ors-sro.com/Install-Emacs-Sbcl-and-Slime/</id>
    <published>2017-05-28T10:04:02.000Z</published>
    <updated>2017-05-28T10:17:35.379Z</updated>
    
    <content type="html"><![CDATA[<p>旧文重发，略作修改</p>
<a id="more"></a>
<h2 id="前言">前言</h2><p>其实网上已经有很多类似的文章了，我也是按照上面的来做。在做的过程中会遇到几个很坑的地方，我自己也是折腾了好久才弄好。所以现在写出来希望能对大家有所帮助。</p>
<h2 id="正文">正文</h2><h3 id="下载和安装_Emacs">下载和安装 Emacs</h3><p><a href="http://ftp.gnu.org/gnu/emacs/windows/emacs-24.3-bin-i386.zip" target="_blank" rel="external">http://ftp.gnu.org/gnu/emacs/windows/emacs-24.3-bin-i386.zip</a> </p>
<p>解压运行安装</p>
<h3 id="下载_Sbcl">下载 Sbcl</h3><p><a href="http://www.sbcl.org/platform-table.html" target="_blank" rel="external">http://www.sbcl.org/platform-table.html</a></p>
<p>选 Windows 和你的架构。如果不知道的话就选 X86 就行了。</p>
<h3 id="下载_Slime">下载 Slime</h3><p><a href="https://github.com/slime/slime" target="_blank" rel="external">https://github.com/slime/slime</a></p>
<p>如果你有 github 帐户就直接 git clone 吧。如果没有的话，点 download zip 然后解压。 </p>
<h3 id="安装Sbcl">安装Sbcl</h3><p>双击安装包，改一下安装路径到你想安装的地方。但是这里有一个坑。</p>
<p><strong>坑1：系统变量重启才会更新</strong></p>
<p>这是因为在安装的过程中会给系统加一个 Sbcl 路径的变量。</p>
<p>所以一定要安装完后重启，不然就会提示</p>
<blockquote>
<p>fatal error encountered in SBCL pid 10236(tid 9971200):<br>can’t find core file at XXXXX</p>
</blockquote>
<p>安装成功的标志是运行 sbcl.exe 会出现类似这样的界面：</p>
<p><img src="/img/InstallEmacsSbclandSlime/sbcl.png" alt="运行 sbcl"></p>
<h3 id="配置_Emacs">配置 Emacs</h3><p>本来在 Linux 下配置 Emacs 是一件简单的事，但在 Windows 下就不那么容易了。因为 Windows 文件名命名机制这里有一个坑。</p>
<p><strong>坑2:找不到 Emacs 的配置文件 .emacs</strong></p>
<p>这是因为 Windows 允许这样的命名规则，也是就不允许只有扩展名而没有文件名（在 Windows 看来是 .emacs 非法的，必须是 XXX.emacs 才是合法的。Linux 则是看成一个隐藏文件而已）</p>
<p>所以要做的第一步是生成 .emacs 配置文件</p>
<p>原理是通过修改选项之后点保存选项会生成 .emacs 配置文件</p>
<p>方法很简单。在 Emacs 目录下双击 runemacs.exe 打开 emacs</p>
<p>然后在菜单栏里点 Options——Show/Hide——tool-bar</p>
<p>之后点 Options——Save options</p>
<p>这样就会在 <code>C:\Users\你的用户名\AppData\Roaming</code> 下生成一个 .emacs</p>
<p>打开 .emacs 输入以下内容以配置 Slime</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">setq</span> inferior-lisp-program <span class="string">"sbcl路径"</span>)</span><span class="comment">; 设置优先使用哪种 Common Lisp 实现</span></span><br><span class="line"><span class="list">(<span class="keyword">add-to-list</span> <span class="variable">'load-path</span> <span class="string">"slime路径"</span>)</span><span class="comment">; 设置 Slime 路径</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">require</span></span> <span class="variable">'slime</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">slime-setup</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">require</span></span> <span class="variable">'slime-autoloads</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">slime-setup</span> '<span class="list">(<span class="keyword">slime-fancy</span>)</span>)</span><span class="comment">; 让 slime 变得更好看，比如把 sbcl 的*变成 CL-USER&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中路径使用<code>/</code>或者<code>//</code>分隔</p>
<p>这其中有一个坑需要小心</p>
<p><strong>坑3：sbcl 的路径一定要写到 sbcl.exe 不然会提示</strong></p>
<blockquote>
<p>Specified program for new process is a directory</p>
</blockquote>
<p>这个真的是深坑啊。当时我花了不少时间才折腾好</p>
<p>原理就是 slime 调用的时候不会从你填的路径找到 sbcl.exe 而是需要给出 sbcl.exe 的完整路径</p>
<p>我的 .emacs 配置是这样的</p>
<p><img src="/img/InstallEmacsSbclandSlime/emacs-setting.png" alt="Emacs 配置"></p>
<p>打开 Emacs 按 M-x（window下就是Alt+x）输入 slime 之后会出现像这样的</p>
<p><img src="/img/InstallEmacsSbclandSlime/run-emacs.png" alt="运行 Slime"></p>
<p>输入<code>&quot;Hello Common Lisp!&quot;</code> 一声长叹</p>
<p><img src="/img/InstallEmacsSbclandSlime/hello-world.png" alt="Hello World"></p>
<h2 id="后记">后记</h2><p>一些常用的 Slime 快捷键</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-k 编译当前文件 （也就是Ctrl+c后再Ctrl+k） </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-c 增量编译（这是我自己的理解） </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-z 切换到Slime </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-l 加载文件</span><br></pre></td></tr></table></figure>
<p>当然以上快捷键都可以再 .emacs 里面改。</p>
<p>PS:我的配色是 solarized 字体是 Monaco</p>
<p>PSS：以上 Vim 的配色。Emacs 的配色是自带的 dichromacy</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;旧文重发，略作修改&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="Emacs" scheme="http://en.ors-sro.com/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>侃类型</title>
    <link href="http://en.ors-sro.com/About-Type/"/>
    <id>http://en.ors-sro.com/About-Type/</id>
    <published>2017-05-21T06:34:24.000Z</published>
    <updated>2017-06-25T09:06:24.282Z</updated>
    
    <content type="html"><![CDATA[<p>随便说一说类型。</p>
<a id="more"></a>
<h2 id="类型的作用">类型的作用</h2><p>如果用记事本写一段程序，就会发现两个问题。</p>
<p>一个是没有代码提示，一个变量点出来的变量也不知道存不存在。</p>
<p>另一个是很容易编译失败，因为可能会发生一些不符合类型的问题。</p>
<p>有了类型能够避免手误，编辑器会提示不存在相应的成员变量。从而更早的发现问题。</p>
<p>使用类型可以显式地表达一种约束。比如加减乘除需要数字，如果传入了字符串就可以在编译期报错，而不是等到运行时才出错。</p>
<p>许许多多的类型组成了类型系统。类型系统按不同的维度可以分为好几种。</p>
<h2 id="强类型和弱类型">强类型和弱类型</h2><p>如果一个类型系统允许隐式类型转换，就是弱类型。否则为强类型。</p>
<p>C 系列语言就是弱类型。它允许隐式类型转换，如整数类型转为浮点数类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFloat</span><span class="params">(<span class="keyword">float</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%f\n"</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	printFloat(i);        <span class="comment">// 隐式类型转换</span></span><br><span class="line">	printFloat((<span class="keyword">float</span>)i); <span class="comment">// 显式类型转换</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Haskell 不允许隐式类型转换。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">printFloat</span> :: <span class="type">Float</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printFloat</span> v = putStrLn (show v)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> printFloat (toInteger <span class="number">1</span>)</span><br><span class="line">          printFloat <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>会编译失败。报错类型不匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Couldn&#39;t match expected type &#8216;Float&#8217; with actual type &#8216;Integer&#8217;&#10;In the first argument of &#8216;printFloat&#8217;, namely &#8216;(toInteger 1)&#8217;&#10;In a stmt of a &#39;do&#39; block: printFloat (toInteger 1)</span><br></pre></td></tr></table></figure>
<p>强类型看起似乎麻烦一些，但是类型转换的工作总是要做的。类型转换的规则应该按照实际情况来，是向下取整还是四舍五入。强类型逼迫思考这部分的逻辑，避免错误被隐藏。</p>
<h2 id="动态类型和静态类型">动态类型和静态类型</h2><p>如果类型能够在编译期确定，就是静态类型，否则为动态类型。</p>
<p>C 系列语言都是静态类型。举一个 C# 的例子。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		Console.WriteLine(PlusSecond(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PlusSecond</span>(<span class="params"><span class="keyword">int</span> donation</span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> life = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">		<span class="keyword">return</span> life + donation; <span class="comment">// donation 一定是 int 类型</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分的脚本语言都是动态类型，比如又爱又恨的 JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlusSecond</span>(<span class="params">donation</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> life = <span class="literal">Infinity</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(donation)) <span class="comment">// 运行时才能确定 donation 的类型。</span></span><br><span class="line">  <span class="keyword">return</span> life + donation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至不能确定函数的返回类型</span></span><br><span class="line">PlusSecond(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// =&gt; number</span></span><br><span class="line"><span class="comment">// =&gt; Infinity</span></span><br><span class="line">PlusSecond(<span class="string">" life"</span>);</span><br><span class="line"><span class="comment">// =&gt; string</span></span><br><span class="line"><span class="comment">// =&gt; "Infinity life"</span></span><br></pre></td></tr></table></figure>
<p>动态类型虽然不能确定类型但还是有类型的。</p>
<p>动态类型虽然没有类型，容易出错，但是有 REPL 可以快速迭代代码啊，撸起袖子就是干。只可惜动态一时爽，重构火葬场。</p>
<h2 id="无类型">无类型</h2><p>现在大部分的语言都是有类型的。毕竟有类型很方便啊。但还是存在一些无类型的语言，虽然可能算不上编程语言。</p>
<p>入演算（滑稽），Lambda Calculus，就是一种无类型的，与图灵机等价的计算模型。</p>
<p>语法为</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= &lt;var&gt;</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (λ&lt;var&gt;.&lt;exp&gt;)</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (&lt;exp&gt; &lt;exp&gt;)</span><br></pre></td></tr></table></figure>
<p>规约规则有 α-变换（重命名），β-归约（应用）和 η-变换（外延性相等）。</p>
<p>具体规则可以参考未来的我写的<a href="/Lambda-calculus">λ 演算</a>。</p>
<p>从语法中没有看到半点关于类型的东西，甚至连循环都看不到。</p>
<p>没有循环还能不能愉快的写代码了。</p>
<p>循环可以用递归代替。那递归怎么实现呢？</p>
<p>虽然定义中没有给出递归，但是可以通过不动点组合子实现。</p>
<p>比如著名的 Y 组合子</p>
<p> $Y=\lambda f.(\lambda x.f (x x)) (\lambda x.f (x x))$ </p>
<p>利用不动点的性质就可以达到递归。</p>
<p>$Y g=g (Y g)=g (g (Y g))=g (\ldots g (Y g)\ldots )$</p>
<p>不过因为 Y 组合子是 Call by name。而传统的语言一般是立即求值，所以需要 Y 组合子的 Call by value 版 Z 组合子。</p>
<p>$Z=\lambda f.(\lambda x.f(\lambda v.xxv))(\lambda x.f(\lambda v.xxv))$</p>
<p>Z 组合子的用法很简单，比如在 ES6 中用递归的方式写阶乘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Z = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))</span><br><span class="line">               (x =&gt; f(v =&gt; x(x)(v)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fact = Z (f =&gt; n =&gt; n == <span class="number">1</span> ? <span class="number">1</span> : n * f(n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fact(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure>
<p>那么问题来了，Z 的类型是？</p>
<h2 id="函数类型">函数类型</h2><p>在无类型的入演算引入蕴含（$\to$）就会变成简单类型的入演算（$\lambda^\to$）。</p>
<p>类型规则很简单</p>
<p>$\dfrac{}{x:\sigma \vdash x : \sigma}$</p>
<p>$\dfrac{\Gamma\vdash x:\sigma\quad x\not=y}{\Gamma,y:\tau \vdash x : \sigma}$</p>
<p>$\dfrac{\Gamma,x:\sigma\vdash t:\tau} {\Gamma\vdash \lambda x : \sigma.t : \sigma \to \tau}$</p>
<p>$\dfrac{\Gamma\vdash t:\sigma\to\tau\quad\Gamma\vdash u:\sigma}{\Gamma\vdash t\,u : \tau}$</p>
<p>例如组合子 IKS 的类型为</p>
<p>$\lambda x:\alpha.x : \alpha\to\alpha$ <strong>(I)</strong></p>
<p>$\lambda x:\alpha.\lambda y:\beta.x:\alpha \to \beta \to \alpha$ (<strong>K</strong>)</p>
<p>$\lambda x:\alpha\to\beta\to\gamma.\lambda y:\alpha\to\beta.\lambda z:\alpha.x z (y z) : (\alpha\to\beta\to\gamma)\to(\alpha\to\beta)\to\alpha\to\gamma$  (<strong>S</strong>)</p>
<p>注意有不少类型是简单类型不能表达的。比如 <code>call/cc</code> 柯里-霍华德同构于皮尔士定律，这在直觉逻辑中是不成立的。所以 <code>call/cc</code> 不能居留。</p>
<p>函数类型是一种值依赖值的例子。</p>
<h2 id="和类型与积类型">和类型与积类型</h2><p>在简单类型的入演算（$\lambda^\to$）引入类型操作符就会变成带类型操作符的简单类型入演算（$\lambda\underline\omega$）</p>
<p>普通的函数是一种操作值的操作符。</p>
<p>类似的，接收类型为参数返回类型的函数成为类型操作符。</p>
<p>有很多类型操作符，所以也会产生很多类型。这里主要提两种类型和类型与积类型。</p>
<p>很多变成使用 null 或者类似的原语来表达缺少值的情况。</p>
<p>但这会有两个问题。</p>
<p>一个是 null 只适用于引用类型，如果是值类型比如 int ，那么该怎么表示缺少值的情况呢？</p>
<p>有些人会取一个范围外的值比如对于输入一定是整数的情况的下可以取 -1 用于表达缺少值。</p>
<p>在输入包含负数的情况下不能用，这就很尴尬了。</p>
<p>值类型还好，错误的输入最多是得到错误的值，而引用类型就不一样了。</p>
<p>如果使用了 null 就必须检查，否则可能会因为空引用而崩溃。</p>
<p>而且使用了 null 相当于绕过了类型系统的检查，是不是 null 只能在运行时确定，做不到检查出 null 而编译失败。</p>
<p>理论上只要做了空检查就不会有问题，但是在复杂的数据结构嵌套中很容易就忘了对某个成员的检查。</p>
<p>这样的感觉像是写动态类型一样，觉得应该是没问题的，最后运行代码然后祈祷不要出错。</p>
<p>Haskell 中使用 Maybe 类型操作符来表达缺少值的情况。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a  <span class="comment">-- a 为类型参数</span></span></span><br></pre></td></tr></table></figure>
<p>注意到 a 为类型变量，可以是 Int，String，Char 等。例如</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="type">Just</span> <span class="number">84</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Maybe</span> t</span><br></pre></td></tr></table></figure>
<p>使用 Maybe 必须检查是否为 Nothing 否则编译失败。不过检查的过程是自动的（多亏了 Monad 和 do-notation）。</p>
<p>引入 null 不是错误，错误的是没有强制检查 null （C# 可以使用 <code>?.</code> 和 <code>??</code> 简化检查）。</p>
<p>当 a 为 Int 时 Maybe 返回 Maybe Int 。</p>
<p>Maybe Int 是什么类型呢。其实是一种和类型，是 Int + Nothing 。</p>
<p>所以 Maybe 之所以能表达缺少值的情况是因为它可以容纳两种类型。</p>
<p>类似的，积类型可以用 <code>(,)</code> 操作符或者 <code>std::pair</code> 生成。</p>
<p>$(A, B)$ 的类型是 A 类型和 B 类型的笛卡儿积 $A \times B$ 。</p>
<p>类型操作符是一种类型依赖类型的例子。 </p>
<h2 id="多态类型">多态类型</h2><p>在简单类型的入演算（$\lambda^\to$）引入全称量词（$\forall$）就会变成二阶入演算（$\lambda2$），又称为系统 F 。</p>
<p>引入 $\forall$ 后获得多态的能力。系统 F 的多态是参数化多态。</p>
<p>参数化多态类似于泛型。比如对于 <code>List&lt;T&gt;</code> 有</p>
<p>$length: \forall T.[T] \to int$ </p>
<p>注意到 <code>length</code> 是 Rank-1 类型。但有的函数可能是 Rank-2 类型。</p>
<p>比如 $(\forall a.a \to a) \to (\forall b.b \to b)$  就是 Rank-2 类型。</p>
<p>但不是有 N 个全称量词就是 Rank-N 类型。</p>
<p>$\forall a. a \to (\forall b.b \to a)$ 是 Rank-1 类型。</p>
<p>因为可以规约为 $\forall a b . a \to b \to a$ 。</p>
<p>通常的类型系统是 Rank-1 类型。系统 F 支持 Rank-N 类型。</p>
<p>Haskell 的类型系统 Hindley–Milner 类型系统是一种带类型类的系统 F 。默认是 Rank-1 ，需要手动开启 Rank-N 。</p>
<p>比如要使用代替 getter / setter 的光学棱镜组就要开启 Rank-N 。</p>
<p>除了参数化多态，还有特设多态。</p>
<p>特设多态是指一个多态函数有多种实现，依赖于参数的类型，调用相应的版本，类似于面向对象中的重载（overload）。</p>
<p>所以特设多态只能支持有限数量的类型。而参数化多态更为通用。</p>
<p>多态类型是一种值依赖类型的例子。</p>
<h2 id="依赖类型">依赖类型</h2><p>容器类型除了元素类型还跟长度有关，不同长度的同元素类型构成了一个容器簇。</p>
<p>如果把长度当作容器类型构造器的参数，那么就形成了依赖类型。</p>
<p>依赖类型分为依赖乘积类型（Π-类型）和依赖总和类型（Σ-类型）。</p>
<p>依赖乘积类型可以写作 $\displaystyle \Pi (x:A),B(x)$ ，当 $B$ 为常数时，即 $\displaystyle \Pi {(x:A)},B$ ，退化为函数类型 $A \to B$</p>
<p>依赖总和类型可以写作 $\displaystyle \Sigma {(x:A)},B(x)$ ，当 $B$ 为常数时，即 $\displaystyle \Sigma {(x:A)},B$ ，退化为乘积类型 $A \times B$</p>
<p>依赖类型使得容器类型长度变成了一种约束。</p>
<p>例如对于元素类型为 T，长度为 n 的 <code>List</code> 类型 $List(T,n)$ ，它的 <code>append</code> 操作类型为</p>
<p>$append : List(T,n) \to List(T,m) \to List(T,m + n)$ </p>
<p>如果最后返回值长度不是 $m+n$ 就会被编译器踢屁股，编译失败。</p>
<p>这样尽可能用类型表达更多的约束，将逻辑问题扑灭在编译期，就能写出更正确的程序。</p>
<p>毕竟业务逻辑应该写在函数类型里，你之所以要写函数实现是因为编译器还没有聪明到自动做 $\beta$ 规约啊科科。</p>
<p>依赖类型是一种类型依赖值的例子。</p>
<p>这样就集齐了值和类型的四种关系。</p>
<p>简单类型($\lambda^\to$)是<strong>值</strong>依赖<strong>值</strong>的关系。</p>
<p>带类型操作符的简单类型($\lambda\underline\omega$)是<strong>类型</strong>依赖<strong>类型</strong>的关系。</p>
<p>二阶入演算（$\lambda2$）是<strong>值</strong>依赖<strong>类型</strong>的关系。</p>
<p>依赖类型（$\lambda P$）是<strong>类型</strong>依赖<strong>值</strong>的关系。</p>
<p>以 $\lambda^\to$ 为原点，其他三种关系为基底，就得到了常见类型系统的入立方。</p>
<p><img src="/img/AboutType/Lambda_cube.png" alt="入立方"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随便说一说类型。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="类型" scheme="http://en.ors-sro.com/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>非对称加密</title>
    <link href="http://en.ors-sro.com/asymmetric-cryptography/"/>
    <id>http://en.ors-sro.com/asymmetric-cryptography/</id>
    <published>2017-05-14T10:23:50.000Z</published>
    <updated>2017-05-14T10:31:00.960Z</updated>
    
    <content type="html"><![CDATA[<p>非常有趣的思想。</p>
<a id="more"></a>
<h2 id="对称加密">对称加密</h2><p>为什么要加密呢？因为有些羞羞的东西不想让他人看到。</p>
<p>比如甲给乙传小纸条，必须要经过捣蛋鬼的手中。如果不加密，捣蛋鬼就会知道其中的内容，然后发出嘿嘿嘿的猥琐笑声。BAD ENDING 1</p>
<p>甲和乙都很无语。所以他们决定以后发消息的时候要加密。</p>
<p>甲把信息加密后写在小纸条上，传给乙。</p>
<p>捣蛋鬼即使在途中看到了也没有办法知道里面的内容。HAPPY ENDING (DREAMING)</p>
<p>但是现实很残忍，甲和乙不能私下接触，所以只能通过传小纸条的方式来交换信息。</p>
<p>那么加密的密钥，甲该怎么传给乙呢？</p>
<p>假设甲把密钥加密后传给乙，乙不知道加密的密钥怎么解密。看不懂。BAD ENDING 2</p>
<p>假设甲把没加密的密钥传给乙，捣蛋鬼也知道了密钥，甲再发羞羞的内容给乙时，捣蛋鬼用已知的密钥解密，再次发出嘿嘿嘿的萎缩笑声。BAD ENDING 3</p>
<p>甲感到很绝望。不加密会被偷窥。加密了也会被偷窥。</p>
<h2 id="非对称加密">非对称加密</h2><p>甲在想如果加密和解密用的不是同一个密钥，那么这样就不怕被偷窥了。那要怎么做呢？</p>
<p>后来老师在密码学课上讲了方法。</p>
<p>甲先生成两个密钥，这两个密钥有这样的特点，知道一个密钥不能推出另外一个密钥，但是两个密钥对于某些数学运算能得到相同的结果，也就是一个密钥加密的文本只能用另外一个密钥解密。</p>
<p>甲随机选择一个密钥，不加密，写在小纸条上传给乙。捣蛋鬼和乙一看这乱七八糟的数字一定是密钥，这个密钥已经公开了。所以称为公钥。剩下那个没公开的称为私钥。</p>
<p>乙心神领会后，也把公钥发给了甲。</p>
<p>这样两轮信息交换后</p>
<p>甲知道了乙的公钥、甲的公钥、甲的私钥。</p>
<p>乙知道了甲的公钥、乙的公钥、乙的私钥。</p>
<p>捣蛋鬼知道了甲的公钥和乙的公钥。</p>
<p>甲用乙的公钥加密羞羞的东西，发给乙。</p>
<p>捣蛋鬼看到莫名其妙的东西，知道是被加密了。但是乙的公钥不能解密，能解密的只有乙的私钥。捣蛋鬼并不知道乙的私钥。只好放行。传给乙。</p>
<p>乙收到密文后，用乙的私钥解密，看到了羞羞的东西，决定回复甲。</p>
<p>乙用甲的公钥加密回复，发给甲。</p>
<p>捣蛋鬼再次看到莫名其妙的东西，知道肯定又是加密了。而且肯定使用甲的公钥加密了。因为如果用乙的公钥加密，甲没有乙的私钥没有办法解密。捣蛋鬼没有甲的私钥，不能解密，只好放行。</p>
<p>甲收到密文后用甲的私钥解密。看到了回复。 HAPPY ENDING</p>
<p>在上述两个例子中，有两种加密方式。</p>
<p>加密和解密用的是同一个密钥，这叫对称加密。</p>
<p>相应地，加密和解密用的不是同一个密钥，这叫非对称机密。</p>
<p>对称加密很容易做到。那么非对称加密是怎么做到密钥不一样还能解密的呢？</p>
<p>有好几种方法，比如有一种方法是这样的。</p>
<p>在数学运算中，有些运算会产生信息丢失，也就是即便知道了运算结果也不一定能确定运算前的数。</p>
<p>比如对于取膜 $\bmod$ </p>
<p>$3 \bmod 2 = 1$  。如果只知道运算结果是 $1$ 是不能确定运算前是 $3$ 的，因为有可能是 $1, 3, 5, 7, 9\dots$ 中的任何一个。</p>
<p>虽然不知道原来的数，但是只要知道数学关系就能得到相同的结果。比如只要奇数模 2 都会等于 1 。</p>
<p>所以可以这么做。</p>
<p>甲先公开生成密钥的两个常数 $g = 5$ 和 $p = 23$ 。</p>
<p>甲随机选取一个数字 $a$ 比如 $a = 6$ ，算出公钥 $A = g^a \bmod p = 5^6 \bmod 23 = 8$</p>
<p>甲把公钥 $A = 23$ 发给乙，把私钥 $a = 6$ 偷偷藏起来。</p>
<p>捣蛋鬼知道了 $5^? \bmod 23 = 8$ ，但是推不出甲的私钥 $a$ 。</p>
<p>乙随机选取一个数字 $b$ 比如 $b = 15$ ，算出公钥 $B = g^b \bmod p = 5^{15} \bmod 23 = 19$</p>
<p>乙把公钥 $B = 19$ 发给甲，把私钥 $b = 15$ 偷偷藏起来。</p>
<p>捣蛋鬼知道了 $5^? \bmod 23 = 19$ ，但是推不出乙的私钥 $b$ 。</p>
<p>因为 $(g^a)b = (g^b)^a$ 所以 $(g^a)^b \bmod p = (g^b)^a \bmod p$ </p>
<p>由于取模的性质有</p>
<p> $(g^a)^b \bmod p = A^b \bmod p$</p>
<p>$(g^b)^a \bmod p = B^a \bmod p$</p>
<p>所以</p>
<p>$A^b \bmod p = B^a \bmod p$</p>
<p>也就是甲可以通过甲的私钥和乙的公钥组合来解密，不能只通过乙的公钥来解密。</p>
<p>同样，乙可以通过乙的私钥和甲的公钥组合来解密，不能只通过甲的公钥来解密。</p>
<p>在实际应用中通常选择比较大的数防止暴力穷举。</p>
<p>因为非对称加密相比于对称加密较慢，所以通常使用非对称加密传递对称加密的密钥后使用对称加密通信。</p>
<h2 id="中间人攻击">中间人攻击</h2><p>以上情况建立在捣蛋鬼没有好好听课的前提下。实际上捣蛋鬼刚好认真听了老师那节介绍非对称加密的课。</p>
<p>于是甲传递甲的公钥时，捣蛋鬼替换为捣蛋鬼的公钥。</p>
<p>乙收到捣蛋鬼的公钥后发出乙的公钥。</p>
<p>捣蛋鬼收到乙的公钥后替换为捣蛋鬼的公钥。</p>
<p>甲收到捣蛋鬼的公钥后，用捣蛋鬼的公钥加密羞羞的东西，发给乙。</p>
<p>捣蛋鬼收到加密的内容后，用捣蛋鬼的私钥解密后看到羞羞的内容。发出嘿嘿嘿的萎缩笑声。BAD ENDING 4</p>
<h2 id="应对非对称加密">应对非对称加密</h2><p>如果文件被非对称加密（如 RSA）加密了。有什么办法解密吗？</p>
<p>目前能想到的有以下几种方法。</p>
<ol>
<li>暴力穷举，假设你有银河超级计算器的话。</li>
<li>获取私钥，假设你可以有资本色诱或威胁的话。</li>
<li>找到快速的大质数分解方式，顺便拿个炸药奖。</li>
</ol>
<h2 id="最后">最后</h2><p>在现实生活中，甲传纸条给乙，经过捣蛋鬼的手，捣蛋鬼噌地站起来指着甲说：“老师他上课传纸条！”。</p>
<p>参考链接</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="external">公开密钥加密</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="external">迪菲-赫爾曼密鑰交換</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常有趣的思想。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="密码学" scheme="http://en.ors-sro.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于原型的面向对象</title>
    <link href="http://en.ors-sro.com/Prototype-base-object-oriented-programming/"/>
    <id>http://en.ors-sro.com/Prototype-base-object-oriented-programming/</id>
    <published>2017-05-07T11:50:45.000Z</published>
    <updated>2017-05-07T11:52:10.222Z</updated>
    
    <content type="html"><![CDATA[<p>实现面向对象不一定是基于类的方式。</p>
<a id="more"></a>
<h2 id="现在">现在</h2><p>ES6 引入基于类的对象声明方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeDPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  constructor(x, y, z)&#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">', '</span> + <span class="keyword">this</span>.z + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这只是为了照顾 Java 和 C++ 程序员而引入的语法糖。底层的实现还是没有变的。</p>
<h2 id="过去">过去</h2><p>ES5 之前的对象声明是这样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>为什么没有写继承呢？因为继承了灵活，有很多中方法，取决于你的目的。</p>
<p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">JavaScript 继承</a></p>
<h2 id="区别">区别</h2><p>面向对象强调的是对象，而不是类。所以没有叫面向类编程。</p>
<p>面向对象的实现方式除了基于类的方式，还有基于原型的方式。</p>
<p>基于原型的方式能够实现基于类的方式，如 ES6 引入的语法糖。</p>
<p>而基于类的实现方式大部分不能实现基于原型的方式。因为大部分的语言类型层级是静态的。</p>
<p>也就是说在编译的时候类型继承是已经确定的，运行的时候不能更改继承关系。</p>
<p>而基于原型的方式在运行的时候可以更改继承关系。更改 <code>prototype</code> 即可。</p>
<p>基于类的面向对象编程经常有基本类型难以更改的问题。这是因为类型继承树是定死的，后期改起来影响很大。</p>
<p>比如你有一个列表的基本组件 <code>ListBase</code> 。所有列表集成于它。</p>
<p>如果你想来一个新的列表跟 <code>ListBase</code> 表现不一致，那么就要重载其中不一致的部分。</p>
<p>如果被重载的函数太长，或者里面引用了私有变量，就很难实现。</p>
<p>这时候要么改 <code>ListBase</code> 要么把 <code>ListBase</code> 的代码复制一遍，重新做一个 <code>NewListBase</code>。</p>
<p>改动 <code>ListBase</code>，因为用到的地方很多，无法保证不会出问题。</p>
<p>复制一遍，如果 <code>ListBase</code> 改动很难同步。也是产生代码腐臭的经典方式。</p>
<p>如果是用原型的方式，直接继承 <code>prototype</code> 。然后改想要改的部分就可以了。</p>
<p>相当于复制了代码，但是这段复制的代码是在运行的时候复制出来的。所以 <code>ListBase</code> 的改动都会同步。</p>
<p>基于原型的继承最大的缺点是接受了基于类继承的先入为主后很难理解。</p>
<p>基于原型的继承在代码中没有类的概念，所有类的概念都是人为为了模拟基于类的面向对象而产生的。</p>
<p>基于原型的集成只有对象的复制和修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现面向对象不一定是基于类的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="JavaScript" scheme="http://en.ors-sro.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>SICP 2.2 层级数据和闭包属性</title>
    <link href="http://en.ors-sro.com/SICP-2-2-Hierarchical-Data-and-the-Closure-Property/"/>
    <id>http://en.ors-sro.com/SICP-2-2-Hierarchical-Data-and-the-Closure-Property/</id>
    <published>2017-04-30T15:05:52.000Z</published>
    <updated>2017-04-30T15:25:05.645Z</updated>
    
    <content type="html"><![CDATA[<p>好久没填坑都快忘了……</p>
<a id="more"></a>
<h2 id="笔记">笔记</h2><p><code>cons</code> 可以嵌套</p>
<p><code>(cons 1 (cons 2 (cons 3 (cons 4 nil))))</code> 相当于 <code>list(1 2 3 4)</code></p>
<p>那 <code>(cons 1 (cons 2 (cons 3 4)))</code> 呢？</p>
<p>原来 <code>nil</code> 来源于意大利语 <strong>nihil</strong> ，以为无，没有。</p>
<p><code>cons</code> 还可用于在列表前面附加元素</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">cons</span> <span class="number">10</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; (10 1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<p>那要在列表后面附加元素呢，使用 <code>append</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; (1 2 3 4)</span></span><br><span class="line"><span class="comment">;; 如果第二个不是列表而是一个元素的话，结果会是 cons</span></span><br><span class="line"><span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="number">3</span>)</span></span><br><span class="line"><span class="comment">; (1 2 . 3)</span></span><br></pre></td></tr></table></figure>
<p>用 <code>null?</code> 来判断列表是否为空。（为什么不是 <code>nil?</code> ……）</p>
<p><code>((1 2) 3 4)</code> 可以看成 <code>(cons (list 1 2) (list 3 4))</code> </p>
<p>也可以看成树状结构，取决于目标和解释方式。</p>
<p>在递归的过程中有时候需要判断参数是不是 pair 。可以用 <code>pair?</code> 来判断。</p>
<h2 id="习题">习题</h2><h3 id="习题_2-17">习题 2.17</h3><blockquote>
<p><strong>Exercise 2.17.</strong>  Define a procedure last-pair that returns the list that contains only the last element of a given (nonempty) list:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">list</span> <span class="number">23</span> <span class="number">72</span> <span class="number">149</span> <span class="number">34</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">34</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>列表就是一系列的 pair 。最后一个元素一定处于 <code>(cons xxx nil)</code> 的类似列表。所以通过基本的操作 <code>car</code> 和 <code>cdr</code> 不断的取尾，最后一个元素为 <code>nil</code> 时所处的 pair 第一个元素就是整个列表的最后一个元素。最后再用 <code>list</code> 封装以达到题目要求。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">last-pair</span> alist)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? <span class="list">(<span class="keyword">cdr</span> alist)</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">car</span> alist)</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">cdr</span> alist)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (4)</span></span><br><span class="line"><span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1)</span></span><br><span class="line"><span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">list</span> <span class="number">23</span> <span class="number">72</span> <span class="number">149</span> <span class="number">34</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (34)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-18">习题 2.18</h3><blockquote>
<p><strong>Exercise 2.18.</strong>  Define a procedure reverse that takes a list as argument and returns a list of the same elements in reverse order:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">reverse</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">25</span> <span class="number">16</span> <span class="number">9</span> <span class="number">4</span> <span class="number">1</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>因为列表是一个递归嵌套 pair 的结构，所以很自然要用递归的方式处理。</p>
<p>用递归的方式处理，最基本的是先确定递归退出条件。通常是考虑最小子问题。</p>
<p>在这个例子中，最小的列表是空列表。</p>
<p>逆转空列表结果还是空列表。</p>
<p>接着就是找递归的递进条件，也就是怎么把问题变成更小的问题。</p>
<p>考虑到一个列表可以拆分为第一个元素和剩余列表。</p>
<p>那么逆转一个列表，相当于逆转过后的剩余列表拼接上第一个元素。</p>
<p>这样问题的规模就缩小了。只要同样地逆转剩余列表即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">reverse</span> alist)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? alist)</span></span><br><span class="line">      alist</span><br><span class="line">      <span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">reverse</span> <span class="list">(<span class="keyword">cdr</span> alist)</span>)</span> </span><br><span class="line">              <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">car</span> alist)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">reverse</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (4 3 2 1)</span></span><br><span class="line"><span class="list">(<span class="keyword">reverse</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (25 16 9 4 1)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-19">习题 2.19</h3><blockquote>
<p><strong>Exercise 2.19.</strong>  Consider the change-counting program of section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.2" target="_blank" rel="external">1.2.2</a>. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the procedure first-denomination and partly into the procedure count-change (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.</p>
<p>We want to rewrite the procedure cc so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> us-coins <span class="list">(<span class="keyword">list</span> <span class="number">50</span> <span class="number">25</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> uk-coins <span class="list">(<span class="keyword">list</span> <span class="number">100</span> <span class="number">50</span> <span class="number">20</span> <span class="number">10</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0.5</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>We could then call cc as follows:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> us-coins)</span></span><br><span class="line"><span class="number">292</span></span><br></pre></td></tr></table></figure></p>
<p>To do this will require changing the program cc somewhat. It will still have the same form, but it will access its second argument differently, as follows:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">cc</span> amount coin-values)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">=</span> amount <span class="number">0</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">or</span> <span class="list">(<span class="keyword">&lt;</span> amount <span class="number">0</span>)</span> <span class="list">(<span class="keyword">no-more</span>? coin-values)</span>)</span> <span class="number">0</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">else</span></span><br><span class="line">         <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">cc</span> amount</span><br><span class="line">                <span class="list">(<span class="keyword">except-first-denomination</span> coin-values)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">cc</span> <span class="list">(<span class="keyword">-</span> amount</span><br><span class="line">                   <span class="list">(<span class="keyword">first-denomination</span> coin-values)</span>)</span></span><br><span class="line">                coin-values)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>Define the procedures first-denomination, except-first-denomination, and no-more? in terms of primitive operations on list structures. Does the order of the list coin-values affect the answer produced by cc? Why or why not?</p>
</blockquote>
<p>题目要求实现 <code>first-denomination</code> 、<code>except-first-denomination</code> 和 <code>no-more?</code> 。</p>
<p>其实函数名字已经提示很多了。</p>
<p><code>first-denomination</code> 是取第一个货币单位。</p>
<p><code>except-first-denomination</code> 是排除第一个货币单位。</p>
<p><code>no-more?</code> 是判断是否还有货币单位。</p>
<p>参考列表的操作，很容易写出来</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> except-first-denomination cdr)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> first-denomination car)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> no-more? null?)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> us-coins)</span></span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> uk-coins)</span></span><br><span class="line"><span class="comment">; =&gt; 104561</span></span><br></pre></td></tr></table></figure>
<p>题目还问改变货币列表中的顺序是否会影响结果。</p>
<p>考虑到换零钱的计算方式是换某种货币的组合数加上不换某种货币的组合数。</p>
<p>显然换 100 加上不换 100 的组合等于换 5 加上不换 5 的组合。因为要兑换的总额是一样的。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> us-coins2 <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">25</span> <span class="number">50</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> us-coins2)</span></span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> us-coins)</span></span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-20">习题 2.20</h3><blockquote>
<p><strong>Exercise 2.20.</strong>  The procedures +, <em>, and list take arbitrary numbers of arguments. One way to define such procedures is to use define with \</em>dotted-tail notation<em>. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedure is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter’s value will be a </em>list* of any remaining arguments. For instance, given the definition<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">f</span> x y . z)</span> &lt;body&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p>the procedure f can be called with two or more arguments. If we evaluate<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">f</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>then in the body of f, x will be 1, y will be 2, and z will be the list (3 4 5 6). Given the definition<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">g</span> . w)</span> &lt;body&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p>the procedure g can be called with zero or more arguments. If we evaluate<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">g</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>then in the body of g, w will be the list <code>(1 2 3 4 5 6)</code>.<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_164" target="_blank" rel="external">11</a></p>
<p>Use this notation to write a procedure same-parity that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">same-parity</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">same-parity</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="list">(<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>题目介绍了不定参数的函数定义方式，通过类似 pair 的形式来定义，还是很有趣的。</p>
<p><code>same-parity</code> 肯定要支持不定参数。那么最少有几个参数？</p>
<p>是 1 个。如果是 1 个直接返回该元素即可。</p>
<p>所以 <code>same-parity</code> 的定义如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">same-parity</span> element . alist)</span> &lt;body&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 点两边都要有空格，不然会视作函数名为 same-parity.alist 的函数。</span></span><br></pre></td></tr></table></figure>
<p>第一个参数是 <code>alist</code> 的第一个元素。</p>
<p>第二个参数是剩余的列表。</p>
<p>然后考虑如何把子问题规模缩小。</p>
<p>比如对于列表 <code>(1 2 3 4)</code></p>
<p>可以拆分为 <code>(same-parity 1 2)</code> 和 <code>(same-parity 1 (3 4))</code></p>
<p>这样问题的规模就变小了。</p>
<p>因为 <code>(same-parity 1 2)</code> 会把参数收集为列表，这样递归不是很方便，所以创建一个 <code>(same-parity-iter)</code> 。</p>
<p>完整代码如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">same-parity</span> . alist)</span></span><br><span class="line">  <span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">same-parity-iter</span> first rest result)</span></span><br><span class="line">    <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? rest)</span></span><br><span class="line">        result</span><br><span class="line">        <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">same-parity</span>? first <span class="list">(<span class="keyword">car</span> rest)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">same-parity-iter</span> first <span class="list">(<span class="keyword">cdr</span> rest)</span> <span class="list">(<span class="keyword">append</span> result <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">car</span> rest)</span>)</span>)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">same-parity-iter</span> first <span class="list">(<span class="keyword">cdr</span> rest)</span> result)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">or</span> <span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">length</span> alist)</span> <span class="number">0</span>)</span></span><br><span class="line">          <span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">length</span> alist)</span> <span class="number">1</span>)</span>)</span></span><br><span class="line">      alist</span><br><span class="line">      <span class="list">(<span class="keyword">same-parity-iter</span> <span class="list">(<span class="keyword">car</span> alist)</span> <span class="list">(<span class="keyword">cdr</span> alist)</span> <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">car</span> alist)</span>)</span>)</span>)</span>)</span></span><br><span class="line">      </span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">same-parity</span>? a b)</span></span><br><span class="line"></span><br><span class="line">  <span class="list">(<span class="keyword">or</span> <span class="list">(<span class="keyword">and</span> <span class="list">(<span class="keyword">even</span>? a)</span> <span class="list">(<span class="keyword">even</span>? b)</span>)</span></span><br><span class="line"></span><br><span class="line">      <span class="list">(<span class="keyword">and</span> <span class="list">(<span class="keyword">odd</span>? a)</span> <span class="list">(<span class="keyword">odd</span>? b)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">same-parity</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1 3 5 7)</span></span><br><span class="line"><span class="list">(<span class="keyword">same-parity</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (2 4 6)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-21">习题 2.21</h3><blockquote>
<p><strong>Exercise 2.21.</strong>  The procedure <code>square-list</code> takes a list of numbers as argument and returns a list of the squares of those numbers.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>Here are two different definitions of <code>square-list</code>. Complete both of them by filling in the missing expressions:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? items)</span></span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      <span class="list">(<span class="keyword">cons</span> &lt;??&gt; &lt;??&gt;)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> &lt;??&gt; &lt;??&gt;)</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>仿照 <code>scale-list</code> 即可得到答案</p>
<p>第一种</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? items)</span></span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">*</span> <span class="list">(<span class="keyword">car</span> items)</span> <span class="list">(<span class="keyword">car</span> items)</span>)</span> <span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">cdr</span> items)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">*</span> x x)</span>)</span> items)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-22">习题 2.22</h3><blockquote>
<p><strong>Exercise 2.22.</strong>  Louis Reasoner tries to rewrite the first square-list procedure of exercise 2.21 so that it evolves an iterative process:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">iter</span> things answer)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? things)</span></span><br><span class="line">      answer</span><br><span class="line">      <span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">cdr</span> things)</span> </span><br><span class="line">            <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">square</span> <span class="list">(<span class="keyword">car</span> things)</span>)</span></span><br><span class="line">                  answer)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">iter</span> items <span class="literal">nil</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>Unfortunately, defining square-list this way produces the answer list in the reverse order of the one desired. Why?</p>
<p>Louis then tries to fix his bug by interchanging the arguments to cons:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">iter</span> things answer)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? things)</span></span><br><span class="line">      answer</span><br><span class="line">      <span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">cdr</span> things)</span></span><br><span class="line">            <span class="list">(<span class="keyword">cons</span> answer</span><br><span class="line">                  <span class="list">(<span class="keyword">square</span> <span class="list">(<span class="keyword">car</span> things)</span>)</span>)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">iter</span> items <span class="literal">nil</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>This doesn’t work either. Explain.</p>
</blockquote>
<p>这么做显然是有问题的。用 Applicative Order 展开就清楚了</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="literal">nil</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">cons</span> <span class="number">1</span> <span class="literal">nil</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">cons</span> <span class="number">4</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="literal">nil</span> <span class="list">(<span class="keyword">cons</span> <span class="number">9</span> <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="number">1</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="literal">nil</span> <span class="list">(<span class="keyword">list</span> <span class="number">9</span> <span class="number">4</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="comment">; (9 4 1)</span></span><br></pre></td></tr></table></figure>
<p>再看修正版，还是使用 Applicative Order 展开</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="literal">nil</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">cons</span> <span class="literal">nil</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">cons</span> <span class="literal">nil</span> <span class="number">1</span>)</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="literal">nil</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">cons</span> <span class="literal">nil</span> <span class="number">1</span>)</span> <span class="number">4</span>)</span> <span class="number">9</span>)</span>)</span></span><br><span class="line"><span class="comment">; (((1) . 4) . 9)</span></span><br></pre></td></tr></table></figure>
<p>这次他虽然调整了顺序，但是没有使用正确的方式附加元素。</p>
<p>按照提供的现有函数，如果想在列表后面附加元素应该使用 <code>append</code> 和 <code>list</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<p>所以这么改就可以了。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">iter</span> things answer)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? things)</span></span><br><span class="line">      answer</span><br><span class="line">      <span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">cdr</span> things)</span></span><br><span class="line">            <span class="list">(<span class="keyword">append</span> answer</span><br><span class="line">                  <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">square</span> <span class="list">(<span class="keyword">car</span> things)</span>)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">iter</span> items <span class="literal">nil</span>)</span>)</span></span></span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; =&gt; (1 4 9 16)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-23">习题 2.23</h3><blockquote>
<p><strong>Exercise 2.23.</strong>  The procedure for-each is similar to map. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, for-each just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all — for-each is used with procedures that perform an action, such as printing. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">for-each</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">newline</span>)</span> <span class="list">(<span class="keyword">display</span> x)</span>)</span></span><br><span class="line"> <span class="list">(<span class="keyword">list</span> <span class="number">57</span> <span class="number">321</span> <span class="number">88</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>573<br>21<br>88</p>
<p>The value returned by the call to for-each (not illustrated above) can be something arbitrary, such as true. Give an implementation of for-each.</p>
</blockquote>
<p>比起 <code>map</code> ，<code>for-each</code> 更注重操作的副作用，而不是结果。</p>
<p>所以如果不介意返回值的话，完全可以把 <code>map</code> 当作 <code>for-each</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> for-each map)</span></span><br></pre></td></tr></table></figure>
<p>如果自己写是这样的。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">for-each</span> f alist)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? alist)</span></span><br><span class="line">      #t</span><br><span class="line">      <span class="list">(<span class="keyword">list</span>  <span class="list">(<span class="keyword">for-each</span> f <span class="list">(<span class="keyword">cdr</span> alist)</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="keyword">car</span> alist)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>注意把 <code>(f (car alist))</code> 放在后面，因为参数求值从后面开始。</p>
<h3 id="习题_2-24">习题 2.24</h3><blockquote>
<p><strong>Exercise 2.24.</strong>  Suppose we evaluate the expression <code>(list 1 (list 2 (list 3 4)))</code>. Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree (as in figure <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_fig_2.6" target="_blank" rel="external">2.6</a>).</p>
</blockquote>
<p>表达式的结果是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; =&gt; (1 (2 (3 4)))</span></span><br></pre></td></tr></table></figure>
<p>盒子图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+---+---+      +---+---+&#10;&#10;|   |   | +--&#62; |   |   |&#10;&#10;+-+-+---+      +-+-+---+&#10;&#10;  |              |&#10;&#10;  v              v&#10;&#10;+---+---+      +---+---+       +---+---+&#10;&#10;|   |   |      |   |   | +---&#62; |   |   |&#10;&#10;+-+-+---+      +-+-+---+       +-+-+---+&#10;&#10;  |              |               |&#10;&#10;  v              v               v&#10;&#10;+---+---+      +---+---+       +---+---+      +---+---+&#10;&#10;|   |   |      |   |   |       |   |   | +--&#62; |   |   |&#10;&#10;+-+-+---+      +-+-+---+       +-+-+---+      +-+-+---+&#10;&#10;  |              |               |              |&#10;&#10;  v              v               v              v&#10;&#10;+-+             +-+             +-+            +-+&#10;&#10;|1|             |2|             |3|            |4|&#10;&#10;+-+             +-+             +-+            +-+</span><br></pre></td></tr></table></figure>
<p>树状图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 (2 (3 4)))&#10;&#9500;&#9472;1&#10;&#9492;&#9472;&#9472;(2 (3 4))&#10;    &#9500;&#9472;&#9472;2&#10;    &#9492;&#9472;&#9472;(3 4)&#10;        &#9500;&#9472;&#9472;3&#10;        &#9492;&#9472;&#9472;4</span><br></pre></td></tr></table></figure>
<h3 id="习题_2-25">习题 2.25</h3><blockquote>
<p><strong>Exercise 2.25.</strong>  Give combinations of <code>car</code>s and <code>cdr</code>s that will pick 7 from each of the following lists:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="number">1</span> <span class="number">3</span> <span class="list">(<span class="number">5</span> <span class="number">7</span>)</span> <span class="number">9</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="list">(<span class="number">7</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="list">(<span class="number">2</span> <span class="list">(<span class="number">3</span> <span class="list">(<span class="number">4</span> <span class="list">(<span class="number">5</span> <span class="list">(<span class="number">6</span> <span class="number">7</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>由内往外，一步步使用 <code>car</code> 和 <code>cdr</code> 即可。</p>
<p>比如对于<code>(1 3 (5 7) 9)</code> 先从 <code>(5 7)</code>下手。</p>
<p>想要得到 <code>(5 7)</code> 中的 7 只需要 <code>(car (cdr (5 7))</code></p>
<p>对于 <code>(1 3 (5 7) 9)</code> 先要 <code>cdr</code> 得到 <code>(3 (5 7) 9)</code> </p>
<p>然后再 <code>cdr</code> 得到 <code>((5 7) 9)</code> </p>
<p>再 <code>car</code> 一下就能得到 <code>(5 7)</code>了。</p>
<p>所以答案如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; (1 3 (5 7) 9)</span></span><br><span class="line"><span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">3</span> <span class="list">(<span class="keyword">list</span> <span class="number">5</span> <span class="number">7</span>)</span> <span class="number">9</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">; ((7))</span></span><br><span class="line"><span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">7</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">; (1 (2 (3 (4 (5 (6 7))))))</span></span><br><span class="line"><span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="list">(<span class="keyword">list</span> <span class="number">5</span> <span class="list">(<span class="keyword">list</span> <span class="number">6</span> <span class="number">7</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>要注意 <code>cdr</code> 始终返回一个列表，所以 <code>(cdr (5 (6 7)))</code> 是 <code>((6 7))</code> 不是 <code>(6 7)</code> 。</p>
<h3 id="习题_2-26">习题 2.26</h3><blockquote>
<p><strong>Exercise 2.26.</strong>  Suppose we define <code>x</code> and <code>y</code> to be two lists:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> y <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>What result is printed by the interpreter in response to evaluating each of the following expressions:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">append</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword">cons</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword">list</span> x y)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>答案如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> y <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">append</span> x y)</span></span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4 5 6)</span></span><br><span class="line"><span class="list">(<span class="keyword">cons</span> x y)</span></span><br><span class="line"><span class="comment">; =&gt; ((1 2 3) 4 5 6)</span></span><br><span class="line"><span class="list">(<span class="keyword">list</span> x y)</span></span><br><span class="line"><span class="comment">; =&gt; ((1 2 3) (4 5 6))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-27">习题 2.27</h3><blockquote>
<p><strong>Exercise 2.27.</strong>  Modify your <code>reverse</code> procedure of exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_thm_2.18" target="_blank" rel="external">2.18</a> to produce a <code>deep-reverse</code> procedure that takes a list as argument and returns as its value the list with its elements reversed and with all subsists deep-reversed as well. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line">x</span><br><span class="line"><span class="list">(<span class="list">(<span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">reverse</span> x)</span></span><br><span class="line"><span class="list">(<span class="list">(<span class="number">3</span> <span class="number">4</span>)</span> <span class="list">(<span class="number">1</span> <span class="number">2</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">deep-reverse</span> x)</span></span><br><span class="line"><span class="list">(<span class="list">(<span class="number">4</span> <span class="number">3</span>)</span> <span class="list">(<span class="number">2</span> <span class="number">1</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>首先定义规则，深度反转空列表还是空列表。</p>
<p>深度反转单个叶子节点还是单个叶子节点。</p>
<p>深度反正一棵树等于反转剩余列表拼接上反转第一个列表。</p>
<p>翻译成代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">deep-reverse</span> tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">null</span>? tree)</span> <span class="list">()</span>)</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? tree)</span>)</span> <span class="list">(<span class="keyword">list</span> tree)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">else</span> <span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">deep-reverse</span> <span class="list">(<span class="keyword">cdr</span> tree)</span>)</span></span><br><span class="line">                      <span class="list">(<span class="keyword">deep-reverse</span> <span class="list">(<span class="keyword">car</span> tree)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">deep-reverse</span> x)</span></span><br><span class="line"><span class="comment">; =&gt; ((4 3) (2 1))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-28">习题 2.28</h3><blockquote>
<p><strong>Exercise 2.28.</strong>  Write a procedure <code>fringe</code> that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">fringe</span> x)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">fringe</span> <span class="list">(<span class="keyword">list</span> x x)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>类似上一题， <code>fringe</code> 空列表为空列表</p>
<p><code>fringe</code> 单个元素为单个元素。</p>
<p><code>fringe</code> 一棵树为<code>fringe</code> 第一个列表拼接上 <code>fringe</code> 剩余元素。</p>
<p>翻译成代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">fringe</span> tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">null</span>? tree)</span> <span class="list">()</span>)</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? tree)</span>)</span> <span class="list">(<span class="keyword">list</span> tree)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">else</span> <span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">fringe</span> <span class="list">(<span class="keyword">car</span> tree)</span>)</span></span><br><span class="line">                      <span class="list">(<span class="keyword">fringe</span> <span class="list">(<span class="keyword">cdr</span> tree)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">fringe</span> x)</span></span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4)</span></span><br><span class="line"><span class="list">(<span class="keyword">fringe</span> <span class="list">(<span class="keyword">list</span> x x)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4 1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-29">习题 2.29</h3><blockquote>
<p><strong>Exercise 2.29.</strong>  A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using <code>list</code>):</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">make-mobile</span> left right)</span></span><br><span class="line">  <span class="list">(<span class="keyword">list</span> left right)</span>)</span></span><br></pre></td></tr></table></figure>
<p>A branch is constructed from a <code>length</code> (which must be a number) together with a <code>structure</code>, which may be either a number (representing a simple weight) or another mobile:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">make-branch</span> length structure)</span></span><br><span class="line">  <span class="list">(<span class="keyword">list</span> length structure)</span>)</span></span><br></pre></td></tr></table></figure>
<p>a.  Write the corresponding selectors <code>left-branch</code> and <code>right-branch</code>, which return the branches of a mobile, and <code>branch-length</code> and <code>branch-structure</code>, which return the components of a branch.</p>
<p>b.  Using your selectors, define a procedure <code>total-weight</code> that returns the total weight of a mobile.</p>
<p>c.  A mobile is said to be <em>balanced</em> if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate that tests whether a binary mobile is balanced.</p>
<p>d.  Suppose we change the representation of mobiles so that the constructors are</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">make-mobile</span> left right)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cons</span> left right)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">make-branch</span> length structure)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cons</span> length structure)</span>)</span></span><br></pre></td></tr></table></figure>
<p>How much do you need to change your programs to convert to the new representation?</p>
</blockquote>
<p>问题 a 。只需要看数据结构的定义，所以四个选择器的定义如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> left-branch car)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">right-branch</span> tree)</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> tree)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> branch-length car)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">branch-structure</span> branch)</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> branch)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>接着实现问题 b 要求的 <code>total-weight</code> 。</p>
<p>分支的最基本类型是形如 <code>(5 3)</code> 这种第一个是长度，第二个是重量的类型。</p>
<p>这种情况分支的重量为 3</p>
<p>其他情况下分支的重量等于左子树的重量加上右子树的重量。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">total-weight</span> mobile)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? mobile)</span>)</span></span><br><span class="line">      mobile</span><br><span class="line">      <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">branch-structure</span> <span class="list">(<span class="keyword">left-branch</span> mobile)</span>)</span>)</span></span><br><span class="line">         <span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">branch-structure</span> <span class="list">(<span class="keyword">right-branch</span> mobile)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> l <span class="list">(<span class="keyword">make-branch</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> r <span class="list">(<span class="keyword">make-branch</span> <span class="number">6</span> <span class="number">7</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> s <span class="list">(<span class="keyword">make-branch</span> <span class="number">1</span> <span class="number">2</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">make-mobile</span> s <span class="list">(<span class="keyword">make-branch</span> <span class="number">7</span> <span class="list">(<span class="keyword">make-mobile</span> l r)</span>)</span>)</span>)</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">; =&gt; ((1 2) (7 ((3 4) (6 7))))</span></span><br><span class="line"><span class="list">(<span class="keyword">total-weight</span> x)</span></span><br><span class="line"><span class="comment">; =&gt; 13</span></span><br><span class="line"><span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">make-mobile</span> l r)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; 11</span></span><br></pre></td></tr></table></figure>
<p>问题 c 中定义平衡为所有的左右子数长度和重量的乘积相等。</p>
<p>对于最基本的 mobile 比如 2 。因为没有左右子树，所以认为是相等的。</p>
<p>对于其他的 mobile 比如 <code>((1 2) (3 4))</code> 判断左右重量和长度的乘积是否相等。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">balanced</span>? mobile)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? mobile)</span>)</span></span><br><span class="line">      #t</span><br><span class="line">      <span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">*</span> <span class="list">(<span class="keyword">branch-length</span> <span class="list">(<span class="keyword">left-branch</span> mobile)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">branch-structure</span> <span class="list">(<span class="keyword">left-branch</span> mobile)</span>)</span>)</span>)</span></span><br><span class="line">         <span class="list">(<span class="keyword">*</span> <span class="list">(<span class="keyword">branch-length</span> <span class="list">(<span class="keyword">right-branch</span> mobile)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">branch-structure</span> <span class="list">(<span class="keyword">right-branch</span> mobile)</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> l <span class="list">(<span class="keyword">make-branch</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span> </span><br><span class="line"><span class="list">(<span class="keyword">define</span> r <span class="list">(<span class="keyword">make-branch</span> <span class="number">6</span> <span class="number">7</span>)</span>)</span> </span><br><span class="line"><span class="list">(<span class="keyword">define</span> s <span class="list">(<span class="keyword">make-branch</span> <span class="number">1</span> <span class="number">2</span>)</span>)</span> </span><br><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">make-mobile</span> s <span class="list">(<span class="keyword">make-branch</span> <span class="number">7</span> <span class="list">(<span class="keyword">make-mobile</span> l r)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">balanced</span>? x)</span></span><br><span class="line"><span class="comment">; =&gt; #f</span></span><br><span class="line"><span class="list">(<span class="keyword">balanced</span>? <span class="list">(<span class="keyword">make-mobile</span> l l)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br><span class="line"><span class="list">(<span class="keyword">balanced</span>? <span class="list">(<span class="keyword">make-mobile</span> r r)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br><span class="line"><span class="list">(<span class="keyword">balanced</span>? <span class="list">(<span class="keyword">make-mobile</span> <span class="list">(<span class="keyword">make-branch</span> <span class="number">3</span> <span class="number">4</span>)</span> <span class="list">(<span class="keyword">make-branch</span> <span class="number">2</span> <span class="number">6</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br></pre></td></tr></table></figure>
<p>问题 d 。如果改变了定义中的数据结构，需要改动哪些。</p>
<p>基本的选择子肯定要改，还有要改的地方是 <code>total-weight</code> 和 <code>balanced?</code> 中判断是否为最基本的 mobile 的 语句。</p>
<p>也就是 <code>(not (pair? mobile))</code> 。</p>
<p>之所以要该这里是因为这里没有引入抽象屏障，<code>total-weight</code> 和 <code>balanced?</code> 知道了 mobile 的实现。</p>
<h3 id="习题_2-30">习题 2.30</h3><blockquote>
<p><strong>Exercise 2.30.</strong>  Define a procedure <code>square-tree</code> analogous to the <code>square-list</code> procedure of exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.21" target="_blank" rel="external">2.21</a>. That is, <code>square-list</code> should behave as follows:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-tree</span></span><br><span class="line"> <span class="list">(<span class="keyword">list</span> <span class="number">1</span></span><br><span class="line">       <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span> <span class="number">5</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">list</span> <span class="number">6</span> <span class="number">7</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="list">(<span class="number">4</span> <span class="list">(<span class="number">9</span> <span class="number">16</span>)</span> <span class="number">25</span>)</span> <span class="list">(<span class="number">36</span> <span class="number">49</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>Define <code>square-tree</code> both directly (i.e., without using any higher-order procedures) and also by using <code>map</code> and recursion.</p>
</blockquote>
<p>仿照 <code>scale-tree</code> 来做即可。</p>
<p>第一种，不使用高阶函数的类型</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-tree</span> tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">null</span>? tree)</span> <span class="list">()</span>)</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? tree)</span>)</span> <span class="list">(<span class="keyword">square</span> tree)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">else</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">square-tree</span> <span class="list">(<span class="keyword">car</span> tree)</span>)</span></span><br><span class="line">                    <span class="list">(<span class="keyword">square-tree</span> <span class="list">(<span class="keyword">cdr</span> tree)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>第二种，使用 <code>map</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-tree</span> tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">sub-tree</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? sub-tree)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">square</span> sub-tree)</span></span><br><span class="line">            <span class="list">(<span class="keyword">square-tree</span> sub-tree)</span>)</span>)</span></span><br><span class="line">      tree)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-31">习题 2.31</h3><blockquote>
<p><strong>Exercise 2.31.</strong>  Abstract your answer to exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.30" target="_blank" rel="external">2.30</a> to produce a procedure <code>tree-map</code> with the property that <code>square-tree</code> could be defined as</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-tree</span> tree)</span> <span class="list">(<span class="keyword">tree-map</span> square tree)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>只要照着上题把用到 <code>square</code> 的替换即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">tree-map</span> f tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">sub-tree</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? sub-tree)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">f</span> sub-tree)</span></span><br><span class="line">            <span class="list">(<span class="keyword">tree-map</span> f sub-tree)</span>)</span>)</span></span><br><span class="line">      tree)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-tree</span> <span class="quoted">'(<span class="number">1</span> (<span class="number">2</span> (<span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>) (<span class="number">6</span> <span class="number">7</span>))</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1 (4 (9 16) 25) (36 49))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-32">习题 2.32</h3><blockquote>
<p><strong>Exercise 2.32.</strong>  We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is <code>(1 2 3)</code>, then the set of all subsets is <code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code>. Complete the following definition of a procedure that generates the set of subsets of a set and give a clear explanation of why it works:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">subsets</span> s)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? s)</span></span><br><span class="line">      <span class="list">(<span class="keyword">list</span> <span class="literal">nil</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">let</span> <span class="list">(<span class="list">(<span class="keyword">rest</span> <span class="list">(<span class="keyword">subsets</span> <span class="list">(<span class="keyword">cdr</span> s)</span>)</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">append</span> rest <span class="list">(<span class="keyword">map</span> &lt;??&gt; rest)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于 <code>(subset (list 1 2 3))</code> 中 <code>rest</code> 为 <code>(subset (list 2 3))</code> </p>
<p>即 <code>((3) (2) (2 3) () )</code> 。对比 <code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code></p>
<p>发现少了 <code>(1) (1 3) (1 2)</code>。</p>
<p>所以需要用 <code>map</code> 把每一个元素拼接成子集。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">subsets</span> s)</span></span><br><span class="line">    <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? s)</span></span><br><span class="line">        <span class="list">(<span class="keyword">list</span> <span class="quoted">'()</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">let</span> <span class="list">(<span class="list">(<span class="keyword">rest</span> <span class="list">(<span class="keyword">subsets</span> <span class="list">(<span class="keyword">cdr</span> s)</span>)</span>)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">append</span> rest <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span></span><br><span class="line">                                <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">car</span> s)</span> x)</span>)</span></span><br><span class="line">                              rest)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>()</code> 的子集是 <code>(())</code>。</p>
<h3 id="习题_2-33">习题 2.33</h3><blockquote>
<p><strong>Exercise 2.33.</strong>  Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">map</span> p sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span> y)</span> &lt;??&gt;)</span> <span class="literal">nil</span> sequence)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">append</span> seq1 seq2)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> cons &lt;??&gt; &lt;??&gt;)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">length</span> sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> &lt;??&gt; <span class="number">0</span> sequence)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意到 <code>accumulate</code> 中的函数第一个参数 <code>x</code> 是当前 <code>sequance</code> 的值，<code>y</code> 是累积的值。</p>
<p>所以只需要运算后拼接起来就可以了。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">map</span> p sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span> y)</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">p</span> x)</span> y)</span>)</span> <span class="literal">nil</span> sequence)</span>)</span></span><br></pre></td></tr></table></figure>
<p>对于 <code>append</code> 只需要将 <code>seq1</code> 中的元素一个个 <code>cons</code> 上去即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">append</span> seq1 seq2)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> cons seq2 seq1)</span>)</span></span><br></pre></td></tr></table></figure>
<p>计算长度，每个元素 + 1 长度。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">length</span> sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span> y)</span> <span class="list">(<span class="keyword">+</span> y <span class="number">1</span>)</span>)</span> <span class="number">0</span> sequence)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-34">习题 2.34</h3><blockquote>
<p><strong>Exercise 2.34.</strong>  Evaluating a polynomial in $x$ at a given value of $x$ can be formulated as an accumulation. We evaluate the polynomial<br>$$<br>a_nr^n + a_{n-1}r^{n-1} + \cdots + a_1r + a_0<br>$$<br>using a well-known algorithm called <em>Horner’s rule</em>, which structures the computation as<br>$$<br>(\cdots(a_nr + a_{n-1})r + \cdots + a_1)r + a_0<br>$$<br>In other words, we start with $a_n$ multiply by $x$, add $a_{n-1}$, multiply by $x$, and so on, until we reach $a_0$.<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_186" target="_blank" rel="external">16</a> Fill in the following template to produce a procedure that evaluates a polynomial using Horner’s rule. Assume that the coefficients of the polynomial are arranged in a sequence, from $a_0$ through $a_n$.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">horner-eval</span> x coefficient-sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">this-coeff</span> higher-terms)</span> &lt;??&gt;)</span></span><br><span class="line">              <span class="number">0</span></span><br><span class="line">              coefficient-sequence)</span>)</span></span><br></pre></td></tr></table></figure>
<p>For example, to compute $1+3x+5x^3+x^5$ at  $x = 2$ you would evaluate</p>
<p><code>(horner-eval 2 (list 1 3 0 5 0 1))</code></p>
</blockquote>
<p>注意到 <code>accumulate</code> 的计算顺序是从右到左。所以只需要重复计算 $a_nr+a_{n-1}$ 即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">horner-eval</span> x coefficient-sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">this-coeff</span> higher-terms)</span>   <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">*</span> higher-terms x)</span></span><br><span class="line">                                                       this-coeff)</span>)</span></span><br><span class="line">              <span class="number">0</span></span><br><span class="line">              coefficient-sequence)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">horner-eval</span> <span class="number">1</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; 10</span></span><br><span class="line"><span class="list">(<span class="keyword">horner-eval</span> <span class="number">2</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; 79</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-35">习题 2.35</h3><blockquote>
<p><strong>Exercise 2.35.</strong>  Redefine <code>count-leaves</code> from section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.2" target="_blank" rel="external">2.2.2</a> as an accumulation:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">count-leaves</span> <span class="literal">t</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> &lt;??&gt; &lt;??&gt; <span class="list">(<span class="keyword">map</span> &lt;??&gt; &lt;??&gt;)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>用 <code>map</code> 遍历数，如果是叶子就长度 + 1，不是就计算叶子数量。这样累加就能得到答案。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">count-leaves</span> <span class="literal">t</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> + <span class="number">0</span> <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">sub-tree</span>)</span></span><br><span class="line">                         <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? sub-tree)</span>)</span></span><br><span class="line">                             <span class="number">1</span></span><br><span class="line">                             <span class="list">(<span class="keyword">count-leaves</span> sub-tree)</span>)</span>)</span></span><br><span class="line">                       <span class="literal">t</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-36">习题 2.36</h3><blockquote>
<p><strong>Exercise 2.36.</strong>  The procedure <code>accumulate-n</code> is similar to <code>accumulate</code> except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation procedure to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results. For instance, if <code>s</code> is a sequence containing four sequences, <code>((1 2 3) (4 5 6) (7 8 9) (10 11 12))</code>, then the value of <code>(accumulate-n + 0 s)</code> should be the sequence <code>(22 26 30)</code>. Fill in the missing expressions in the following definition of <code>accumulate-n</code>:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">accumulate-n</span> op init seqs)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? <span class="list">(<span class="keyword">car</span> seqs)</span>)</span></span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">accumulate</span> op init &lt;??&gt;)</span></span><br><span class="line">            <span class="list">(<span class="keyword">accumulate-n</span> op init &lt;??&gt;)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于空的序列 <code>(())</code> 结果为 <code>()</code>。</p>
<p>对于非空序列 <code>((1 2) (3 4))</code> 结果是 <code>(cons (list 1 3) (list 2 4))</code></p>
<p>所以要得到序列中的每一个元素，使用 <code>map car</code> 。</p>
<p>剩下的类似</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">accumulate-n</span> op init seqs)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? <span class="list">(<span class="keyword">car</span> seqs)</span>)</span></span><br><span class="line">      <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">accumulate</span> op init <span class="list">(<span class="keyword">map</span> car seqs)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">accumulate-n</span> op init <span class="list">(<span class="keyword">map</span> cdr seqs)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">accumulate-n</span> + <span class="number">0</span> <span class="quoted">'(())</span>)</span></span><br><span class="line"><span class="comment">; =&gt; ()</span></span><br><span class="line"><span class="list">(<span class="keyword">accumulate-n</span> + <span class="number">0</span> <span class="quoted">'((<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) (<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>) (<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>))</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (12 15 18)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-37">习题 2.37</h3><blockquote>
<p><strong>Exercise 2.37.</strong>  Suppose we represent vectors $v = (v_i)$  as sequences of numbers, and matrices $m = (m_{ij})$ as sequences of vectors (the rows of the matrix). For example, the matrix<br>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 &amp; 4\\<br>4 &amp; 5 &amp; 6 &amp; 6\\<br>6 &amp; 7 &amp; 8 &amp; 9<br>\end{bmatrix}<br>$$<br>is represented as the sequence <code>((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>. With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:</p>
<table>
<thead>
<tr>
<th><code>(dot-product v w)</code></th>
<th>returns the sum $\sum_{i} v_iw_i$</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(matrix-*-vector m v)</code></td>
<td>returns the vector $t$, where $t_i = \sum_j m_{ij}v_j$</td>
</tr>
<tr>
<td><code>(matrix-*-matrix m n)</code></td>
<td>returns the matrix $p$, where $p_{ij} = \sum_{k} m_{ik}n_{kj}$</td>
</tr>
<tr>
<td><code>(transpose m)</code></td>
<td>returns the matrix $n$, where $n_{ij} = m_{ji}$</td>
</tr>
</tbody>
</table>
<p>We can define the dot product as<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_190" target="_blank" rel="external">17</a></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">dot-product</span> v w)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> + <span class="number">0</span> <span class="list">(<span class="keyword">map</span> <span class="variable">* v w)))</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>Fill in the missing expressions in the following procedures for computing the other matrix operations. (The procedure <code>accumulate-n</code> is defined in exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.36" target="_blank" rel="external">2.36</a>.)</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">matrix-*-vector</span> m v)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> &lt;??&gt; m)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">transpose</span> mat)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate-n</span> &lt;??&gt; &lt;??&gt; mat)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">matrix-*-matrix</span> m n)</span></span><br><span class="line">  <span class="list">(<span class="keyword">let</span> <span class="list">(<span class="list">(<span class="keyword">cols</span> <span class="list">(<span class="keyword">transpose</span> n)</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">map</span> &lt;??&gt; m)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>先看 <code>matrix-*-vector</code> 中 <code>map</code> 后是一个 vector ，根据矩阵和向量乘法的定义，需要两个向量相乘。</p>
<p>所以需要使用 <code>dot-product</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">matrix-*-vector</span> m v)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">mi</span>)</span> <span class="list">(<span class="keyword">dot-product</span> v mi)</span>)</span> m)</span>)</span></span><br></pre></td></tr></table></figure>
<p>对于转置 <code>transpose</code> ，每个元素之间只需要 <code>cons</code> </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">transpose</span> mat)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate-n</span> cons <span class="quoted">'()</span> mat)</span>)</span></span><br></pre></td></tr></table></figure>
<p>然后是矩阵相乘，<code>matrix-*-matrix</code> 中的 <code>map</code> 后是一个 vector，而 $n$ 转置后还是一个矩阵。</p>
<p>将转置过后 $n$ 的每一行和 $m$ 每一行相乘。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">matrix-*-matrix</span> m n)</span></span><br><span class="line">  <span class="list">(<span class="keyword">let</span> <span class="list">(<span class="list">(<span class="keyword">cols</span> <span class="list">(<span class="keyword">transpose</span> n)</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">mi</span>)</span> <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">ni</span>)</span> <span class="list">(<span class="keyword">dot-product</span> ni mi)</span>)</span> cols)</span> m)</span>)</span>)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没填坑都快忘了……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SICP" scheme="http://en.ors-sro.com/tags/SICP/"/>
    
  </entry>
  
  <entry>
    <title>词法作用域和动态作用域</title>
    <link href="http://en.ors-sro.com/Lexical-scoppe-and-Dynamic-scoppe/"/>
    <id>http://en.ors-sro.com/Lexical-scoppe-and-Dynamic-scoppe/</id>
    <published>2017-04-23T08:29:24.000Z</published>
    <updated>2017-04-23T08:48:02.363Z</updated>
    
    <content type="html"><![CDATA[<p>不知道也可以好好写程序。</p>
<a id="more"></a>
<h2 id="定义">定义</h2><p>写代码的时候，经常使用变量名来代替字面量和输入的内容。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String prefix = <span class="string">"Your name is "</span>;</span><br><span class="line">String name = Console.readLine();</span><br><span class="line">Console.WriteLine(prefix + name);</span><br></pre></td></tr></table></figure>
<p><strong>定义变量</strong>是将值（字面量或者输入）绑定到变量名字的一个过程。</p>
<p>那使用变量的时候，就要有一个相反的过程。</p>
<p><strong>解析变量</strong>是将变量名字按照绑定解析为值的一个过程。</p>
<p>在上述例子中 <code>String prefix = &quot;Your name is &quot;</code> 定义了一个绑定 <code>prefix -&gt; &quot;Your name is &quot;</code></p>
<p>在 <code>Console.WriteLine(prefix + name)</code> 解析 <code>prefix</code> 时，</p>
<p>按照绑定 <code>prefix -&gt; &quot;Your name is &quot;</code> 替换 <code>prefix</code> 为 <code>&quot;Your name is &quot;</code>。</p>
<p>词法作用域和动态作用域描述的是变量解析时的规则。</p>
<p><strong>词法作用域</strong>是解析变量时从词法环境查找变量值的规则。在实际应用中，词法环境通常是块级作用域，函数作用域等。也就是会跟源码有关，先从定义时的作用域查找，找不到再查找外层作用域。因为查找的路径跟源码有关，可以在编译时确定，所以又称为静态作用域。现代语言大多使用静态作用域。</p>
<p><strong>动态作用域</strong>是解析变量时从执行环境查找变量值的规则。在实际应用中，执行环境通常是调用栈。也就是会跟运行状态有关。先从运行的函数中查找，找不到再顺着调用栈中的其他函数查找。因为查找的路径与调用顺序有关，只能在运行时确定，所以称为动态作用域。只有少数语言使用动态作用域。</p>
<h2 id="例子">例子</h2><p>定义不是那么直观。看一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">g(); <span class="comment">// 返回 0 还是返回 1 ？</span></span><br></pre></td></tr></table></figure>
<p>按照直觉，也就是现代语言的方式（静态作用域），执行 <code>f()</code>  ，<code>f</code> 中返回 <code>x</code> 。</p>
<p><code>x</code> 没有在 <code>f</code> 中定义，所以就去外层（全局）中查找，找到定义为 <code>var x = 0</code> 。</p>
<p>所以返回 0 。</p>
<p>按照动态作用域的定义，执行 <code>f()</code> ，<code>f</code> 中返回 <code>x</code> 。</p>
<p><code>x</code> 没有在 <code>f</code> 中定义，所以顺着调用栈查找，<code>f</code> 是被 <code>g</code> 调用的。</p>
<p><code>g</code> 中定义 <code>var x = 1</code> 。</p>
<p>所以返回 1 。</p>
<p>因此词法作用域可以看源代码就能确定 <code>f()</code> 的返回值，而动态作用域得在运行时才能确定，取决于谁调用了 <code>f()</code>。</p>
<h2 id="历史">历史</h2><p>静态作用域因为很符合直觉。所以一出现就纷纷被采用。所以现在大部分语言都是静态作用域。</p>
<p>那为什么一开始语言没有采用静态作用域而是动态作用域呢？</p>
<p>因为动态作用域太容易实现了。</p>
<p>定义变量就把变量名和值的绑定推到栈上。</p>
<p>解析变量就是顺着栈查找。</p>
<p>相当于只有一个词法环境，也就是全局词法环境。</p>
<p>而要实现词法作用域就不是那么简单了。首先要规定词法环境，最小的词法环境是块级作用域还是函数作用域。</p>
<p>然后还要在词法分析的时候做相应的工作。</p>
<p>词法作用域首先出现于 ALGOL ，后被 Scheme 和 Common Lisp 采用。</p>
<p>现在大部分语言都使用词法作用域。</p>
<h2 id="现存">现存</h2><p>即使是采用词法作用域的语言，也有使用动态作用域的地方。</p>
<p>C 语言中，宏展开使用的是动态作用域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> a (x + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x = <span class="number">0</span>; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span> <span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span> </span>&#123; b(); c(); &#125;</span><br></pre></td></tr></table></figure>
<p>按照词法作用域的原则，宏 <code>a</code> 中的 <code>x</code> 应该为 2 。与被谁调用无关。</p>
<p>但实际是 <code>b()</code> 打印出 1 。<code>c()</code> 打印出 2 。</p>
<p>所以宏展开是动态作用域。</p>
<p>因此 《C ++ Primer 》推荐少用宏。当然除了这个原因还有一个宏卫生的原因。</p>
<p>JavaScript 也用静态作用域，但可以使用 <code>eval()</code> 模拟动态作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = x =&gt; <span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    print(x);</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g_ = <span class="built_in">eval</span>(<span class="string">"("</span> + <span class="built_in">String</span>(g) + <span class="string">")"</span>);</span><br><span class="line">    <span class="comment">/*  g_ = function g() &#123;</span><br><span class="line">      print(x);</span><br><span class="line">      x = 2;</span><br><span class="line">    &#125; */</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">    g_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();                         <span class="comment">// prints 3</span></span><br><span class="line"></span><br><span class="line">print(x);                    <span class="comment">// prints 1</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li><a href="1">维基</a></li>
<li><a href="http://stackoverflow.com/questions/11533771/scope-rules-for-c-macros" target="_blank" rel="external">Scope rules for C macros</a></li>
<li><a href="http://stackoverflow.com/questions/10060857/is-it-possible-to-achieve-dynamic-scoping-in-javascript-without-resorting-to-eva" target="_blank" rel="external">Is it possible to achieve dynamic scoping in JavaScript without resorting to eval?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道也可以好好写程序。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="作用域" scheme="http://en.ors-sro.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 闭包</title>
    <link href="http://en.ors-sro.com/JavaScript-Closure/"/>
    <id>http://en.ors-sro.com/JavaScript-Closure/</id>
    <published>2017-04-16T10:07:07.000Z</published>
    <updated>2017-04-16T10:13:35.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>闭包是穷人的对象。对象是穷人的闭包。</p>
</blockquote>
<a id="more"></a>
<h2 id="定义">定义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetCounter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> ++c&#125;</span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = GetCounter()</span><br><span class="line">counter()</span><br></pre></td></tr></table></figure>
<p>这段代码的返回值是 <code>undefined</code> 还是 1 ？</p>
<p>答案是 1 。</p>
<p>因为这是 JavaScript 的一个重要特性——闭包（Closure）。</p>
<p>闭包是一个包含函数和其变量绑定的对象。</p>
<p>例如上述代码中，<code>counter</code> 是一个闭包。</p>
<p>其中函数为 <code>function count() {return ++c}</code> ，变量绑定为 <code>{c: GetCounter.c}</code>。</p>
<h2 id="释疑">释疑</h2><p>如果你学习过 C 系列的语言，可能会感到疑惑。</p>
<p>函数返回了怎么还能引用其中的局部变量。</p>
<p>这是因为 JavaScript 有两个特性——词法作用域和一等公民函数。</p>
<p>先说词法作用域，简单来说词法作用域是描述查找变量的值的一种规则——从定义处查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = FunctionScope()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>这段代码的返回值是什么？是 <code>ReferenceError</code> 吗？</p>
<p>不一定。因为还不知道 <code>scope</code> 的定义。</p>
<p>那从哪获取 <code>scope</code> 的定义呢。当然是从这段代码所处的地方获取。</p>
<p>假设改成这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">"global scope"</span></span><br><span class="line"><span class="keyword">let</span> f = FunctionScope()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>那么代码的返回值就是 <code>&quot;global scope&quot;</code>。因为所处的作用域有变量绑定<code>{scope: global.scope}</code> （这里使用 Javascript 的对象语法来表示变量绑定）</p>
<p>如果改成这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> scope = <span class="string">"function scope"</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">"global scope"</span></span><br><span class="line"><span class="keyword">let</span> f = FunctionScope()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>那么代码的返回值是<code>&quot;function scope&quot;</code> 。为什么不是 <code>&quot;global scope&quot;</code> 呢？</p>
<p>因为定义函数同时会定义作用域。</p>
<p>定义 <code>FunctionScope</code> 的时候也定义了 <code>{scope: FunctionScope.scope}</code></p>
<p>将这个作用域插入到作用域链中，整个作用域链为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;scope: FunctionScope.scope&#125; -&gt; &#123;scope: global.scope&#125;</span><br></pre></td></tr></table></figure>
<p>按照词法作用域的规则，变量的值从定义处查找。所以先从 <code>{scope: FunctionScope}</code> 中查找。</p>
<p>发现有记录，通过引用 <code>FunctionScope.scope</code> 找到值 <code>&quot;function scope&quot;</code> 。所以返回 <code>&quot;function scope&quot;</code> 。如果找不到，就顺着作用域链查找直到找不到抛出 <code>ReferenceError</code></p>
<p>如果仅仅有词法作用域是不够的。C 语言也是词法作用域，但是并没有听说过闭包。</p>
<p>这是因为 Javascript 将函数视为一等公民。</p>
<p>所以函数可以随意的创建，赋值到变量，传递为参数，作为返回值等。</p>
<p>这里最重要的是可以在函数中定义函数。</p>
<p>JavaScript 定义函数的时候会创建函数作用域，将当前环境中的变量通过引用的方式记录下来。</p>
<p>在上述例子中，<code>f()</code> 定义的同时定义了函数作用域 <code>{scope: FunctionScope.scope}</code> </p>
<p>返回 <code>f()</code> 也会连同函数作用域一同返回。</p>
<p>如果一个变量没有引用，就会被垃圾收集器回收。比如函数中的局部变量，在函数执行完后没有引用就会被回收。</p>
<p>但是如果返回了函数，比如说 <code>f()</code> 因为函数作用域 <code>{scope: FunctionScope.scope}</code> 引用了 <code>scope</code> 所以 <code>scope</code> 不会被回收。</p>
<p>所以函数执行完后还可以使用局部变量。</p>
<h2 id="注意">注意</h2><p>理论上所有函数都是闭包，但是因为有的函数没有访问内部变量，所以没有闭包的感觉。</p>
<p>返回函数是定义闭包的一种方式，但不是唯一方式。</p>
<p>比如还可以返回一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">   reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; n = <span class="number">0</span>; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个闭包定义调用两次返回不同的闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = counter(), d = counter(); <span class="comment">// 创造两个 counter</span></span><br><span class="line">c.count() <span class="comment">// =&gt; 0</span></span><br><span class="line">d.count() <span class="comment">// =&gt; 0: 独立计数</span></span><br><span class="line">c.reset() <span class="comment">// reset() 和 count() 方法共享状态</span></span><br><span class="line">c.count() <span class="comment">// =&gt; 0: 因为重置了 c</span></span><br><span class="line">d.count() <span class="comment">// =&gt; 1: d 没有重置</span></span><br></pre></td></tr></table></figure>
<p>闭包中的变量绑定只记录引用，不记录具体的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Funcs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> funcs = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> i&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> functions = Funcs()</span><br><span class="line">functions[<span class="number">2</span>]()</span><br></pre></td></tr></table></figure>
<p>所以这段代码返回的是 5 不是 2。因为循环结束后 <code>i</code> 的值为 5。</p>
<p>还需要注意的一点是闭包中的 <code>this</code> 不是外层的 <code>this</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a &#125;</span><br><span class="line">  <span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = f()</span><br><span class="line">h()</span><br></pre></td></tr></table></figure>
<p>这段代码会返回 <code>undefined</code> 因为 <code>g</code> 中的 <code>this.a</code> 的 <code>this</code> 指的是 <code>g</code>。</p>
<p>因为 <code>g</code> 中没有变量 <code>a</code> 的定义，所以返回 <code>undefined</code>。</p>
<p>只要改成 <code>self.a</code> 就可以了。</p>
<p>此外还可以使用 ES6 的箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> g = () =&gt; a</span><br><span class="line">  <span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = f()</span><br><span class="line">h()</span><br></pre></td></tr></table></figure>
<h2 id="最后">最后</h2><p>文章的内容参考了<a href="http://shop.oreilly.com/product/9780596805531.do" target="_blank" rel="external">犀牛书</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;闭包是穷人的对象。对象是穷人的闭包。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavsScript" scheme="http://en.ors-sro.com/tags/JavsScript/"/>
    
  </entry>
  
  <entry>
    <title>值类别</title>
    <link href="http://en.ors-sro.com/Value-Category/"/>
    <id>http://en.ors-sro.com/Value-Category/</id>
    <published>2017-04-09T13:55:24.000Z</published>
    <updated>2017-04-09T14:14:11.532Z</updated>
    
    <content type="html"><![CDATA[<p>如何把一个简单的事情搞复杂。</p>
<a id="more"></a>
<h2 id="简单的开始">简单的开始</h2><p>左值和右值是 C 和 C++ 语言中表达式的一种值的分类。每个表达式都有类型和值类别。</p>
<p>如 <code>1 + 1</code> 的类型为 <code>int</code> ，值类别为右值。</p>
<p>在 C++ 03 左值和右值很容易区分。</p>
<p>左值（left value, lvalue）为内存地址，可以出现在赋值等号的左边和右边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// x 是左值</span></span><br><span class="line"><span class="keyword">int</span> y = x; <span class="comment">// x 可以出现在赋值等号的右边</span></span><br></pre></td></tr></table></figure>
<p>右值（right value, rvalue）为<strong>只能</strong>出现在赋值等号右边的表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// x 是右值</span></span><br><span class="line"><span class="number">1</span> = x; <span class="comment">// 出错， 1 是右值，只能出现在赋值等号的右边。</span></span><br></pre></td></tr></table></figure>
<h2 id="复杂的延续">复杂的延续</h2><p>C++ 11 引入了移动语义。</p>
<p>对于类型 T ，<code>T&amp;&amp;</code> 称为右值引用 （rvalue reference）。<code>T&amp;</code> 称为左值引用（lvalue reference）。</p>
<p>如果类型 T 实现了移动构造函数，则称 T 为可移动的。</p>
<p>引入了语义，问题随之而来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; f() &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>那么 <code>f()</code> 是左值还是右值？</p>
<p><code>f()</code> 不是左值因为左值不可移动。</p>
<p><code>f()</code> 不是右值因为可以出现在赋值等号的左边。</p>
<p>所以引入一种新的值类别，称为<strong>亡值</strong>（eXpiring value, <strong>xvalue</strong>）。<code>f()</code> 为亡值。</p>
<p>原先的左值变成了<strong>泛左值</strong>（generalized value, <strong>glvalue</strong>）。</p>
<p>原先的右值变成了<strong>纯右值</strong>（pure value, <strong>prvalue</strong>）。</p>
<p>定义新的<strong>左值</strong>为非亡值的泛左值。</p>
<p>定义新的<strong>右值</strong>为纯右值或者亡值。</p>
<p>用图表示就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;                                                                     +----------------+&#10;                                                                     |                |&#10;                                                          +---------&#62;+      &#24038; &#20540;     |&#10;                                                          |          |                |&#10;                                 +----------------+       |          +----------------+&#10;                                 |                |       |&#10;                         +------&#62;+    &#27867; &#24038; &#20540;    +-------+&#10;                         |       |                |       |&#10;+----------------+       |       +----------------+       |          +----------------+&#10;|                |       |                                |          |                |&#10;|    &#20540; &#31867; &#21035;     +-------+                                +---------&#62;+     &#20129; &#20540;      |&#10;|                |       |                                |          |                |&#10;+----------------+       |       +----------------+       |          +----------------+&#10;                         |       |                |       |&#10;                         +------&#62;+    &#32431; &#21491; &#20540;    +-------+&#10;                                 |                |       |&#10;                                 +----------------+       |          +----------------+&#10;                                                          |          |                |&#10;                                                          +---------&#62;+      &#21491; &#20540;     |&#10;                                                                     |                |&#10;                                                                     +----------------+</span><br></pre></td></tr></table></figure>
<p>表达式一定是左值，亡值，右值中的一种。</p>
<p>左值等具体代码可参考<a href="http://en.cppreference.com/w/cpp/language/value_category#Primary categories" target="_blank" rel="external">基础类别</a>。</p>
<p>具体的定义可以参考<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf" target="_blank" rel="external">n3055</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何把一个简单的事情搞复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://en.ors-sro.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>停机问题</title>
    <link href="http://en.ors-sro.com/Halting-problem/"/>
    <id>http://en.ors-sro.com/Halting-problem/</id>
    <published>2017-04-02T05:49:01.000Z</published>
    <updated>2017-04-09T10:26:08.513Z</updated>
    
    <content type="html"><![CDATA[<p>如果存在这样的算法就太完美了。</p>
<a id="more"></a>
<h2 id="定义">定义</h2><blockquote>
<p><strong>停机问题</strong>（英语：halting problem）是<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91" target="_blank" rel="external">逻辑数学</a>中<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%A1%E7%AE%97%E6%80%A7%E7%90%86%E8%AE%BA" target="_blank" rel="external">可计算性理论</a>的一个问题。通俗地说，停机问题就是判断任意一个<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F" target="_blank" rel="external">程序</a>是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。</p>
<p>—— 维基百科</p>
</blockquote>
<p>程序为什么会不停机呢？程序有三种结构 —— 顺序结构，条件结构，循环结构。</p>
<p>如果程序只允许使用顺序结构和条件结构，而且代码行数是有限的，那么程序一定会停机。</p>
<p>但如果使用了循环结构（包括递归），就有可能陷入死循环。因为可能由于程序 BUG 等原因导致无限递归或者无线循环。</p>
<p>停机问题找寻的是一种<strong>通用</strong>的算法。如果是一段具体的代码还是可以判断出是否停机的。</p>
<h2 id="理发师">理发师</h2><p>如果一个人不给自己理发，那么理发师就给他理发。</p>
<p>如果一个人自己理发，那么理发师就不给他理发。</p>
<p>那么理发师给不给自己理发？</p>
<p>如果理发师给自己理发，那么按照一个人自己理发的原则，理发师就不应该给这个理发。</p>
<p>如果理发师不给自己理发，那么按照一个人不给自己理发的原则，理发师应该给自己理发。</p>
<p>本质上这是一阶逻辑自我指涉的不自洽性。</p>
<h2 id="证明">证明</h2><p>停机问题的证明类似理发师悖论。</p>
<p>如果存在一个判断程序是否停机的算法，停机的时候返回 1 ，不停机返回 0 。</p>
<p>那么构造一个相反的算法，停机的时候返回 0 ，不停机的是否返回 1 。</p>
<p>如果用停机算法判断这个相反的算法结果会是怎样。</p>
<p>如果结果是停机，根据停机算法的定义得出相反的算法会停机。但是这跟相反算法的定义矛盾。相反算法定义为与停机算法结果相反。停机算法结果是停机，那么相反算法会不停机。</p>
<p>如果结果是不停机，根据停机算法的定义得出相反的算法不停机。但是这跟相反算法的定义矛盾。相反算法定义为与停机算法结果相反。停机算法的结果是不停机，那么相反算法会停机。</p>
<p>所以不存在<strong>通用</strong>的停机检测算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果存在这样的算法就太完美了。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="逻辑" scheme="http://en.ors-sro.com/tags/%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>Monad Transformers</title>
    <link href="http://en.ors-sro.com/Monad-Transformers/"/>
    <id>http://en.ors-sro.com/Monad-Transformers/</id>
    <published>2017-03-26T11:22:50.000Z</published>
    <updated>2017-03-26T13:04:26.901Z</updated>
    
    <content type="html"><![CDATA[<p>组合两个 Monad 的 Monad</p>
<a id="more"></a>
<p>本文为 <a href="https://en.wikibooks.org/wiki/Haskell/Monad_transformers" target="_blank" rel="external">Monad Transformers</a> 的学习笔记。</p>
<h2 id="困境">困境</h2><p>有时候需要校验输入内容。比如验证是否为符合要求的密码</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="import"><span class="keyword">import</span> Data.Char</span></span><br><span class="line"><span class="import"><span class="keyword">import</span> Data.Maybe</span></span><br><span class="line"></span><br><span class="line"><span class="title">isValid</span> :: <span class="type">String</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isValid</span> s = length s &gt;= <span class="number">8</span></span><br><span class="line">            &amp;&amp; any isAlpha s</span><br><span class="line">            &amp;&amp; any isNumber s</span><br><span class="line">            &amp;&amp; any isPunctuation s</span><br></pre></td></tr></table></figure>
<p>获取输入</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 因为需要携带值，所以这里使用 Maybe String 而不是 Bool</span></span><br><span class="line"><span class="title">getPassphrase</span> :: <span class="type">IO</span> (<span class="type">Maybe</span> <span class="type">String</span>)</span><br><span class="line"><span class="title">getPassphrase</span> = <span class="keyword">do</span> s &lt;- getLine</span><br><span class="line">                   <span class="keyword">if</span> isValid s <span class="keyword">then</span> return $ <span class="type">Just</span> s</span><br><span class="line">                                <span class="keyword">else</span> return <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>校验</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">askPassphrase</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">askPassphrase</span> = <span class="keyword">do</span> putStrLn <span class="string">"请输入密码："</span></span><br><span class="line">                   maybe_value &lt;- getPassphrase</span><br><span class="line">                   <span class="keyword">if</span> isJust maybe_value <span class="comment">-- 这里手动判断是否合法</span></span><br><span class="line">                     <span class="keyword">then</span> <span class="keyword">do</span> putStrLn maybe_value ++ <span class="string">" 是个不错的密码"</span> </span><br><span class="line">                     <span class="keyword">else</span> return ()</span><br></pre></td></tr></table></figure>
<p>代码中使用 <code>isJust</code> 判断是否合法。在数量比较少的情况下不是什么问题。通常使用 Maybe Monad 是不需要手动判断是否为 <code>Just</code> 。因为有 <code>&gt;&gt;=</code> 。</p>
<p>所以这里是否能使用 Maybe Monad 来避免手动检查呢。</p>
<p>假设去点 <code>isJust</code> 的三行判断代码。从新编写一个函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">askPassphrase</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">askPassphrase</span> = <span class="keyword">do</span> putStrLn <span class="string">"请输入密码："</span></span><br><span class="line">                   maybe_value &lt;- getPassphrase</span><br><span class="line">                   maybe_value &gt;&gt;= f</span><br></pre></td></tr></table></figure>
<p>这个 <code>f</code> 的类型是什么呢？</p>
<p>首先 <code>askPassphrase</code> 的类型是 <code>IO ()</code> 。所以 <code>f</code> 需要返回 <code>IO ()</code></p>
<p>而 <code>f</code> 又接受一个 <code>String</code> 类型的参数。</p>
<p>所以 <code>f</code> 的类型应该是</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure>
<p>但是这样不能用于 <code>maybe_value &gt;&gt;= f</code> 因为 <code>&gt;&gt;=</code> 的类型是</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t (&gt;&gt;=)</span><br><span class="line">(&gt;&gt;=) :: <span class="type">Monad</span> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure>
<p>所以要使用 <code>&gt;&gt;=</code> ，<code>f</code> 的类型必须是</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">String</span> -&gt; <span class="type">Maybe</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>显然两个类型冲突了，所以写不出来。</p>
<p>所以需要一个能够组合 Maybe Monad 和 IO Monad 的类型。</p>
<p>这个就是 Monad Transformers</p>
<h2 id="定义">定义</h2><p>定义 Maybe Monad 的 Monad Transformer <code>MaybeT</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">newtype</span> <span class="type">MaybeT</span> m a = <span class="type">MaybeT</span> <span class="container">&#123; <span class="title">runMaybeT</span> :: <span class="title">m</span> (<span class="type">Maybe</span> <span class="title">a</span>) &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>其中 m 可以为任意 Monad</p>
<p>Monad Transformer 本身也是 Monad 。所以需要实现 <code>return</code> 和 <code>&gt;&gt;=</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">Monad</span> <span class="container">(<span class="type">MaybeT</span> <span class="title">m</span>)</span> <span class="keyword">where</span></span></span><br><span class="line">    return  = <span class="type">MaybeT</span> . return . <span class="type">Just</span></span><br><span class="line">    <span class="comment">-- return a = MaybeT . return . Just a</span></span><br></pre></td></tr></table></figure>
<p><code>Just</code> 将 a 转化为 <code>Maybe a</code> 类型</p>
<p><code>return</code> 将 <code>Maybe a</code> 转化为 <code>m (Maybe a)</code> 类型</p>
<p><code>MaybeT</code> 将 <code>m (Maybe a)</code> 转化为 <code>MaybeT m (Maybe a)</code> 类型。</p>
<p>接着实现 <code>&gt;&gt;=</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (&gt;&gt;=) 定义中的 m 为 MaybeT m</span></span><br><span class="line">(&gt;&gt;=) :: <span class="type">MaybeT</span> m a -&gt; (a -&gt; <span class="type">MaybeT</span> m b) -&gt; <span class="type">MaybeT</span> m b</span><br><span class="line"></span><br><span class="line"><span class="title">x</span> &gt;&gt;= f = <span class="type">MaybeT</span> $ <span class="keyword">do</span> maybe_value &lt;- runMaybeT x</span><br><span class="line">                      <span class="keyword">case</span> maybe_value <span class="keyword">of</span></span><br><span class="line">                           <span class="type">Nothing</span>    -&gt; return <span class="type">Nothing</span></span><br><span class="line">                           <span class="type">Just</span> value -&gt; runMaybeT $ f value</span><br></pre></td></tr></table></figure>
<p>为了使用方便，顺便实现相应的 MonadPlus 和 MonadTrans</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadPlus</span> <span class="container">(<span class="type">MaybeT</span> <span class="title">m</span>)</span> <span class="keyword">where</span></span></span><br><span class="line">    mzero     = <span class="type">MaybeT</span> $ return <span class="type">Nothing</span></span><br><span class="line">    mplus x y = <span class="type">MaybeT</span> $ <span class="keyword">do</span> maybe_value &lt;- runMaybeT x</span><br><span class="line">                            <span class="keyword">case</span> maybe_value <span class="keyword">of</span></span><br><span class="line">                                 <span class="type">Nothing</span>    -&gt; runMaybeT y</span><br><span class="line">                                 <span class="type">Just</span> _     -&gt; return maybe_value</span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">MonadTrans</span> <span class="type">MaybeT</span> <span class="keyword">where</span></span></span><br><span class="line">    lift = <span class="type">MaybeT</span> . (liftM <span class="type">Just</span>)</span><br></pre></td></tr></table></figure>
<h2 id="改写">改写</h2><p>有了 <code>MaybeT</code> 代码可以这么写</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getValidPassphrase</span> :: <span class="type">MaybeT</span> <span class="type">IO</span> <span class="type">String</span></span><br><span class="line"><span class="title">getValidPassphrase</span> = <span class="keyword">do</span> s &lt;- lift getLine <span class="comment">-- 将 IO String 提升为 Maybe (IO String)</span></span><br><span class="line">                        guard (isValid s) <span class="comment">-- MonadPlus 类型类使我们能够使用 guard. 这里 s 为 String 类型</span></span><br><span class="line">                        return s</span><br><span class="line"></span><br><span class="line"><span class="title">askPassphrase</span> :: <span class="type">MaybeT</span> <span class="type">IO</span> ()</span><br><span class="line"><span class="title">askPassphrase</span> = <span class="keyword">do</span> lift $ putStrLn <span class="string">"输入新密码:"</span> <span class="comment">-- 将 IO () 提升为 Maybe (IO ())</span></span><br><span class="line">                   value &lt;- getValidPassphrase <span class="comment">-- value 为 String 类型</span></span><br><span class="line">                   lift $ putStrLn <span class="string">"储存中..."</span></span><br></pre></td></tr></table></figure>
<p>没有了检查的过程，因为全都藏在 <code>MaybeT</code> 的 <code>&gt;&gt;=</code> 里面了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组合两个 Monad 的 Monad&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Haskell" scheme="http://en.ors-sro.com/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Generator</title>
    <link href="http://en.ors-sro.com/ES6-Generator/"/>
    <id>http://en.ors-sro.com/ES6-Generator/</id>
    <published>2017-03-19T10:09:15.000Z</published>
    <updated>2017-03-19T10:46:01.827Z</updated>
    
    <content type="html"><![CDATA[<p>类似 C# 的 IEmulator</p>
<a id="more"></a>
<h2 id="定义">定义</h2><p>ES6 新增了 Generator ，类似于 C# 的 IEmulator 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 函数前面加 * 表示是 generator 函数</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span> <span class="comment">// yield 返回一个值</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// undefine</span></span><br></pre></td></tr></table></figure>
<p>Generator 可以是无限的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="pi">  "use strict"</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    <span class="keyword">let</span> sum = a + b</span><br><span class="line">    a = b</span><br><span class="line">    b = sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印前十个斐波那契数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = Fibonacci();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f.next().value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 1 2 3 5 8 13 21 54</span></span><br></pre></td></tr></table></figure>
<p>Generator 可以嵌套</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span>* AnotherGen()</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">AnotherGen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"a"</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"b"</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"c"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// "a"</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// "b"</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// "c"</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>Generator 可以模拟线程调度实现携程的效果，因为 Generator 可以让出控制权，达到暂停的效果。</p>
<h2 id="参考">参考</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">MDN</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类似 C# 的 IEmulator&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://en.ors-sro.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>迁移到 ES6+</title>
    <link href="http://en.ors-sro.com/Migrate-to-es6/"/>
    <id>http://en.ors-sro.com/Migrate-to-es6/</id>
    <published>2017-03-12T08:23:40.000Z</published>
    <updated>2017-03-12T08:39:23.988Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些迁移到 ES6 、ES7 的笔记，主要参考了 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a></p>
<p>新增了很多内容，这里只记录常用的。</p>
<a id="more"></a>
<h2 id="变量声明">变量声明</h2><p>ES6 新增了两个变量声明的关键词 <code>let</code> 和 <code>const</code></p>
<p><code>let</code> 用于代替 <code>var</code> 。</p>
<p><code>let</code> 不会像 <code>var</code> 那样声明为全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以也不需要 IIFE 了。因为 <code>let</code> 声明相当于块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>const</code> 用于声明只读的常量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p><a href="/Airbnb-es6-style-guide/#引用">详情</a></p>
<h2 id="解构">解构</h2><p>ES6 增加了变量解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>解构赋值很灵活</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>解构赋值可用于多值返回，参数解构等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;z: <span class="number">3</span>, y: <span class="number">2</span>, x: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2><p>字符串操作新增了很多方法，主要说几个常用的。</p>
<p><code>includes()</code> 判断是否包含特定字符串</p>
<p><code>startsWith()</code> 判断是否以特定字符串开头</p>
<p><code>endsWith()</code> 判断是否以特定字符串结尾</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p> ES6 还新增了模板字符串，用``` 包裹 。模板字符串中的空格和换行都会保留。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span><br><span class="line">string text line 2`</span>);</span><br></pre></td></tr></table></figure>
<p>还可以用作插值表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>
<h2 id="数值">数值</h2><p>ES6 新增二进制和八进制的表示法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b10000000000</span> === <span class="number">1024</span> <span class="comment">//true</span></span><br><span class="line"><span class="number">0o2000</span> === <span class="number">1024</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>还新增了一些处理数字的方法，常用的有</p>
<p><code>Number.isNan()</code> 判断是否为 <code>NaN</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span>/<span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Math.truct()</code> 截断小数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">0.1234</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'123.456'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'foo'</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p><code>Math.sign()</code> 判断正负</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(-<span class="number">5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(-<span class="number">0</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">'foo'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign();      <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>此外还新增了指数运算符 <code>**</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a ** 2 = a * a;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2><p>数组也新增了方法，常用的有</p>
<p><code>Array.from()</code> 用于将类数组转为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Array.of()</code> 将一组值转化为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>find()</code> 返回符合条件的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find((n) =&gt; n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<p><code>findIndex()</code> 返回符合条件的元素索引</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>所以以后使用 <code>indexOf</code> 时优先考虑使用 <code>includes()</code> 、<code>find()</code> 、<code>findIndex()</code> </p>
<h2 id="函数声明">函数声明</h2><p>ES6 新增了胖箭头函数用于声明 $\lambda$ 表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = v =&gt; v;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = () =&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用箭头函数还有一个好处就是不用手动绑定 <code>this</code> 。</p>
<p>ES6 新增了对参数默认值的支持</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = 'World') &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log('Hello') // Hello World</span><br><span class="line">log('Hello', 'China') // Hello China</span><br><span class="line">log('Hello', '') // Hello</span><br></pre></td></tr></table></figure>
<p>可以和解构赋值搭配使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = 5&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined, 5</span></span><br><span class="line">foo(&#123;x: <span class="number">1</span>&#125;) <span class="comment">// 1, 5</span></span><br><span class="line">foo(&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;) <span class="comment">// 1, 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure>
<p>还新增了不定参数的支持</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>新增扩展运算符，将数组化为元素序列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>
<p>可以用于合并数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>
<p>还可以搭配解构赋值使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">let</span> a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">let</span> [a, ...rest] = list</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];</span><br><span class="line">first  <span class="comment">// "foo"</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h2 id="对象">对象</h2><p>ES6 新增对象声明语法糖 <code>class</code></p>
<p>用传统的原型链声明一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>用 <code>class</code> 语法糖</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>extends</code> 来继承，使用 <code>super()</code> 调用父类函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增了一些简化表示法</p>
<p>属性简写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x: x, y: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>方法简写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/Airbnb-es6-style-guide/#对象">详情</a></p>
<h2 id="Promise">Promise</h2><p><a href="/Promise">ES6 Promise</a></p>
<h2 id="迭代">迭代</h2><p>新增了 <code>for ... of</code> 迭代，相当于其他语言的 <code>for each</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可搭配新增的 <code>entries()</code> 、<code>key()</code> 、<code>value()</code> 使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>
<h2 id="代码风格">代码风格</h2><p>两空格缩进，不添加分号。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些迁移到 ES6 、ES7 的笔记，主要参考了 &lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新增了很多内容，这里只记录常用的。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://en.ors-sro.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
