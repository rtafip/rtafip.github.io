<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拖鞋党的拖鞋摊</title>
  
  <subtitle>写一些有的没的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://en.ors-sro.com/"/>
  <updated>2018-05-20T11:40:59.437Z</updated>
  <id>http://en.ors-sro.com/</id>
  
  <author>
    <name>拖鞋党</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码札记 —— 算法复杂度</title>
    <link href="http://en.ors-sro.com/Code-notes-time-complexity/"/>
    <id>http://en.ors-sro.com/Code-notes-time-complexity/</id>
    <published>2018-05-20T11:33:32.000Z</published>
    <updated>2018-05-20T11:40:59.437Z</updated>
    
    <content type="html"><![CDATA[<p>$\Theta(n) + \Theta(n) \ne \Theta(n^2)$（蹭个热点）</p><a id="more"></a><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>衡量算法的好坏通常使用复杂度。复杂度包括空间复杂度，时间复杂度和理解复杂度（大雾）。</p><p>为什么不直接那算法执行时间来衡量算法的好坏呢？</p><p>因为烂的电脑执行一个快的算法可以比好的电脑执行一个慢的算法耗时更短。所以靠时间测量这种方法是依赖于硬件的。</p><p>当然可以在同一个电脑上执行不同的算法来对比。不过如果有一种不依赖与硬件和执行的方式去衡量算法那就更方便了。</p><p>所以聪明的科学家发明了时间复杂度极其相应记号来衡量算法的好坏。</p><h2 id="时间复杂度的计算"><a href="#时间复杂度的计算" class="headerlink" title="时间复杂度的计算"></a>时间复杂度的计算</h2><p>通常算法的时间复杂度只和他的输入规模有关。比如同样的算法，排序 10000 个数肯定比排序 10 个数慢。如果使用 $n$ 来表示输入的规模（比如排序 10000 个数，那么 $n = 10000$），快速排序的时间复杂度 $T(n)$ 可以表示为关于 $n$ 的多项式 $T(n) = \Theta(n\log(n))$ 。</p><p>那么如何计算时间复杂度呢？</p><p>一个算法的执行事件等于所有指令耗时的综合。</p><p>从高级编程语言的方面上讲，常见的指令有赋值，加减乘除的操作符，循环，函数调用等。</p><p>比如赋值指令 <code>x = 1</code> 因为具体时间与硬件平台有关，所以将这个具体时间记为一个单位时间。又因为耗时不会随着问题规模变动，是一个常数，所以表示为 $\Theta(1)$ </p><p>加减乘除等操作符耗时为 $\Theta(1)$</p><p>循环操作本质上是重复一定次数的操作，所以只需要计算一次操作的时间，乘上重复次数就可以算出总的时间。比如求和函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行了 n 次赋值操作，每次操作时间为 $\Theta(1)$，所以总耗时为 $\Theta(1) \times n = \Theta(n)$ 。</p><p>函数是一段代码的集合，所以函数执行时间等于每行代码执行时间的总和。</p><p>比如冒泡排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_sort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j;</span><br><span class="line">    <span class="keyword">var</span> n = array.length</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// n - 1 次</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>- i; j++) &#123; <span class="comment">// n - 1 - i 次</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>]) &#123; <span class="comment">// Θ(1)</span></span><br><span class="line">                <span class="keyword">var</span> temp = array[j];<span class="comment">// Θ(1)</span></span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];<span class="comment">// Θ(1)</span></span><br><span class="line">                array[j + <span class="number">1</span>] = temp;<span class="comment">// Θ(1)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以冒泡排序的时间复杂度为<br>$$<br>T(n) = (n - 1) \times (n - 1 - i) \times \Theta(1) \times 4 = \Theta(2n^2) = \Theta(n^2)<br>$$<br>然而不是每个时间复杂度都那么容易求得出来。</p><p>比如快速排序的时间复杂度为 $T(n) = 2T(n / 2) + \Theta(n)$ 。</p><p>这是一个递推式，要怎么求出递推式的解呢？</p><p>聪明的小朋友能马上想到用<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">天下无敌法</a>，但主方法是有使用条件的，如果不能使用该如何求解呢？很简单只要展开递推式，求解每一项的时间求和即可。</p><p>比如上面的快速排序递推式，</p><p>对于 $ n = 2 $ 时 $T(2) = 2T(1) + \Theta(n) = 2\Theta(n) + \Theta(n) = 3\Theta(n)$ </p><p>类似的</p><p>$T(n) = 2T(n/2) + \Theta(n) = 4T(n/4) + 3\Theta(n) = aT(1) + b\Theta(n)$</p><p>其实这是一个等比数列求和的过程。前面的项数$a = 2\log_2{n}$，后面的 $b = a/2 + 1$</p><p>因为 $T(1) = \Theta(n)$</p><p>所以 $T(n) = 2\log(n)\Theta(n) +  \log(n)\Theta(n) = 3\log(n)\Theta(n) = \Theta(n\log(n))$</p><p>其他的递推式也可以用类似的方法求解。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本来只想说一个简单的递推式求解，却控制不住自己解释了一堆……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$\Theta(n) + \Theta(n) \ne \Theta(n^2)$（蹭个热点）&lt;/p&gt;
    
    </summary>
    
      <category term="工作笔记" scheme="http://en.ors-sro.com/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="递归" scheme="http://en.ors-sro.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>代码札记 —— 事件冒泡</title>
    <link href="http://en.ors-sro.com/Code-note-event-flow/"/>
    <id>http://en.ors-sro.com/Code-note-event-flow/</id>
    <published>2018-05-13T09:31:18.000Z</published>
    <updated>2018-05-13T09:41:18.481Z</updated>
    
    <content type="html"><![CDATA[<p>开新坑啦 × 2</p><a id="more"></a><h2 id="老坑未填新坑又开"><a href="#老坑未填新坑又开" class="headerlink" title="老坑未填新坑又开"></a>老坑未填新坑又开</h2><p>关注我的朋友们应该会发现我好久都没发新文章了（其实根本没人关注）。</p><p>其实一直都在写新文章只是觉得完成度不够高所以没发出来。</p><p>最近一段时间发现在工作中写代码到时候会遇到一些问题，有些是开放性的，需要深入研究来决定是否使用某个技术。有些是稍微了解但没有深入探究的功能。</p><p>所以需要编写文章来记录学习的过程。</p><p>所以又开新坑啦！新坑就是每周写一些工作上有关代码的问题，字数通常较少（偷懒的借口）。</p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>今天的话题是代码中事件冒泡机制。</p><p>ActionScript （是的我还在用这个过气的语言）和 JavaScript 一样也有类似的事件冒泡机制。</p><p>之前有大概了解过冒泡的机制，就是从当前显示对象一层层的像父层级传递事件，像是海底中气泡往上冒的过程，所以称为事件冒泡。</p><p><a href="https://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7e4f.html" target="_blank" rel="noopener">Adobe 的事件流程</a>提到事件流程有三个阶段：捕获阶段，目标阶段，冒泡阶段。</p><p>捕获阶段：从舞台 <code>stage</code> 的事件传递到父节点，再传递到子节点触发事件对象的阶段</p><p>目标阶段：当前对象为触发事件对象的阶段</p><p>冒泡阶段：从触发事件对象阶段，传递到子节点，再传递至到 <code>stage</code> 的阶段。</p><p>流程图为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">             +-----------+</span><br><span class="line">         +   |   stage   |   ^</span><br><span class="line">         |   +-----+-----+   |</span><br><span class="line">         |         |         |</span><br><span class="line">         |         |         |</span><br><span class="line">         |         v         |</span><br><span class="line">         |   +-----+-----+   |</span><br><span class="line">Capture  |   |   Parent  |   |  Bubble</span><br><span class="line">Phase    |   +-----+-----+   |  Phase</span><br><span class="line">         |         |         |</span><br><span class="line">         |         |         |</span><br><span class="line">         |         v         |</span><br><span class="line">         |   +-----+-----+   |</span><br><span class="line">         |   |   Child   |   |</span><br><span class="line">         v   +-----------+   +</span><br><span class="line"></span><br><span class="line">                 Target</span><br><span class="line">                 Phase</span><br></pre></td></tr></table></figure><p>那这样如果在父层级加事件就会触发两次吗？</p><p>如果按照默认添加事件的方式只会在冒泡阶段触发一次。</p><p>因为添加事件的函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addEventListener</span>(<span class="params"><span class="keyword">type</span>:<span class="built_in">String</span>, listener:<span class="built_in">Function</span>, useCapture:<span class="built_in">Boolean</span> = <span class="literal">false</span>, priority:int = 0, useWeakReference:<span class="built_in">Boolean</span> = <span class="literal">false</span></span>):<span class="title">void</span></span></span><br></pre></td></tr></table></figure><p>中的第三个参数 <code>useCapture</code> 默认为 false 。 也就是不在捕获阶段触发，如果设置为 true 也就是会在捕获阶段触发。</p><p>而创建事件的时候</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Event</span>(<span class="params"><span class="keyword">type</span>:<span class="built_in">String</span>, bubbles:<span class="built_in">Boolean</span> = <span class="literal">false</span>, cancelable:<span class="built_in">Boolean</span> = <span class="literal">false</span></span>)</span></span><br></pre></td></tr></table></figure><p>事件构造函数中的第二个参数 <code>bubbles</code> 默认为 false，也就是事件不冒泡。</p><p>所以通常按默认加事件的方式，父节点是不会触发事件处理函数的。</p><p>还好可以在父节点中监听子节点的事件</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(EVENT_NAME, handler);</span><br></pre></td></tr></table></figure><p>如果需要事件冒泡，需要将 <code>bubbles</code> 设置为 true 。不过通常这个需求都可以通过在父节点的类中监听子节点事件来达成。</p><p>除了用事件还可以用回调的方式来实现。不过相比使用回调，事件的有比较明显的有点。事件处理方式灵活（归功于事件流程），一个事件可以有多个监听，而回调就没那么容易做到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开新坑啦 × 2&lt;/p&gt;
    
    </summary>
    
      <category term="工作笔记" scheme="http://en.ors-sro.com/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="事件" scheme="http://en.ors-sro.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>右值引用和通用引用</title>
    <link href="http://en.ors-sro.com/Right-value-reference-and-Universal-reference/"/>
    <id>http://en.ors-sro.com/Right-value-reference-and-Universal-reference/</id>
    <published>2017-09-24T09:24:35.000Z</published>
    <updated>2017-09-24T09:33:16.524Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 一到店，所有人都便都看着他笑……「对呀对呀！……引用有四种写法，你知道么？」</p><a id="more"></a><h2 id="没有引用"><a href="#没有引用" class="headerlink" title="没有引用"></a>没有引用</h2><p>编程初学者写一个交换函数，很可能是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这样是不起作用的。有些人会从汇编的角度分析，有些人会从调用方式的角度分析。</p><p>最后修正后的 C 语言版本使用了指针。（使用宏的都拖出去续了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = *x;</span><br><span class="line">  *x = *y;</span><br><span class="line">  *y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为不恰当的使用指针很容易造成空指针的问题。所以 C++ 引入了引用。</p><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>C++ 使用引用版本的交换函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用本质上是自动解引用的指针。所以这段代码跟指针的版本原理差不多。</p><p>这时候的 C++ 还是守序善良。短短几年过去却变成了混乱邪恶的 C++ 11 。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>C++ 11 引入了右值引用，用 <code>&amp;&amp;</code> 表示，对应的之前的引用称为左值引用，用 <code>&amp;</code> 表示。使用右值引用的交换函数版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp;&amp; x, <span class="keyword">int</span>&amp;&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而内置类型并没有移动构造函数，所以移动退化为复制。C++ 11 之前都是拷贝交换，C++ 11 引入右值引用后才实现了真正上的移动交换。如果使用自定义类区别就会明显一些。</p><h2 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h2><p>通用的移动交换函数应该是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; x, T&amp; y)</span> </span>&#123;</span><br><span class="line">    T temp = <span class="built_in">std</span>::move(x);</span><br><span class="line">    x = <span class="built_in">std</span>::move(y);</span><br><span class="line">    y = <span class="built_in">std</span>::move(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code> 可以是 <code>int</code>  、<code>int &amp;</code>  和 <code>int &amp;&amp;</code> 等等，代入后可能特化为以下版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; &amp;x, <span class="keyword">int</span>&amp; &amp; y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp;&amp; &amp;x, <span class="keyword">int</span>&amp;&amp; &amp;y)</span></span>;</span><br></pre></td></tr></table></figure><p>这样就出现了两个问题。</p><p>本来只有左值引用的时候模板函数只需要一两个特化版本。现在引入右值引用后还要写一个版本。</p><p>第二个问题是 <code>int&amp;&amp; &amp;</code> 是什么类型？</p><p>为了解决第一个问题，C++ 11 引入了通用引用，用 <code>&amp;&amp;</code> 表示。使用通用引用的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp;&amp; x, T&amp;&amp; y)</span> </span>&#123;</span><br><span class="line">    T temp = <span class="built_in">std</span>::move(x);</span><br><span class="line">    x = <span class="built_in">std</span>::move(y);</span><br><span class="line">    y = <span class="built_in">std</span>::move(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题又来了。通用引用（<code>&amp;&amp;</code>）和右值引用（<code>&amp;&amp;</code>）是一样的吗？</p><p>答案是不一样的。那要怎么区分呢？</p><p>第二个问题的回答刚好解决了这个新问题。</p><p>实际上 C++ 是不允许创建引用的引用的。所以右值引用才可以用 &amp;&amp; 表示，不然到底是左值引用的左值引用还是单纯的右值引用？</p><p>但在 C++ 中还是有办法绕过限制，比如上面使用模板的方法来实现 <code>int&amp; &amp;</code> 的效果。</p><p>创建引用的引用是没有意义的，直接使用引用即可。所以有以下规约</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; &amp; -&gt; &amp;</span><br><span class="line">&amp;&amp; &amp; -&gt; &amp;&amp;</span><br><span class="line">&amp; &amp;&amp; -&gt; &amp;</span><br><span class="line">&amp;&amp; &amp;&amp; -&gt; &amp;&amp;</span><br></pre></td></tr></table></figure><p>其中 <code>&amp; &amp;&amp; -&gt; &amp;</code> 和 <code>&amp;&amp; &amp;&amp; -&gt; &amp;&amp;</code> 都不会改变原有引用的左右性，所以参数声明为 <code>&amp;&amp;</code> 就表示，如果是左值引用，那么传进来还是左值引用。如果是右值引用，那么传进来还是右值引用。</p><p>因此 Scott Meyers 把 <code>&amp;&amp;</code> 命名为通用引用。</p><p>相应地模板只需要写一个 <code>T&amp;&amp;</code> 的特化版就可以了，这样的特性被称为完璧转发。</p><p>从规约上看，具体的类型如 <code>int&amp;&amp;</code> 就是右值引用，通用的类型 <code>T&amp;&amp;</code> 则是通用引用，左右性需要看传入参数的左右性。</p><h2 id="文章引用"><a href="#文章引用" class="headerlink" title="文章引用"></a>文章引用</h2><p><a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers" target="_blank" rel="noopener">通用引用的定义</a></p><p><a href="https://stackoverflow.com/questions/20364297/why-universal-references-have-the-same-syntax-as-rvalue-references" target="_blank" rel="noopener">右值引用和通用引用的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 一到店，所有人都便都看着他笑……「对呀对呀！……引用有四种写法，你知道么？」&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>APL</title>
    <link href="http://en.ors-sro.com/APL/"/>
    <id>http://en.ors-sro.com/APL/</id>
    <published>2017-08-27T09:00:48.000Z</published>
    <updated>2017-09-03T07:58:50.331Z</updated>
    
    <content type="html"><![CDATA[<p>不撸兔子</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>APL （A Programming Language 或者 APL Programming Language）是 Kenneth E. Iverson 于 1960 左右发明的一门基于数组的编程语言。紧凑而特殊的数学符号是它最鲜明的特点。</p><h2 id="简单的程序"><a href="#简单的程序" class="headerlink" title="简单的程序"></a>简单的程序</h2><p>APL 的 Hello world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;Hello, world&apos;</span><br></pre></td></tr></table></figure><p>诶看起来好简单。因为 APL 是一个解释型语言。所以不用打印函数也是可以得。</p><p>那么再看一下比较简单的 APL 程序。下面是一个选择六个随机数的程序。</p><p>$x[⍋x←6?40]$</p><p>等会怎么变成数学公式了。因为 APL 大部分符号都是数学符号，所以用数学公式的方式显示比较自然。</p><p>如果熟悉了其中符号的含义，就能很轻松的理解了。</p><p>从右到左</p><p>$]$ 搭配左边的 $[$ 相当于数组下表访问符。</p><p>$?$ 是随机函数。$6?40$ 表示使用不放回的方式从 $[1,40] $ 抽取 6 次。</p><p>$←$ 赋值符号</p><p>$x$ 变量，可以是 $a$ , $b$ , $suibian$ 等。</p><p>$⍋$ 递增排序，返回下标。$⍋$ 7 5 6 8  的结果是 2 3 1 4 。最小的数是 5 ，对应的下标是 2 （下标从 1 开始不是 0 ）</p><p>所以程序是这样运行的。</p><p>$6?40$ 随机结果为 34 3 6 36 26 20</p><p>$x←6?40$ ，x 为 34 3 6 36 26 20</p><p>$⍋x$  递增排序，返回下标 2 3 6 5 1 4</p><p>x[2 3 6 5 1 4] 结果为 3 6 20 26 34 36</p><p>果然是很简单的程序呢。</p><h2 id="Primitive"><a href="#Primitive" class="headerlink" title="Primitive"></a>Primitive</h2><h3 id="一元形式"><a href="#一元形式" class="headerlink" title="一元形式"></a>一元形式</h3><table><thead><tr><th>Name(s)</th><th>Notation</th><th>Meaning</th><th>Unicode codepoint</th></tr></thead><tbody><tr><td>Roll</td><td><code>?B</code></td><td>从 $[1,B]$ 中随机一个数</td><td>U+003F ?</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions" target="_blank" rel="noopener">Ceiling</a></td><td><code>⌈B</code></td><td>大于等于 B 的最小整数</td><td>U+2308 ⌈</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions" target="_blank" rel="noopener">Floor</a></td><td><code>⌊B</code></td><td>小于等于 B 的最大整数</td><td>U+230A ⌊</td></tr><tr><td>Shape, <a href="https://en.wikipedia.org/wiki/Rho" target="_blank" rel="noopener">Rho</a></td><td><code>⍴B</code></td><td>B 的组件每个维度的数量</td><td>U+2374 ⍴</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Negation" target="_blank" rel="noopener">Not</a>, <a href="https://en.wikipedia.org/wiki/Tilde" target="_blank" rel="noopener">Tilde</a></td><td><code>∼B</code></td><td>∼1 为 0, ∼0 为 1</td><td>U+223C ∼</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Absolute_value" target="_blank" rel="noopener">Absolute value</a></td><td><code>∣B</code></td><td>B 的模</td><td>U+2223 ∣</td></tr><tr><td>Index generator, <a href="https://en.wikipedia.org/wiki/Iota" target="_blank" rel="noopener">Iota</a></td><td><code>⍳B</code></td><td>产生从1 到 B 的序列</td><td>U+2373 ⍳</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Exponentiation" target="_blank" rel="noopener">Exponential</a></td><td><code>⋆B</code></td><td>$e^B$</td><td>U+22C6 ⋆</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Negation" target="_blank" rel="noopener">Negation</a></td><td><code>−B</code></td><td>B 的相反数</td><td>U+2212 −</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Identity_function" target="_blank" rel="noopener">Identity</a></td><td><code>+B</code></td><td>返回 B</td><td>U+002B +</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Sign_function" target="_blank" rel="noopener">Signum</a></td><td><code>×B</code></td><td>返回 B 的符号。小于 0 返回¯1， 等于 0 返回 0 ，大于0 返回 1</td><td>U+00D7 ×</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Multiplicative_inverse" target="_blank" rel="noopener">Reciprocal</a></td><td><code>÷B</code></td><td>$1/B$</td><td>U+00F7 ÷</td></tr><tr><td>Ravel, Catenate, Laminate</td><td><code>,B</code></td><td>重塑 B 为向量</td><td>U+002C ,</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Matrix_inverse" target="_blank" rel="noopener">Matrix inverse</a>, Monadic Quad Divide</td><td><code>⌹B</code></td><td>矩阵 B 的逆</td><td>U+2339 ⌹</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Pi" target="_blank" rel="noopener">Pi</a> times</td><td><code>○B</code></td><td>$B \times \pi$</td><td>U+25CB ○</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Logarithm" target="_blank" rel="noopener">Logarithm</a></td><td><code>⍟B</code></td><td>$\ln B$</td><td>U+235F ⍟</td></tr><tr><td>Reversal</td><td><code>⌽B</code></td><td>沿着最后一个数轴反转 B 的元素</td><td>U+233D ⌽</td></tr><tr><td>Reversal</td><td><code>⊖B</code></td><td>沿着第一个数轴反转 B 的元素</td><td>U+2296 ⊖</td></tr><tr><td>Grade up</td><td><code>⍋B</code></td><td>返回升序排序 B 后元素下标</td><td>U+234B ⍋</td></tr><tr><td>Grade down</td><td><code>⍒B</code></td><td>返回降序排序 B 后元素下表</td><td>U+2352 ⍒</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Eval" target="_blank" rel="noopener">Execute</a></td><td><code>⍎B</code></td><td>执行一个 APL 表达式</td><td>U+234E ⍎</td></tr><tr><td>Monadic format</td><td><code>⍕B</code></td><td>最简化 B</td><td>U+2355 ⍕</td></tr><tr><td>Monadic <a href="https://en.wikipedia.org/wiki/Transpose" target="_blank" rel="noopener">transpose</a></td><td><code>⍉B</code></td><td>转置矩阵 B</td><td>U+2349 ⍉</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Factorial" target="_blank" rel="noopener">Factorial</a></td><td><code>!B</code></td><td>B! 从 1 乘到 B</td><td>U+0021 !</td></tr></tbody></table><h3 id="二元形式"><a href="#二元形式" class="headerlink" title="二元形式"></a>二元形式</h3><table><thead><tr><th>Name(s)</th><th>Notation</th><th>Meaning</th><th>Unicodecodepoint</th></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/wiki/Addition" target="_blank" rel="noopener">Add</a></td><td><code>A+B</code></td><td>A 加 B</td><td>U+002B +</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Subtraction" target="_blank" rel="noopener">Subtract</a></td><td><code>A−B</code></td><td>A 减 B</td><td>U+2212 −</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Multiply" target="_blank" rel="noopener">Multiply</a></td><td><code>A×B</code></td><td>A 乘以 B</td><td>U+00D7 ×</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Division_(mathematics" target="_blank" rel="noopener">Divide</a>)</td><td><code>A÷B</code></td><td>A 除以 B</td><td>U+00F7 ÷</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Exponentiation" target="_blank" rel="noopener">Exponentiation</a></td><td><code>A⋆B</code></td><td>A 的 B 次方</td><td>U+22C6 ⋆</td></tr><tr><td>Circle</td><td><code>A○B</code></td><td>A = 1: $\sin(B)$  A = 2: $\cos(B)$ A = 3: $\tan(B)$ A=5: $\sinh(B)$ A = 6: $\cosh(B)$ A = 7: $\tanh(B)$</td><td>U+25CB ○</td></tr><tr><td>Deal</td><td><code>A?B</code></td><td>不放回从 $[1,B]$ 抽取 A 次</td><td>U+003F ?</td></tr><tr><td>Membership, Epsilon</td><td><code>A∈B</code></td><td>返回 1 ，如果 A 在 B 中，否则返回 0</td><td>U+2208 ∈</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Sample_maximum_and_minimum" target="_blank" rel="noopener">Maximum</a>, Ceiling</td><td><code>A⌈B</code></td><td>返回 A 和 B 中最大的一个</td><td>U+2308 ⌈</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Sample_maximum_and_minimum" target="_blank" rel="noopener">Minimum</a>, Floor</td><td><code>A⌊B</code></td><td>返回 A 和 B 中最小的一个</td><td>U+230A ⌊</td></tr><tr><td>Reshape, Dyadic <a href="https://en.wikipedia.org/wiki/Rho" target="_blank" rel="noopener">Rho</a></td><td><code>A⍴B</code></td><td>A 型数组，B 为数据。</td><td>U+2374 ⍴</td></tr><tr><td>Take</td><td><code>A↑B</code></td><td>根据 ×A 选择 B 中前（或后）A 个元素</td><td>U+2191 ↑</td></tr><tr><td>Drop</td><td><code>A↓B</code></td><td>根据 ×A 丢弃 B 中前（或后）A 个元素</td><td>U+2193 ↓</td></tr><tr><td>Decode</td><td><code>A⊥B</code></td><td>Value of a polynomial whose coefficients are <em>B</em> at <em>A</em></td><td>U+22A5 ⊥</td></tr><tr><td>Encode</td><td><code>A⊤B</code></td><td>Base-<em>A</em> representation of the value of <em>B</em></td><td>U+22A4 ⊤</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Modulo_operation" target="_blank" rel="noopener">Residue</a></td><td><code>A∣B</code></td><td>B 模 A</td><td>U+2223 ∣</td></tr><tr><td>Catenation</td><td><code>A,B</code></td><td>B 拼接 A</td><td>U+002C ,</td></tr><tr><td>Expansion, Dyadic Backslash</td><td><code>A\B</code></td><td>根据 A 中 0 的位置在 B 中插入 0 （或空格）</td><td>U+005C \</td></tr><tr><td>Compression, Dyadic Slash</td><td><code>A/B</code></td><td>根据 A 中 1 的位置在 B 中选择元素</td><td>U+002F /</td></tr><tr><td>Index of, Dyadic <a href="https://en.wikipedia.org/wiki/Iota" target="_blank" rel="noopener">Iota</a></td><td><code>A⍳B</code></td><td>A 在 B 中的下标。如果不在返回 <code>1+⍴A</code></td><td>U+2373 ⍳</td></tr><tr><td>Matrix divide, Dyadic Quad Divide</td><td><code>A⌹B</code></td><td>矩阵除法</td><td>U+2339 ⌹</td></tr><tr><td>Rotation</td><td><code>A⌽B</code></td><td>The elements of <em>B</em> are rotated <em>A</em> positions</td><td>U+233D ⌽</td></tr><tr><td>Rotation</td><td><code>A⊖B</code></td><td>The elements of <em>B</em> are rotated <em>A</em> positions along the first axis</td><td>U+2296 ⊖</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Logarithm" target="_blank" rel="noopener">Logarithm</a></td><td><code>A⍟B</code></td><td>$\log_{A}{B}$</td><td>U+235F ⍟</td></tr><tr><td>Dyadic format</td><td><code>A⍕B</code></td><td>Format <em>B</em> into a character matrix according to <em>A</em></td><td>U+2355 ⍕</td></tr><tr><td>General transpose</td><td><code>A⍉B</code></td><td>The axes of <em>B</em> are ordered by <em>A</em></td><td>U+2349 ⍉</td></tr><tr><td>Combinations</td><td><code>A!B</code></td><td>二项式$C^{a}_{b}$</td><td>U+0021 !</td></tr><tr><td>Diaeresis, Dieresis, Double-Dot</td><td><code>A¨B</code></td><td>Over each, or perform each separately; <em>B</em> = on these; <em>A</em> = operation to perform or using(e.g. iota)</td><td>U+00A8 ¨</td></tr><tr><td>Less than</td><td><code>A&lt;B</code></td><td>小于返回 1 ，否则返回 0</td><td>U+003C &lt;</td></tr><tr><td>Less than or equal</td><td><code>A≤B</code></td><td>小于等于返回 1，否则返回 0</td><td>U+2264 ≤</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Equality_(mathematics" target="_blank" rel="noopener">Equal</a>)</td><td><code>A=B</code></td><td>等于返回 1 ，否则返回 0</td><td>U+003D =</td></tr><tr><td>Greater than or equal</td><td><code>A≥B</code></td><td>大于等于返回 1，否则返回 0</td><td>U+2265 ≥</td></tr><tr><td>Greater than</td><td><code>A&gt;B</code></td><td>大于返回 1 ，否则返回 0</td><td>U+003E &gt;</td></tr><tr><td>Not equal</td><td><code>A≠B</code></td><td>不等于返回 1 ，否则返回 0</td><td>U+2260 ≠</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Logical_disjunction" target="_blank" rel="noopener">Or</a></td><td><code>A∨B</code></td><td>二进制或，A 和 B 都为 0 时返回 0 。否则返回 1</td><td>U+2228 ∨</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Logical_conjunction" target="_blank" rel="noopener">And</a></td><td><code>A∧B</code></td><td>二进制与，A 和 B 都为 1 时返回 1 。否则返回 0</td><td>U+2227 ∧</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Logical_NOR" target="_blank" rel="noopener">Nor</a></td><td><code>A⍱B</code></td><td>二进制或非。</td><td>U+2371 ⍱</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Sheffer_stroke" target="_blank" rel="noopener">Nand</a></td><td><code>A⍲B</code></td><td>二进制与非</td><td>U+2372 ⍲</td></tr></tbody></table><p>更多例子参考<a href="https://en.wikipedia.org/wiki/APL_syntax_and_symbols" target="_blank" rel="noopener">维基</a>。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>生命游戏</p><p>$life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}$</p><p>字数排序</p><p>$X[⍋X+.≠’ ‘;]$</p><p>移除 HTML 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt←&apos;&lt;html&gt;&lt;body&gt;&lt;p&gt;This is &lt;em&gt;emphasized&lt;/em&gt; text.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&apos;</span><br><span class="line">⎕←&#123;⍵/⍨~&#123;⍵∨≠\⍵&#125;⍵∊&apos;&lt;&gt;&apos;&#125;txt</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>APL 的奇怪符号可以通过专用键盘输入。如果你不喜欢这种奇怪的符号，那么……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不撸兔子&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APL" scheme="http://en.ors-sro.com/tags/APL/"/>
    
  </entry>
  
  <entry>
    <title>C++ 头文件解耦</title>
    <link href="http://en.ors-sro.com/C-header-issues/"/>
    <id>http://en.ors-sro.com/C-header-issues/</id>
    <published>2017-08-20T08:31:52.000Z</published>
    <updated>2017-09-10T07:48:13.908Z</updated>
    
    <content type="html"><![CDATA[<p>令人头疼的糟粕</p><a id="more"></a><h2 id="It-sucks！"><a href="#It-sucks！" class="headerlink" title="It sucks！"></a>It sucks！</h2><p>写过 C++ 的人一定会被编译速度恶心到。一方面是因为 C++ 有很多零负担抽象，选择运行速度，那只能牺牲编译速度。</p><p>另一方面是因为随便动一个文件就要编译整个工程！</p><h2 id="万恶的头文件"><a href="#万恶的头文件" class="headerlink" title="万恶的头文件"></a>万恶的头文件</h2><p>一切都得从 C 语言开始说起。</p><p>C 语言不支持调用未声明的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是要被编译器踢屁股的。（如果编译器过了证明编译器没有严格遵循标准，换你踢编译器屁股啦）</p><p>除非前置声明函数类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 前置函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个文件通常有很多函数，所以就会有很多前置函数声明。</p><p>于是头文件就诞生了。</p><p>头文件放函数声明，.c 文件放实现。岂不美哉？</p><p>现实往往没有那么简单。通常为了使用外部的数据结构或者函数，需要引用其他头文件。</p><p>一个引用一个，形成了引用链。</p><p>一条链接一条，形成了引用网。</p><p>一改动，一编译，BOOM！</p><h2 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h2><p>那要怎么解决这个问题呢？</p><p>基本的原则有好几条。比如引用其他头文件时，在 .c 文件中引用，而不是头文件引用。</p><p>这样别人引用你的头文件的时候就不会引入大量的头文件。</p><p>当然因为 C++ 的缺陷，这条规则并不是每次都能做到。</p><p>比如头文件函数声明中引用了外部的数据结构，这时候如果只在 .c 文件引用头文件，显然引用了外部数据结构的头文件因为没有办法知道外部数据结构类型就会编译失败。</p><p>还有一种比较恶心的情况是函数声明引用了本头文件内的数据结构，数据结构在声明后面。</p><p>这时候就只有两种选择。一种是将整个数据结构的定义前移。另一种是前置声明数据结构，相应地使用的地方全部改成指针类型。（干，为什么不能用引用，明明引用也是一种指针啊。只不过是自动解引用而已。）实际上现代编程语言都不会有这种问题。</p><p>其实还有一种办法，那就是把整个数据结构的定义放到新的头文件里面。（恭喜你，又多了一个头文件，复杂度指数级爆炸。）</p><p>最重要的原则还是声明和实现分离。最主要的是数据结构的声明和实现分离。（对，不要再把数据结构的定义放在头文件里。）具体参考<a href="https://wizardforcel.gitbooks.io/effective-cpp/content/33.html" target="_blank" rel="noopener">《Effective C++》 第 31 条最小化文件之间的编译依赖</a>（本质上就是利用类型系统的弱点通过指针退化来实现多态。）</p><h2 id="回到未来"><a href="#回到未来" class="headerlink" title="回到未来"></a>回到未来</h2><p>以上的方法都是治标不治本。如果想要根治，就必须废弃 C++ 的头文件引用机制。转而使用现代化的模块机制。不过这个提案又鸽了。如果你有幸使用宇宙第一<sub>卡</sub>的 IDE —— Visual Studio 2017 ，又不用跨平台编译，那么<a href="https://blogs.msdn.microsoft.com/vcblog/2017/05/05/cpp-modules-in-visual-studio-2017/" target="_blank" rel="noopener">欢迎回到未来</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;令人头疼的糟粕&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="C++" scheme="http://en.ors-sro.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>什么鬼 JS</title>
    <link href="http://en.ors-sro.com/What-the-fuck-JS/"/>
    <id>http://en.ors-sro.com/What-the-fuck-JS/</id>
    <published>2017-08-13T10:00:05.000Z</published>
    <updated>2017-09-17T06:55:23.647Z</updated>
    
    <content type="html"><![CDATA[<p>第二季</p><a id="more"></a><h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><p>在<a href="/Learn-some-Javascript/#与_C_语法类似">学一些 JS </a>里面就有提到过 <a href="http://javascript-puzzlers.herokuapp.com/" target="_blank" rel="noopener">JS 的常见问题</a> [滑稽]。最近又看到了类似的总结。前戏到此为止，马上进入吧。</p><h2 id="true-等于-false"><a href="#true-等于-false" class="headerlink" title="true 等于 false"></a>true 等于 false</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><p><code>[]</code> 是 JavaScript 里面的数组（Array）。也就是数组不等于数组！</p><p>要想知道为什么，当然是看语言规范啦！（不要再吭哧吭哧地扣汇编代码）</p><p>因为非运算符 <code>!</code> 比相等判别运算符<code>==</code> 的优先级高，所以先看<a href="https://www.ecma-international.org/ecma-262/#sec-logical-not-operator" target="_blank" rel="noopener">非运算符的规范</a></p><blockquote><p>12.5.9Logical NOT Operator (!)</p><p>12.5.9.1Runtime Semantics: Evaluation</p><ol><li>Let expr be the result of evaluating <a href="https://www.ecma-international.org/ecma-262/#prod-UnaryExpression" target="_blank" rel="noopener">UnaryExpression</a>.</li><li>Let oldValue be <a href="https://www.ecma-international.org/ecma-262/#sec-toboolean" target="_blank" rel="noopener">ToBoolean</a>(? <a href="https://www.ecma-international.org/ecma-262/#sec-getvalue" target="_blank" rel="noopener">GetValue</a>(expr)).</li><li>If oldValue is <strong>true</strong>, return <strong>false</strong>.</li><li>Return <strong>true</strong>.</li></ol></blockquote><p>其中最关键的一步是第二条的 <code>ToBoolean(![])</code> 。再看 <code>ToBoolean</code> 的规范。</p><blockquote><p>7.1.2ToBoolean ( argument ) </p><p>The abstract operation ToBoolean converts argument to a value of type Boolean according to <a href="https://www.ecma-international.org/ecma-262/#table-10" target="_blank" rel="noopener">Table 9</a>:</p><table><thead><tr><th>Argument Type</th><th>Result</th></tr></thead><tbody><tr><td>Undefined</td><td>Return false.</td></tr><tr><td>Null</td><td>Return false.</td></tr><tr><td>Boolean</td><td>Return argument.</td></tr><tr><td>Number</td><td>If argument is +0, -0, or NaN, return false; otherwise return true.</td></tr><tr><td>String</td><td>If argument is the empty String (its length is zero), return false; otherwise return true.</td></tr><tr><td>Symbol</td><td>Return true.</td></tr><tr><td>Object</td><td>Return true.</td></tr></tbody></table></blockquote><p><code>[]</code> 虽然是数组，但是 <code>typeof []</code> 是 Object 。所以查表 <code>![]</code> 的结果为 <code>true</code> 。</p><p>结果转化为 <code>[] == true</code> 。</p><p>再看 <code>==</code> <a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" target="_blank" rel="noopener">相等判别运算符</a>的规范</p><blockquote><p>7.2.13Abstract Equality Comparison</p><p>The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:</p><ol><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(x) is the same as <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(y), thenReturn the result of performing <a href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison" target="_blank" rel="noopener">Strict Equality Comparison</a> x === y.<ol><li>Return the result of performing <a href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison" target="_blank" rel="noopener">Strict Equality Comparison</a> x === y.</li></ol></li><li>If x is <strong>null</strong> and y is <strong>undefined</strong>, return <strong>true</strong>.</li><li>If x is <strong>undefined</strong> and y is <strong>null</strong>, return <strong>true</strong>.</li><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(x) is Number and <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(y) is String, return the result of the comparison x == <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber" target="_blank" rel="noopener">ToNumber</a>(y).</li><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(x) is String and <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(y) is Number, return the result of the comparison <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber" target="_blank" rel="noopener">ToNumber</a>(x) == y.</li><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(x) is Boolean, return the result of the comparison <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber" target="_blank" rel="noopener">ToNumber</a>(x) == y.</li><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(y) is Boolean, return the result of the comparison x == <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber" target="_blank" rel="noopener">ToNumber</a>(y).</li><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(x) is either String, Number, or Symbol and <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(y) is Object, return the result of the comparison x == <a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive" target="_blank" rel="noopener">ToPrimitive</a>(y).</li><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(x) is Object and <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(y) is either String, Number, or Symbol, return the result of the comparison <a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive" target="_blank" rel="noopener">ToPrimitive</a>(x) == y.</li><li>Return <strong>false</strong>.</li></ol></blockquote><p>显然 <code>[] == true</code> 对应的是第 7 条。</p><p>再看 ToNumber 的规范</p><blockquote><p>7.1.3ToNumber ( argument )</p><p>The abstract operation ToNumber converts argument to a value of type Number according to <a href="https://www.ecma-international.org/ecma-262/#table-11" target="_blank" rel="noopener">Table 10</a>:</p><table><thead><tr><th>Argument Type</th><th>Result</th></tr></thead><tbody><tr><td>Undefined</td><td>Return NaN.</td></tr><tr><td>Null</td><td>Return +0.</td></tr><tr><td>Boolean</td><td>If argument is true, return 1. If argument is false, return +0.</td></tr><tr><td>Number</td><td>Return argument (no conversion).</td></tr><tr><td>String</td><td>See grammar and conversion algorithm below.</td></tr><tr><td>Symbol</td><td>Throw a TypeError exception.</td></tr><tr><td>Object</td><td>Apply the following steps:Let primValue be ? <a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive" target="_blank" rel="noopener">ToPrimitive</a>(argument, hint Number).Return ? <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber" target="_blank" rel="noopener">ToNumber</a>(primValue).</td></tr></tbody></table></blockquote><p><code>true</code> 的类型是 Boolean ， 所以结果是 1 。</p><p>结果又转化为 <code>[] == 1</code></p><p>在看相等判断运算符的规范，这时候符合第九条。 要运算 <code>ToPrimitive([]) == 1</code></p><p>查看 ToPrimitive 的规范即可。这里有个偷懒的办法。因为 <code>ToBoolean([]) == true</code> 。</p><p>所以 <code>true == 1</code> 的结果是 <code>true</code> 。</p><h2 id="baNaNa"><a href="#baNaNa" class="headerlink" title="baNaNa"></a>baNaNa</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'b'</span> + <span class="string">'a'</span> + + <span class="string">'a'</span> + <span class="string">'a'</span> <span class="comment">// =&gt; baNaNa</span></span><br></pre></td></tr></table></figure><p>这里其实耍了个花招，实际上是这样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'b'</span> + <span class="string">'a'</span> + (+ <span class="string">'a'</span>) + <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p>因为 <code>+&#39;a&#39;</code> 是 <code>NaN</code> 。所以整个式子的结果就是 baNaNa 。</p><h2 id="NaN-不是-NaN"><a href="#NaN-不是-NaN" class="headerlink" title="NaN 不是 NaN"></a>NaN 不是 NaN</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure><p>这个看严格判等运算符 <code>===</code> 的<a href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison" target="_blank" rel="noopener">规范</a>就能很容易得到答案</p><blockquote><p>7.2.14Strict Equality Comparison</p><p>The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:</p><ol><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(x) is different from <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(y), return false.</li><li>If <a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(x) is Number, then<ol><li>If x is NaN, return false.</li><li>If y is NaN, return false.</li><li>If x is the same Number value as y, return true.</li><li>If x is +0 and y is -0, return true.</li><li>If x is -0 and y is +0, return true.</li><li>Return false.</li></ol></li><li>Return <a href="https://www.ecma-international.org/ecma-262/#sec-samevaluenonnumber" target="_blank" rel="noopener">SameValueNonNumber</a>(x, y).</li></ol></blockquote><p>所以根据 2.1 ，结果是 <code>false</code> 。</p><p>因为 IEEE 是这样定义 <code>NaN</code></p><blockquote><p>四种互斥的关系是：小于，等于，大于以及无序。最后一种情况出现在至少有一个操作符为 NaN 的情况。NaN 与所有相比的结果都应该是无序，包括自身。</p><p>— <a href="https://stackoverflow.com/questions/1565164/1573715#1573715" target="_blank" rel="noopener">“What is the rationale for all comparisons returning false for IEEE754 NaN values?”</a> at StackOverflow </p></blockquote><p>##NaN 是 number</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>            <span class="comment">// -&gt; 'number'</span></span><br></pre></td></tr></table></figure><p>这样看似不合理。实际上，稍微思考一下就觉得是非常自然的。</p><p>比如有一个除法函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">x, y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x / y <span class="comment">// 返回的类型是什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>div</code> 的返回类型当然是 <code>number</code> 。所以当 <code>div(0, 0)</code> 产生结果为 <code>NaN</code> 时，如果 <code>NaN</code> 不是 <code>number</code> 类型就比较难办了。</p><p>参考 typeof 运算符<a href="https://www.ecma-international.org/ecma-262/#sec-typeof-operator" target="_blank" rel="noopener">规范</a></p><h2 id="最小值大于零"><a href="#最小值大于零" class="headerlink" title="最小值大于零"></a>最小值大于零</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MIN_VALUE &gt; <span class="number">0</span> <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><p>因为 <code>Number.MIN_VALUE</code> 的值为 5e-324，也就是 $5 \times 10^{-324}$ ，所以当然是大于 0 的啊。</p><p>这里的最小值想要表达的是浮点数的最小精度。</p><h2 id="HTML-注释在-JS-是合法的"><a href="#HTML-注释在-JS-是合法的" class="headerlink" title="HTML 注释在 JS 是合法的"></a>HTML 注释在 JS 是合法的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valid comment</span></span><br><span class="line">&lt;!-- valid comment too --&gt;</span><br></pre></td></tr></table></figure><p>没想到吧！JS 中也可以使用 HTML 式的注释方式。而且这是写在<a href="https://www.ecma-international.org/ecma-262/#sec-html-like-comments" target="_blank" rel="noopener">规范</a>里面的。</p><h2 id="疯狂打-CALL"><a href="#疯狂打-CALL" class="headerlink" title="疯狂打 CALL"></a>疯狂打 CALL</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log.call.call.call.call.call.apply(<span class="function"><span class="params">a</span> =&gt;</span> a, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>熟悉 call 和 apply 的用法就能很快看出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log.call.call.call.call.call.apply(<span class="function"><span class="params">a</span> =&gt;</span> a, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">// =&gt; console.log.call.apply(a =&gt; a, [1, 2])</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><h2 id="事后"><a href="#事后" class="headerlink" title="事后"></a>事后</h2><p>以上所有例子出自于 <a href="https://github.com/denysdovhan/wtfjs" target="_blank" rel="noopener">WTFJS</a>，里面还有很多跟新语法有关的例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二季&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="JavaScript" scheme="http://en.ors-sro.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Unlambda</title>
    <link href="http://en.ors-sro.com/Unlambda/"/>
    <id>http://en.ors-sro.com/Unlambda/</id>
    <published>2017-08-06T11:39:46.000Z</published>
    <updated>2017-09-30T06:18:49.021Z</updated>
    
    <content type="html"><![CDATA[<p>非 lambda</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://www.madore.org/~david/programs/unlambda/" target="_blank" rel="noopener">Unlambda</a> 是一个无变量、基于组合子逻辑、图灵完备的编程语言。</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>Unlambda 的 <a href="https://repl.it/JyeM/0" target="_blank" rel="noopener">Hello world</a> 是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`r```````````.H.e.l.l.o. .w.o.r.l.di</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这个 Hello world 还是比较简单的。只涉及到 <code>r</code> ，<code>.</code> 和 <code>i</code> 三种元素。</p><p>“`” 是函数调用操作符。</p><p>相当于 C 语言函数后面的 <code>()</code> 。</p><p><code>.x</code> 是一系列的函数，如 <code>.a</code> ，<code>.b</code> , <code>.c</code> 等。</p><p>这一系列的函数都是接收一个参数，打印对应的 “x”，如 “a”，”b”，”c” 等， 并返回这个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`.H</span><br></pre></td></tr></table></figure><p>这样调用时错误的。因为 <code>.x</code> 系列的函数需要接收一个参数。</p><p>这样调用相当于 C 语言</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H() <span class="comment">// 错误 H 函数需要接收一个函数。</span></span><br></pre></td></tr></table></figure><p><code>r</code> 函数是 <code>.x</code> 函数中，x 为换行符的函数的语法糖。作用就是输出换行，返回接收的参数。</p><p><code>i</code> 函数就是 $identity$ 函数，原封不动的返回接收到的函数。用 JavaScript 表示就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设需要输出字符 “H” ，要怎么写呢。</p><p>首先需要 <code>.H</code> 函数。然后使用 “`” 操作符应用函数。</p><p>函数要求有一个参数，这个参数如果没有用到那么可以随便传。</p><p>所以答案出炉了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`.H.i</span><br><span class="line">`.H.a</span><br><span class="line">`.H.b</span><br><span class="line">`.H.c</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以上的任意一种都可以。</p><p>为什么 “`.H.a” 没有打印出 “Ha” 呢？</p><p>因为只使用了一个 “`” 函数调用操作符。</p><p>相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">H</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"H"</span>)</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>)</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "`.H.a" 相当于</span></span><br><span class="line">H(a)</span><br><span class="line"><span class="comment">// 如梭想要打印出 "Ha"，要这样</span></span><br><span class="line"><span class="comment">// "``.H.a.a" 或者 "``.H.a.H" 或者 "``.H.a.i" 反正返回值不使用</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">H(a)(i)</span><br></pre></td></tr></table></figure><p>回到 Hello world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`r```````````.H.e.l.l.o. .w.o.r.l.di</span><br></pre></td></tr></table></figure><p>翻译成 JavaScript 就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r(H(e)(l)(l)(o)( )(w)(o)(r)(l)(d)(i))</span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Unlambda 中只有函数，没有类似循环的结构，那么怎么循环呢？</p><p>如果对 lambda 比较熟悉就会清楚应该使用递归。</p><p>Unlambda 中没有数字，要怎么表达数字呢？</p><p>类似地，使用丘奇数。</p><p>Unlambda 中没有列表等数据结构。</p><p>参考 Lisp，先构建 <code>cons</code> 、<code>car</code> 和 <code>cdr</code> 剩下的就是想象力的问题了。</p><p>详情参考 <a href="http://www.madore.org/~david/programs/unlambda/" target="_blank" rel="noopener">Unlambda 官方入门教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非 lambda&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="lambda" scheme="http://en.ors-sro.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>Flash 脚本</title>
    <link href="http://en.ors-sro.com/Flash-JavaScript-API/"/>
    <id>http://en.ors-sro.com/Flash-JavaScript-API/</id>
    <published>2017-07-30T08:58:44.000Z</published>
    <updated>2017-10-08T07:29:50.141Z</updated>
    
    <content type="html"><![CDATA[<p>此 Flash 脚本非 ActionScript</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>除了跑在 Flash Player 中的脚本 ActionScript ， Flash 还有一个跑在 Adobe Flash CC 的 JavaScript 。</p><p>Flash JavaScript 提供了大量的接口，方便执行制作 flash 的某些操作，比如机械重复的导出等。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>选择文件，新建，Flash JavaScript File 。</p><p>输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">1</span>) <span class="comment">//干，又不是 XSS</span></span><br></pre></td></tr></table></figure><p>保存。</p><p>双击保存的文件运行，或者选择菜单<strong>命令</strong>，运行命令，选择保存的文件。</p><p>成功的话就能看到在 flash 的一个弹框。</p><h2 id="Show-In-Stage"><a href="#Show-In-Stage" class="headerlink" title="Show In Stage"></a>Show In Stage</h2><p>来一个复杂的例子。首先需要寻找借口，可以从<a href="http://help.adobe.com/en_US/flash/cs/extend/flash_cs5_extending.pdf" target="_blank" rel="noopener">官方的 API 手册</a>中查找。</p><p>官方手册非常详细，提供的 API 基本覆盖所有能够手动在 Adobe Flash CC 的操作。</p><p>比如其中的一页目录是这样的。</p><blockquote><p>Chapter 11: Document object<br>document.accName . . .  62<br>document.addDataToDocument() . . . 62<br>document.addDataToSelection() . . .  63<br>document.addFilter() . . .  64<br>document.addItem() . . .  64<br>document.addNewLine() . . . 65<br>document.addNewOval() . . .  66<br>document.addNewPrimitiveOval() . . .  66<br>document.addNewPrimitiveRectangle() . . .  67<br>document.addNewPublishProfile() . . .  68<br>document.addNewRectangle() . . .  69<br>document.addNewScene() . . . 70<br>document.addNewText() . . . 71</p></blockquote><p>例如做一个查找库中某个元件在哪里使用了，手册中就有类似的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将装有所有图层的数组赋值给 theLayers </span></span><br><span class="line"><span class="keyword">var</span> theLayers = fl.getDocumentDOM().getTimeline().layers;</span><br><span class="line"><span class="comment">// 创建一个用于装载所有 "myMovieClip" 实例的数组</span></span><br><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 循环所有图层</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; theLayers.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 取第一个图层</span></span><br><span class="line">  <span class="comment">// 赋值给 "theElems"</span></span><br><span class="line">  <span class="keyword">var</span> theElems = theLayers[i].frames[<span class="number">0</span>].elements;</span><br><span class="line">  <span class="comment">// 循环所有图层上的元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> c = <span class="number">0</span>; c &lt; theElems.length; c++) &#123;</span><br><span class="line">    <span class="comment">// 检查是否为实例 （instance）</span></span><br><span class="line">    <span class="keyword">if</span> (theElems[c].elementType == <span class="string">"instance"</span>) &#123;</span><br><span class="line">      <span class="comment">// 检查是否为 "myMovieClip" 的实例</span></span><br><span class="line">      <span class="keyword">if</span> (theElems[c].libraryItem.name == <span class="string">"myMovieClip"</span>) &#123;</span><br><span class="line">        <span class="comment">// 装入数组</span></span><br><span class="line">        myArray[x] = theElems[c];</span><br><span class="line">        <span class="comment">// 递增计数器</span></span><br><span class="line">        x++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择所有 "myMovieClip" 的实例</span></span><br><span class="line">fl.getDocumentDOM().selection = myArray;</span><br></pre></td></tr></table></figure><p>这个例子只能检测当前元件的所有图层，如果要检测元件的子元件还需要调用 <code>document.enterEditMode()</code>，再递归一下就完成了。</p><h2 id="百足之虫"><a href="#百足之虫" class="headerlink" title="百足之虫"></a>百足之虫</h2><p>Flash 自从<a href="https://www.apple.com/hotnews/thoughts-on-flash/" target="_blank" rel="noopener">乔帮主一战</a>后就萎靡不振，尤其是近几年在前端逐渐式微。</p><p>直到最近 <a href="http://www.tmtpost.com/2708187.html" target="_blank" rel="noopener">Adobe 宣判了 Flash 的死刑</a>， 在 2020 年正式停止支持。</p><p>即便如此，国内依然是 Flash 使用的重灾之地。各种令人作呕的页游，不思进取的视频网站还用着 Flash 播放器。</p><p>可以想象在很长的一段时间内 Flash 还会在国内苟延残喘。</p><p>但是现在确实可以不用学习 Flash 相关的技术了。ActionScript 什么的。</p><p>Flash 让制作动画变得很容易，大大丰富了当年前端的表现。</p><p>但是十年前已经不是 1997 了，相比于 2008 年，现在离 2020 年更近。</p><p>它就像青春，留下了美好的回忆。请让它静静消失而不是吸干最后一点精力，这样回想起那段闪客时代还能欣慰一笑。</p><p>Flash 你好， Flash 再见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此 Flash 脚本非 ActionScript&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="Flash" scheme="http://en.ors-sro.com/tags/Flash/"/>
    
  </entry>
  
  <entry>
    <title>Rust 所有权借用机制</title>
    <link href="http://en.ors-sro.com/Ownership-and-Borrow-in-Rust/"/>
    <id>http://en.ors-sro.com/Ownership-and-Borrow-in-Rust/</id>
    <published>2017-07-23T06:58:41.000Z</published>
    <updated>2017-07-23T07:01:40.613Z</updated>
    
    <content type="html"><![CDATA[<p>我用裸指针三十年，一共也就崩掉了三（sán）万多个程序。YEAH!</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zh.wikipedia.org/wiki/Rust" target="_blank" rel="noopener">Rust</a> 是一个由 Mozilla 开发的，准则为 「安全、并发、实用」的编程语言。</p><p>其实就是一个带指针安全的现代版 C++ （大雾）。</p><p>Rust 的设计不允许空指针和悬空指针，如果有就会编译失败。</p><blockquote><p>Rust 有一个检查指针生命期间和指针冻结的系统，可以用来预防在 C++ 中许多的类型错误，甚至是用了<a href="https://zh.wikipedia.org/wiki/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" target="_blank" rel="noopener">智能指针</a>功能之后会发生的类型错误。</p></blockquote><h2 id="C-看了都想打人"><a href="#C-看了都想打人" class="headerlink" title="C++ 看了都想打人"></a>C++ 看了都想打人</h2><p>先来看一段 Rust 的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2 = v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"v[0] is: &#123;&#125;"</span>, v[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>虽然语法跟 C++ 有区别，不过语义是类似的——声明了两个变量，并打印第一个变量中的一部分内容。</p><p>如果写成 C++ 这样的代码习以为常。</p><p>但是这段代码在 Rust 中会编译失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: use of moved value: `v`</span><br><span class="line">println!(&quot;v[0] is: &#123;&#125;&quot;, v[0]);</span><br><span class="line">                        ^</span><br></pre></td></tr></table></figure><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>在 Rust 中有一个所有权的概念。失去了所有权，将不能进行读取或者修改操作。</p><p>变量绑定（变量声明，函数调用等）会获得所有权。</p><p>所有权跟作用域绑定（通常是大括号）。离开作用域后，会自动释放资源。</p><p>Rust 中也有移动语义，如果将一个变量直接赋值给另一个变量，假设没有实现 Copy trait ，所有权会被移动到新的变量。</p><p>所以上面的报错信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: use of moved value: `v`</span><br><span class="line">println!(&quot;v[0] is: &#123;&#125;&quot;, v[0]);</span><br><span class="line">                        ^</span><br></pre></td></tr></table></figure><p>说的是使用了移动过的变量 <code>v</code>。一旦变量被移动过了，就禁止使用，就算 <code>v</code> 能指向正确的内容。</p><p>这么做是有原因的。</p><p>假设允许编译通过，可能会出现这样危险的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2 = v;</span><br><span class="line"></span><br><span class="line">v2.truncate(<span class="number">2</span>); <span class="comment">// 截取前两个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"v[3] is: &#123;&#125;"</span>, v[<span class="number">3</span>]); <span class="comment">// BOOM!</span></span><br></pre></td></tr></table></figure><p>这是因为修改了内容而原来的指针并不知道，所以按照原来看起来正确的方式最终导致了错误。</p><h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>有时候所有权转义会带来麻烦</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, v2: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; (<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// 对 v1 和 v2 搞东搞西</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还所有权和返回函数结果</span></span><br><span class="line">    (v1, v2, <span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (v1, v2, answer) = foo(v1, v2);</span><br></pre></td></tr></table></figure><p>其实只是需要内容而不是所有权啊。</p><p>所以 Rust 还有借用的机制。</p><p>使用借用机制后是这样的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(v1: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, v2: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 对 v1 和 v2 搞东搞西</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> answer = foo(&amp;v1, &amp;v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后还可以使用 v1 和 v2</span></span><br></pre></td></tr></table></figure><p>使用了借用机制之后没有所有权转移，自然就不用归还所有权了。</p><p>上面的引用是常数引用，不能修改。想修改需要使用 <code>mut</code> 关键字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">    *y += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>借用机制类似与 C++ 的引用机制但是又有几个区别。</p><ol><li>可以有多个常数级借用（&amp;T）</li><li>只能有一个可修改借用 (&amp;mut T)</li></ol><p>而且一个资源只能有一种借用方式，要么是常数级借用，要么是可修改借用。</p><p>借用也是跟作用域绑定的。比如以下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"></span><br><span class="line">    *y += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会编译失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error: cannot borrow `x` as immutable because it is also borrowed as mutable</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, x);</span><br><span class="line">                   ^</span><br><span class="line">note: previous borrow ends here</span><br><span class="line">fn main() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>这是因为 x 已经借用给 y 当作可修改借用。然后 <code>println!</code> 传递参数的时候需要常数级借用，前面说过一个资源只能有一种借用方式。 </p><p>如果改成这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x; <span class="comment">// y 借用开始</span></span><br><span class="line"></span><br><span class="line">        *y += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">// y 借用结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以了。因为 y 出了借用的作用域，借用就会自动归还。后面不会出现借用冲突的问题。</p><h2 id="走开！烦人的空悬指针"><a href="#走开！烦人的空悬指针" class="headerlink" title="走开！烦人的空悬指针"></a>走开！烦人的空悬指针</h2><p>空悬指针（dangling pointer）通常是由释放后使用（use after free）产生的。</p><p>Rust 的借用机制会防止释放后使用发生。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y: &amp;<span class="built_in">i32</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    y = &amp;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, y);</span><br></pre></td></tr></table></figure><p>编译报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error: `x` does not live long enough</span><br><span class="line">    y = &amp;x;</span><br><span class="line">         ^</span><br><span class="line">note: reference must be valid for the block suffix following statement 0 at</span><br><span class="line">2:16...</span><br><span class="line">let y: &amp;i32;</span><br><span class="line">&#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    y = &amp;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">note: ...but borrowed value is only valid for the block suffix following</span><br><span class="line">statement 0 at 4:18</span><br><span class="line">    let x = 5;</span><br><span class="line">    y = &amp;x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误提示已经说得很清楚了。就是 <code>x</code> 苟活的时间不够长。因为 <code>x</code> 出了作用域后就不再可用，所以 <code>y</code> 也相应的不再可用。因此拒绝编译通过可以避免后面的释放后使用的问题。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Rust 的空指针的解决方案是 option type 。这里不再赘述了。</p><p>天下没有免费的午餐。Rust 又要高性能，还要零负担抽象（诶怎么说得那么像某语言），那么就只能付出用户心智负担和编译时间的代价了。</p><p>从源头上避免空指针和空悬指针是可以做到的，如果你还觉得不可能是因为你用的不是现代编程语言啊，科科！</p><p><a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html" target="_blank" rel="noopener">rust 官方入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我用裸指针三十年，一共也就崩掉了三（sán）万多个程序。YEAH!&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Rust" scheme="http://en.ors-sro.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>常见的 option type 评测</title>
    <link href="http://en.ors-sro.com/About-some-option-type-implementation/"/>
    <id>http://en.ors-sro.com/About-some-option-type-implementation/</id>
    <published>2017-07-16T09:08:33.000Z</published>
    <updated>2017-10-15T08:24:35.334Z</updated>
    
    <content type="html"><![CDATA[<p>才不是什么手机评测的格式呢。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>option type 是一种用于消灭空指针（null pointer）的和类型（sum type）。</p><p>option type 用于表达可能不存在值的语义，在很多语言中都有<a href="https://en.wikipedia.org/wiki/Option_type" target="_blank" rel="noopener">相应的实现</a>。</p><p>评测对象为官方实现的 option type，而非第三方库。</p><p>主要从是否杜绝空指针和是否方便做空检查（null check）这两点评测。</p><h2 id="C-的-option"><a href="#C-的-option" class="headerlink" title="C++ 的 option"></a>C++ 的 option</h2><p>C++ 17 开始有了 option 的官方实现 <code>std::optional</code></p><p>引用 <a href="http://en.cppreference.com/w/cpp/utility/optional" target="_blank" rel="noopener">cppreference</a> 的一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;optional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// optional can be used as the return type of a factory that may fail</span></span><br><span class="line"><span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; create(<span class="keyword">bool</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Godzilla"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create(false) returned "</span></span><br><span class="line">              &lt;&lt; create(<span class="literal">false</span>).value_or(<span class="string">"empty"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// optional-returning factory functions are usable as conditions of while and if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> str = create(<span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create(true) returned "</span> &lt;&lt; *str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天啊！居然是手动做空检查！吓得我赶紧看了一下这个类的方法和辅助函数，居然没有 <code>map</code> 或者 <code>flatmap</code>。</p><p>这就是那种送到面前抄都抄错的教科书级例子。</p><p>为什么说手动做空检查是不受推荐的呢。</p><p>先忘掉 <code>std::optional</code> 的存在，回想以前的代码是怎么确保不会因为值不存在而崩溃的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>* pData = GetSomeThingMayReturnNull();</span><br><span class="line"><span class="keyword">if</span> (!pData) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value is "</span> &lt;&lt; *pData &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比上面使用 <code>std::optional</code> 的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> str = create(<span class="literal">true</span>)) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create(true) returned "</span> &lt;&lt; *str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是做法完全一样？都是先空检查再使用值。没毛病。</p><p>但是如果做法都一样为什么还要引入 <code>std::optional</code> 类型？</p><p>而且引入 <code>std::optional</code> 对于空指针问题没有明显的改善。</p><p>程序员是人，人是会犯错误的。忘记做空检查是最常见的错误。所以才会有因为忘了做空检查导致空指针问题。</p><p>使用 <code>std::optional</code> 还是得手动做空检查，那跟直接使用 <code>nullptr</code> 表达空值有什么区别？</p><p>也就是使用 <code>std::optional</code> 没有办法杜绝空指针，有出错的可能，除非能证明所有对 <code>std::optional</code> 的使用前都做了空检查。</p><p>那是不是没有办法杜绝空指针？</p><p>答案是否定的。在强类型语言如 Haskell 中会强迫用户检测，否则编译失败。从而杜绝了运行时空指针。</p><p>所以 <code>std::optional</code> 错在没有强制做空检查，没有强制做空检查的原因是编译器没有给予支持而空检查和取值操作是分开的两步操作，而不是一步原子操作。</p><p>评测结果：不推荐使用</p><h2 id="Java-的-option"><a href="#Java-的-option" class="headerlink" title="Java 的 option"></a>Java 的 option</h2><p>Java 8 也引入了 option type ，类名也是 <code>Optional</code></p><p>引用<a href="http://www.importnew.com/6675.html" target="_blank" rel="noopener">介绍 optional </a>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Optional实例，也可以通过方法返回值得到。</span></span><br><span class="line">    Optional&lt;String&gt; name = Optional.of(<span class="string">"Sanaulla"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建没有值的Optional实例，例如值为'null'</span></span><br><span class="line">    Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//isPresent方法用来检查Optional实例是否有值。</span></span><br><span class="line">    <span class="keyword">if</span> (name.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//调用get()返回Optional值。</span></span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//在Optional实例上调用get()抛出NoSuchElementException。</span></span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//ifPresent方法接受lambda表达式参数。</span></span><br><span class="line">    <span class="comment">//如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span></span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"The length of the value is: "</span> + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span></span><br><span class="line">    System.out.println(empty.orElse(<span class="string">"There is no value present!"</span>));</span><br><span class="line">    System.out.println(name.orElse(<span class="string">"There is some value!"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//orElseGet与orElse类似，区别在于传入的默认值。</span></span><br><span class="line">    <span class="comment">//orElseGet接受lambda表达式生成默认值。</span></span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//orElseThrow与orElse方法类似，区别在于返回值。</span></span><br><span class="line">      <span class="comment">//orElseThrow抛出由传入的lambda表达式/方法生成异常。</span></span><br><span class="line">      empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//map方法通过传入的lambda表达式修改Optonal实例默认值。 </span></span><br><span class="line">    <span class="comment">//lambda表达式返回值会包装为Optional实例。</span></span><br><span class="line">    Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//flatMap与map（Funtion）非常相似，区别在于lambda表达式的返回值。</span></span><br><span class="line">    <span class="comment">//map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span></span><br><span class="line">    <span class="comment">//但是flatMap方法的lambda返回值总是Optional类型。</span></span><br><span class="line">    upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//filter方法检查Optiona值是否满足给定条件。</span></span><br><span class="line">    <span class="comment">//如果满足返回Optional实例值，否则返回空Optional。</span></span><br><span class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(longName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//另一个示例，Optional值不满足给定条件。</span></span><br><span class="line">    Optional&lt;String&gt; anotherName = Optional.of(<span class="string">"Sana"</span>);</span><br><span class="line">    Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(shortName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 的 <code>Optional</code> 有 <code>map</code> 和 <code>flatmap</code> 。很好。</p><p>最大的败笔在于提供了 <code>get()</code> 方法。</p><p>在没有提供之前可以保证代码不会有空指针。</p><p>提供 <code>get()</code> 后，就必须要手动做空检查。</p><p>这就跟 C++ 的 <code>std::optional</code> 一样。</p><p>根据墨菲定律，可能出错的终将会出错。所以很可能出现直接使用 <code>get()</code> 而忘了做空检查。</p><p>如果 <code>get()</code> 抛出的异常是编译时异常还好，这样不做空检查就会编译失败。</p><p>但是 <code>get()</code> 抛出的异常 <code>NoSuchElementException</code> 是运行时异常，简直就是变相的 <code>null</code>。</p><p>听说 <code>Optional</code> 还<a href="https://zhuanlan.zhihu.com/p/22492722" target="_blank" rel="noopener">可以是空指针</a>。</p><blockquote><p>讲个笑话。</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Customer&gt; customer = customerService.retriveCustomerById(<span class="number">22492722</span>);</span><br><span class="line"></span><br><span class="line">customer.map(Customer::getName).orElse(<span class="string">"Hello world!"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>「retriveCustomerById返回null没有编译错误」</p></blockquote><p>哇！这就意味着你要先检查 <code>Optional</code> 是不是空，在检查里面有没有值。</p><p>简直是帮倒忙，不解决原有的问题还引入了新的问题。</p><p>评测结果：凑合使用，不要使用 <code>get()</code> ，更不要使用 <code>orElse(null)</code> 。</p><h2 id="没有空指针的未来"><a href="#没有空指针的未来" class="headerlink" title="没有空指针的未来"></a>没有空指针的未来</h2><p>在有了正确的 option type 后，你离没有空指针的代码只有一个语法糖的距离。</p><p>终有一天我们会跨入无空指针的时代。</p><p>到时回看这时的代码。</p><p>那一天，人类终于回想起了，曾经一度被空指针所支配的恐怖，还有被囚禁于空检查大括号中的那份屈辱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;才不是什么手机评测的格式呢。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="option" scheme="http://en.ors-sro.com/tags/option/"/>
    
  </entry>
  
  <entry>
    <title>async 和 await</title>
    <link href="http://en.ors-sro.com/async-and-await/"/>
    <id>http://en.ors-sro.com/async-and-await/</id>
    <published>2017-07-09T10:11:19.000Z</published>
    <updated>2017-10-22T07:51:25.030Z</updated>
    
    <content type="html"><![CDATA[<p>你离异步只有一个语法糖的距离。</p><a id="more"></a><h2 id="syntax-sugar"><a href="#syntax-sugar" class="headerlink" title="syntax sugar"></a>syntax sugar</h2><p>使用 Promise 编写 JavaScript 异步代码已经司空见惯。</p><p>但是 Promise 写多了还是觉得有些繁琐。</p><p>对此，一个新的语法糖提案被提出。</p><p>那就是 async 和 await 。</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 用于标识一个函数为异步函数。被标识的函数返回一个 Promise 。</p><p>也就是 async 其实只是一个语法糖。</p><p>内部的实现还是 Promise 。</p><p>相当于返回 Promise 的同步函数。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await 用于等待一个异步函数。</p><p>也就是用于取出 Promise 的值。</p><p>举一个简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有标识了 async 的函数才能在函数体中使用 await 。不然会报错。</p><p>await 后面的代码会在 Promise resolve 后才执行。但是并不会造成程序阻塞。</p><p>因为底层还是用 Promise 实现的。</p><h2 id="new-era"><a href="#new-era" class="headerlink" title="new era"></a>new era</h2><p>用 async 和 await 改写<a href="/Promise">Promise 异步编程</a>的例子</p><p>Promise 的例子代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"数据拉取成功"</span>);</span><br><span class="line">callback(data);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"拉取中……"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"处理中……"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">data += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"处理数据完成"</span>);</span><br><span class="line">resolve(data);</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"发送中……"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"数据发送成功"</span>);</span><br><span class="line">resolve(data);</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showSucess</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"恭喜充值成功游戏时间 +"</span> + data + <span class="string">"s!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">getData(resolve)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.then(handleData).then(sendData).then(showSucess);</span><br></pre></td></tr></table></figure><p>用 async 和 await 改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TakeSeveralSeconds</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ms = <span class="built_in">Math</span>.random() * <span class="number">1000</span> + <span class="number">1000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"耗时 "</span> + ms + <span class="string">" 毫秒"</span>)</span><br><span class="line">      resolve(ms)</span><br><span class="line">  &#125;, ms))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"拉取中……"</span>)</span><br><span class="line">  <span class="keyword">await</span> TakeSeveralSeconds()</span><br><span class="line">  <span class="keyword">var</span> data = <span class="number">0</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"数据拉取成功"</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"处理中……"</span>)</span><br><span class="line">  <span class="keyword">await</span> TakeSeveralSeconds()</span><br><span class="line">  data += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"处理数据完成"</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sendData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"发送中……"</span>)</span><br><span class="line">  <span class="keyword">await</span> TakeSeveralSeconds()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"数据发送成功"</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showSucess</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"恭喜充值成功游戏时间 +"</span> + data + <span class="string">"s!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="keyword">let</span> handledData = <span class="keyword">await</span> handleData(data)</span><br><span class="line">  <span class="keyword">let</span> sendedData = <span class="keyword">await</span> sendData(handledData)</span><br><span class="line">  showSucess(sendedData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>main()</code> 得到以下输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">拉取中……</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</span><br><span class="line">耗时 1438.6931921290636 毫秒</span><br><span class="line">数据拉取成功</span><br><span class="line">处理中……</span><br><span class="line">耗时 1511.1830960750424 毫秒</span><br><span class="line">处理数据完成</span><br><span class="line">发送中……</span><br><span class="line">耗时 1644.7195288709415 毫秒</span><br><span class="line">数据发送成功</span><br><span class="line">恭喜充值成功游戏时间 +1s!</span><br></pre></td></tr></table></figure><h2 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h2><p>从 Chrome 55 开始，Chrome 默认启用 async 和 await 。其他情况可以使用 babel 转译。</p><h2 id="by-the-way"><a href="#by-the-way" class="headerlink" title="by the way"></a>by the way</h2><p>async 和 await 的本质是编译器做了 CPS 变换，新加的两个 Monad 的语法糖。有什么难的（逃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你离异步只有一个语法糖的距离。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="异步" scheme="http://en.ors-sro.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>邱奇数</title>
    <link href="http://en.ors-sro.com/Church-encoding/"/>
    <id>http://en.ors-sro.com/Church-encoding/</id>
    <published>2017-07-02T08:19:24.000Z</published>
    <updated>2017-10-29T04:25:44.582Z</updated>
    
    <content type="html"><![CDATA[<p>万物皆为 lambda</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>lambda 的语法和规约定义中都没有定义数字类型。</p><p>这是为了保持 lambda 的简洁性。数字类型的定义不是必须的，可以用特定的 lambda 表示。</p><p>根据皮亚诺公理，算数系统由一个起点（1 或者 0），和一个后继函数构成。</p><p>0，1，2，3，4，5，6……只是一种符号，一种自然数的编码。自然数的编码不是唯一的。</p><p>如果你愿意你也可以使用零一二三四五六来编码。</p><p>邱奇数是一种 lambda 形式的自然数编码。</p><p>定义起点为 $ 0 = \lambda f . \lambda x . x$</p><p>后继函数为 $succ = \lambda n . \lambda f. \lambda x. f (n f x)$</p><p>根据定义 $0$ 的后继为 $1$ 。所以将 $0$ 带入后记函数 $succ$ 中得到</p><p>$ (\lambda n . \lambda f . \lambda x. f(n f x) 0)$</p><p>将 $0$ 代入得到。</p><p>$(\lambda n. \lambda f. \lambda x. f(n f x) (\lambda f . \lambda x . x))$</p><p>为了避免混淆，对 $0$ 使用 $\alpha$ 变换。</p><p>$(\lambda n. \lambda f. \lambda x .f(n f x) (\lambda a . \lambda b . b))$</p><p>应用 $n = \lambda a . \lambda b . b$</p><p>$\lambda f. \lambda x. f((\lambda a . \lambda b . b) (f x))$</p><p>继续规约 $ a = f $</p><p>$\lambda f . \lambda x. f((\lambda b. b)x)$</p><p>继续规约 $  b = x $</p><p>$\lambda f . \lambda x .f x$</p><p>类似的方法可以得到 1 到 n 的定义</p><p>$0 = \lambda f . \lambda x . x $</p><p>$1 = \lambda f . \lambda x . f x$</p><p>$2 = \lambda f . \lambda x . f (f x)$</p><p>$3 = \lambda f . \lambda x . f (f (f x))$</p><p>$4 = \lambda f . \lambda x . f (f (f (f x)))$</p><p>$5 = \lambda f . \lambda x . f (f (f (f (f x))))$</p><p>$6 = \lambda f . \lambda x . f (f (f (f (f (f x)))))$</p><p>$7 = \lambda f . \lambda x . f (f (f (f (f (f (f x))))))$</p><p>$8 = \lambda f . \lambda x . f (f (f (f (f (f (f (f x)))))))$</p><p>$9 = \lambda f . \lambda x . f (f (f (f (f (f (f (f (f x))))))))$</p><p>$n = \lambda f . \lambda x . f^n x$</p><p>邱奇数的编码是将自然数 n 转化为 n 的次方，也就是 n 次函数复合。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>自然数运算最常见的是加减乘除。</p><p>先来定义最简单的加法。</p><p>$plus(m,n) = m + n$</p><p>因为邱奇数的编码是次方，所以 $f^{m+n}(x) = f^m(x) + f^n (x)$ 。</p><p>因此定义加法为 </p><p>$ plus = \lambda m . \lambda n. \lambda f. \lambda x . m f (n f x)$</p><p>类似的乘法定义为</p><p>$mult = \lambda m . \lambda n . \lambda f . n (m f)$</p><p>因为减法和除法会产生出界的情况，这里就不展开定义了。有兴趣的烦请移步<a href="https://en.wikipedia.org/wiki/Church_encoding" target="_blank" rel="noopener">维基百科</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;万物皆为 lambda&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="lambda" scheme="http://en.ors-sro.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>λ 演算</title>
    <link href="http://en.ors-sro.com/Lambda-calculus/"/>
    <id>http://en.ors-sro.com/Lambda-calculus/</id>
    <published>2017-06-25T08:43:56.000Z</published>
    <updated>2017-06-25T08:49:29.556Z</updated>
    
    <content type="html"><![CDATA[<p>是 $\lambda$ 演算不是入演算[滑稽]</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>lambda 表达式可以简单理解为匿名函数。</p><p>现在不少语言都加入了 lambda 表达式。就连名词王国 Java 也忍不住参与了。</p><p>一个普通的送命函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Plus</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 Java 中的 lambda 表达式是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>用 JavaScript 中的 lambda 表达式是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>用 Scheme 中的 lambda 表达式是这样的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">+</span> x <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>用 C++ 中的 lambda 表达式是这样的（没错就是要和别的妖艳贱货不一样）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[=](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x + <span class="number">1</span>;&#125;;</span><br></pre></td></tr></table></figure><p>使用 lambda 表达式能够方便函数的创建，传递，返回等，大大方便了编程，就不说某不思进取语言之前只能传递匿名类的故事了。</p><p>实际上 lambda 表达式源于 $\lambda$ 演算。</p><p>对编程有基本了解的人都应该知道图灵机，图灵机是目前能实现的最强计算模型。图灵机的运算是读写头在纸带上运动，可以说是非常工程派了。相应地，学术派中用于研究计算的是 $\lambda$ 演算，它拥有图灵机一样的运算能力。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>$\lambda$ 演算的语法定义为</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= &lt;var&gt;</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (λ&lt;var&gt;.&lt;exp&gt;)</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (&lt;exp&gt; &lt;exp&gt;)</span><br></pre></td></tr></table></figure><p>第一条是变量抽象，即一个 $\lambda$ 项可以是一个变量。</p><p>第二条是函数抽象，即一个 $\lambda$ 项可以接收一个变量，返回一个 $\lambda$ 项。</p><p>第三条是函数应用，即一个 $\lambda$ 项可以应用一个 $\lambda$ 项。</p><p>比如对于 JavaScript 的 lambda 表达式 <code>x =&gt; x + 1</code> 可以表示为 $\lambda x. x + 1$ 。（假设 <code>+</code> 和 $1$ 都是良定的）。</p><p>第二条函数抽象限制了函数只有一个参数，那么遇到多个参数怎么办呢？</p><p>这里需要用到老生常谈的柯里化。</p><p>简单的说是将多参函数转化成多个单参函数的组合。</p><p>例如对于 <code>(x, y) =&gt; x + y</code> 相应的 $\lambda$ 项是 $\lambda x. (\lambda y. x + y)$ 。</p><p>为了手写方便，可以省略括号 $\lambda x . \lambda y . x + y$ 。</p><p>再次为了手写方便，可以省略为 $\lambda x y . x + y$ 。</p><h2 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h2><p>光有语法肯定是不够的。还需要规约规则。</p><p>$\lambda$ 演算有三条规约规则。</p><p>$\alpha$ 替换（重命名）：替换被绑定变量不改变结果。如 $\lambda x. x + 1$ 和 $\lambda t . t + 1$ 是一样的。类似于编程语言中的函数参数重命名。</p><p>$\beta$ 规约（函数应用）：函数应用为函数形参替换为实参的过程。如 $((\lambda x. x + 1) 2)$ 的结果为 $2 + 1 = 3$ 。类似于编程语言中的函数应用。</p><p>$\eta$ 转换（外延性相等）：两个函数对于所有的参数得到的结果都一致。之所以称为外延性相等是如果把两个函数当作黑盒，那么它们是一致的。如果查看黑盒中的内容就会发现内容可能不一样。如 $\lambda x . f x$ 与 $f$ 外延性相等。举一个 JavaScript 的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line"><span class="comment">// 外延性相等于</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>说了那么多可能只是知道一些概念，可以<a href="https://people.eecs.berkeley.edu/~gongliang13/lambda/" target="_blank" rel="noopener">在线运算</a>一些例子来加深理解。</p><p>想要更加深入了解可以前往<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">维基百科</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是 $\lambda$ 演算不是入演算[滑稽]&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="lambda" scheme="http://en.ors-sro.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>柯里-霍华德同构</title>
    <link href="http://en.ors-sro.com/Curry-Howard-correspondence/"/>
    <id>http://en.ors-sro.com/Curry-Howard-correspondence/</id>
    <published>2017-06-18T13:08:03.000Z</published>
    <updated>2017-11-05T07:13:39.576Z</updated>
    
    <content type="html"><![CDATA[<p>这真的只是一种巧合吗？</p><a id="more"></a><h2 id="命题与类型"><a href="#命题与类型" class="headerlink" title="命题与类型"></a>命题与类型</h2><p>一个函数的类型可以是 <code>A -&gt; B -&gt; A</code> 。</p><p>一个命题的类型可以是 $\alpha \to \beta \to \alpha$ 。</p><p>可以发现，这两个类型是类似的。</p><p>类型 <code>A</code> 类似于命题 $\alpha$ 。</p><p>函数 <code>-&gt;</code> 类似于蕴含 $\to$ 。</p><p>实际上这是柯里-霍华德同构。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>柯里-霍华德同构</strong>揭示了计算机程序和数学证明之间的紧密联系。</p><p>类型即命题，程序即证明。</p><p>也就是函数的类型相当于命题，函数的实现相当于证明。这在 Coq 中体现得很明显。</p><p>用 <a href="https://www.zhihu.com/people/be5invis/answers" target="_blank" rel="noopener">be5</a> 大大<a href="https://zhihu.com/question/22959608/answer/24770830" target="_blank" rel="noopener">一针见血的解释</a>来说就是</p><blockquote><p>Lambda 演算同构为 Gentzen 的自然演绎</p><ul><li>函数调用就是蕴含消除</li><li>函数抽象就是蕴含介入</li><li>参数多态就是全称量化</li><li>模板类型就是谓词</li><li>结构类型就是合取</li><li>联合类型就是析取</li><li>收参数但不返回就是否定</li><li>高洋上的 call/cc 就是双重否定消除</li></ul></blockquote><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>函数调用的规则是<br>$$<br>{\Gamma\vdash t:\sigma\to\tau\quad\Gamma\vdash u:\sigma}\over{\Gamma\vdash t\,u : \tau}<br>$$<br>结果从 $\sigma\to\tau$ 变成 $\tau$ ，少了蕴含 $\to$ 所以称为蕴含消除。</p><p>相应的函数调用的逆操作函数抽象的规则是<br>$$<br>{\Gamma,x:\sigma\vdash t:\tau}\over{\Gamma\vdash \lambda x : \sigma.t : \sigma \to \tau}<br>$$<br>结果从 $\tau$ 变成 $\sigma\to\tau$ ，多了蕴含 $\to$ 所以称为蕴含介入。</p><p>参数多态实际上是对于某个参数不限制类型，相当于逻辑量词 $\forall$ ，也就是全称量化。</p><p>联合类型，例如 <code>Maybe Int</code> ，表示可能是 <code>Int</code> 或者是 <code>Nothing</code> 。关系是<strong>或</strong>，也就是析取。</p><p>相应地，结构类型表示可以同时是多个类型，关系是<strong>且</strong>，也就是合取。</p><p>对于接受参数而不返回的函数，或者返回 Unit 的函数，实际上类似于 $A \to \bot$ ，返回一个底。 </p><p>CPS 转换对应的是双重否定转换，也就是双重否定介入。</p><p>相应地，<code>call/cc</code> 对应的是双重否定消除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这真的只是一种巧合吗？&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="同构" scheme="http://en.ors-sro.com/tags/%E5%90%8C%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Coq  入门学习笔记 （1）</title>
    <link href="http://en.ors-sro.com/Coq-Notes-1/"/>
    <id>http://en.ors-sro.com/Coq-Notes-1/</id>
    <published>2017-06-11T08:11:55.000Z</published>
    <updated>2017-11-12T06:28:45.090Z</updated>
    
    <content type="html"><![CDATA[<p>鸡年当然要学习鸡语言啦。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://zh.wikipedia.org/wiki/Coq" target="_blank" rel="noopener">Coq</a> 是一个基于<a href="https://zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">构造演算</a>的定理证明辅助工具。</p><p>在开始玩耍之前需要到官网<a href="https://coq.inria.fr/download" target="_blank" rel="noopener">下载 Coq</a></p><p>安装完成后打开 Coq 的 REPL —— Coq.exe 。</p><p>打开后能看到类似内容</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Coq <span class="number">8.6</span> (December <span class="number">2016</span>)</span><br><span class="line"></span><br><span class="line">Coq &lt;</span><br></pre></td></tr></table></figure><p>输入 <code>&quot;Hello World&quot;.</code> 打印 Hello World 。</p><p>然而并没有什么 Hello World :P 。</p><h2 id="普通的引理"><a href="#普通的引理" class="headerlink" title="普通的引理"></a>普通的引理</h2><p>先来证明一个普通的引理，算是 Hello World 吧。</p><p>在 Coq 中输入一下内容。 被 <code>(*</code> 和 <code>*)</code> 括起来的是注释不用输入。  「Coq &lt;」 也不用输入。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Coq &lt; <span class="keyword">Section</span> Minimal_Logic. <span class="comment">(* 以点号结尾，类似 C 语言的分号 *)</span></span><br><span class="line"></span><br><span class="line">Coq &lt; <span class="keyword">Variables</span> A B C : <span class="keyword">Prop</span>. <span class="comment">(* 如果还没输入点就换行了，只需输入点就能结束 *)</span></span><br><span class="line">A is assumed</span><br><span class="line">B is assumed</span><br><span class="line">C is assumed</span><br><span class="line"></span><br><span class="line">Coq &lt; <span class="keyword">Goal</span> (A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C.</span><br><span class="line"><span class="number">1</span> subgoal</span><br><span class="line"></span><br><span class="line">  A, B, C : <span class="keyword">Prop</span></span><br><span class="line">  ============================</span><br><span class="line">  (A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C</span><br><span class="line"></span><br><span class="line">Unnamed_thm &lt; <span class="built_in">auto</span>.</span><br><span class="line">No more subgoals.</span><br></pre></td></tr></table></figure><p>证明完毕！到此结束，手动再见。</p><h2 id="简单的过程"><a href="#简单的过程" class="headerlink" title="简单的过程"></a>简单的过程</h2><p>既然愿意了解，那么就一步步来。先撤销证明。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &lt; <span class="keyword">Undo</span>. （* U 是大写 *）</span><br><span class="line"><span class="number">1</span> subgoal</span><br><span class="line"></span><br><span class="line">  A, B, C : <span class="keyword">Prop</span></span><br><span class="line">  ============================</span><br><span class="line">  (A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C</span><br></pre></td></tr></table></figure><p>输出的内容中 1 subgoal 说明只有一个目标需要证明</p><p><code>A, B, C : Prop</code> 表示 A B C 都是 Prop 。Prop 是命题 （<strong>Prop</strong>osition）的缩写。</p><p><code>============================</code> 是分割线。上面的内容是假设和条件。下面的内容是需要证明的部分。</p><p><code>(A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C</code> 需要证明的内容。 用 <code>()</code> 括起来表示视为一个整体， <code>-&gt;</code> 为蕴涵。</p><p><code>A -&gt; B</code> 读作若 A 则 B。</p><p>接下来为了方便证明，需要引入一些假设。</p><p>使用 <code>intro</code> 引入<strong>一个</strong>假设。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &lt; <span class="built_in">intro</span> H.</span><br><span class="line"><span class="number">1</span> subgoal</span><br><span class="line"></span><br><span class="line">  A, B, C : <span class="keyword">Prop</span></span><br><span class="line">  H : A -&gt; B -&gt; C</span><br><span class="line">  ============================</span><br><span class="line">  (A -&gt; B) -&gt; A -&gt; C</span><br></pre></td></tr></table></figure><p>引入了假设 <code>H : A -&gt; B -&gt;C</code> 。证明的目标就变成了 <code>(A -&gt; B) -&gt; A -&gt; C</code>。</p><p>还可以引入多个假设。</p><p>多个假设使用 <code>intros</code> 就是 <code>intro</code> 加了 s 。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &lt; <span class="built_in">intros</span> H' HA.</span><br><span class="line"><span class="number">1</span> subgoal</span><br><span class="line"></span><br><span class="line">  A, B, C : <span class="keyword">Prop</span></span><br><span class="line">  H : A -&gt; B -&gt; C</span><br><span class="line">  H' : A -&gt; B</span><br><span class="line">  HA : A</span><br><span class="line">  ============================</span><br><span class="line">  C</span><br></pre></td></tr></table></figure><p>现在需要证明的目标变成了 <code>C</code> 。</p><p>观察已有条件，发现假设 <code>H : A -&gt; B -&gt; C</code> 蕴涵 <code>C</code>。当然演绎出 <code>C</code> 还需要 <code>A -&gt; B</code> 。</p><p>可以先应用假设，转化证明的目标。</p><p>应用假设使用 <code>apply</code> </p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &lt; <span class="built_in">apply</span> H.</span><br><span class="line"><span class="number">2</span> subgoals</span><br><span class="line"></span><br><span class="line">  A, B, C : <span class="keyword">Prop</span></span><br><span class="line">  H : A -&gt; B -&gt; C</span><br><span class="line">  H' : A -&gt; B</span><br><span class="line">  HA : A</span><br><span class="line">  ============================</span><br><span class="line">  A</span><br><span class="line"></span><br><span class="line">subgoal <span class="number">2</span> is:</span><br><span class="line"> B</span><br></pre></td></tr></table></figure><p>现在目标变成了两个，一个 <code>A</code> 一个 <code>B</code> 。</p><p>观察已有条件，<code>A</code> 刚好是假设 <code>HA : A</code> 。</p><p>使用 <code>exact</code> 表示刚好。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &lt; <span class="built_in">exact</span> HA.</span><br><span class="line"><span class="number">1</span> subgoal</span><br><span class="line"></span><br><span class="line">  A, B, C : <span class="keyword">Prop</span></span><br><span class="line">  H : A -&gt; B -&gt; C</span><br><span class="line">  H' : A -&gt; B</span><br><span class="line">  HA : A</span><br><span class="line">  ============================</span><br><span class="line">  B</span><br></pre></td></tr></table></figure><p>现在目标变成了 <code>B</code> 。</p><p>观察已有条件，假设 <code>H&#39; : A -&gt; B</code> 蕴含了 <code>B</code> 。</p><p>那么应用 <code>H&#39;</code> 即可。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &lt; <span class="built_in">apply</span> H'.</span><br><span class="line"><span class="number">1</span> subgoal</span><br><span class="line"></span><br><span class="line">  A, B, C : <span class="keyword">Prop</span></span><br><span class="line">  H : A -&gt; B -&gt; C</span><br><span class="line">  H' : A -&gt; B</span><br><span class="line">  HA : A</span><br><span class="line">  ============================</span><br><span class="line">  A</span><br></pre></td></tr></table></figure><p>现在目标变成了 <code>A</code>。</p><p>之前已经证明了 <code>A</code> 。这里可以用 <code>exact HA.</code> 。</p><p>也可以直接总结，表示目标已经证明。</p><p>总结使用 <code>assumption</code>。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &lt; <span class="built_in">assumption</span>.</span><br><span class="line">No more subgoals.</span><br></pre></td></tr></table></figure><p><code>No more subgoals</code> 说明没有需要证明的目标了。证明结束。</p><p>证明可以使用 <code>Save</code> 保存。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &lt; <span class="keyword">Save</span> trivial_lemma.</span><br><span class="line"><span class="built_in">intro</span> H.</span><br><span class="line">(<span class="built_in">intros</span> H' HA).</span><br><span class="line">(<span class="built_in">apply</span> H).</span><br><span class="line"> <span class="built_in">exact</span> HA.</span><br><span class="line"></span><br><span class="line"> (<span class="built_in">apply</span> H').</span><br><span class="line"> <span class="built_in">assumption</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Save</span> trivial_lemma.</span><br><span class="line">trivial_lemma is defined</span><br></pre></td></tr></table></figure><p>中间的部分就是证明的过程。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这次就简单的写个 Hello World 的笔记。<a href="https://coq.inria.fr/tutorial/1-basic-predicate-calculus" target="_blank" rel="noopener">后面的内容</a>还需要慢慢整理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鸡年当然要学习鸡语言啦。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Coq" scheme="http://en.ors-sro.com/tags/Coq/"/>
    
  </entry>
  
  <entry>
    <title>用 Flashdevelop 调试 ActionScript</title>
    <link href="http://en.ors-sro.com/Debug-As-in-Flashdevelop/"/>
    <id>http://en.ors-sro.com/Debug-As-in-Flashdevelop/</id>
    <published>2017-06-04T07:20:42.000Z</published>
    <updated>2017-11-19T07:12:33.909Z</updated>
    
    <content type="html"><![CDATA[<p>就算是过气的语言也有使用场景啊（页游）。</p><a id="more"></a><p>FlashDevelop 是编写 ActionScript 的常用 IDE 。FlashDevelop 支持调试 ActionScript 。</p><p>不过 FlashDevelop 调试还要装杂七杂八的东西。</p><p>配置过程如下</p><h2 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h2><p>因为大多数人的 FlashDevelop 用的是 32 位版，所以需要下载 32 位版的 Java</p><p><a href="https://www.java.com/zh_CN/download/manual.jsp" target="_blank" rel="noopener">https://www.java.com/zh_CN/download/manual.jsp</a></p><p><img src="/img/DebugAsInFlashdevelop/SelectJava.png" alt="SelectJava"></p><p>选择第二个，Windows 脱机。</p><p>安装完成后打开命令行输入 <code>java</code> 应该返回类似画面</p><p><img src="/img/DebugAsInFlashdevelop/Java.png" alt="Java"></p><p>如果不是这样，需要<a href="https://jingyan.baidu.com/article/925f8cb836b26ac0dde0569e.html" target="_blank" rel="noopener">配置 Java_Home 环境变量</a></p><p>环境变量生效需要<strong>重启</strong></p><h2 id="安装-Flex-SDk"><a href="#安装-Flex-SDk" class="headerlink" title="安装 Flex SDk"></a>安装 Flex SDk</h2><p>打开 FlashDevelop -&gt; Tool -&gt; Install Software…</p><p>勾选 <strong>Flex SDK(OLD)</strong> </p><p><img src="/img/DebugAsInFlashdevelop/InstallSDK.png" alt="InstallSDK"></p><p>点击 <strong>Install 1 items</strong> 安装</p><p>安装完成后<strong>重启 FlashDevelop</strong></p><p>如果提示找不到 SDK 描述文件，则需要从刚装好的 SDK 目录下复制 <strong>flex-sdk-description.xml</strong> （可以用 <a href="http://www.voidtools.com/" target="_blank" rel="noopener">everything</a> 查找）到提示的路径中。</p><p><img src="/img/DebugAsInFlashdevelop/Warning.png" alt="Warning"></p><p>复制后<strong>重启 FlashDevelop</strong></p><h2 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h2><p>打开 FlashDevelop -&gt; Project -&gt; Propperties</p><p><strong>Compilation Target</strong> 选为 <strong>Other IDE</strong></p><p><strong>Test Project</strong> 选为 <strong>Play: External Player</strong></p><p><img src="/img/DebugAsInFlashdevelop/ExternalPlayer.png" alt="SelectExternalPlayer"></p><p><strong>Install SDK(s)</strong> 选为 <strong>Flex</strong></p><p><img src="/img/DebugAsInFlashdevelop/SelectSDK.png" alt="SelectSDK"></p><h2 id="配置外部播放器"><a href="#配置外部播放器" class="headerlink" title="配置外部播放器"></a>配置外部播放器</h2><p>打开 FlashDevelop -&gt; Programs Settings… -&gt; 往下拖动找到 FlashViewer</p><p>设置 <strong>External Player Path</strong> 为 <code>C:\Program Files (x86)\Adobe\Adobe Flash CS6\Players\Debug\FlashPlayerDebugger.exe</code></p><p><img src="/img/DebugAsInFlashdevelop/SetExternalPlayer.png" alt="SetExternalPlayer"></p><h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>打开想要调试的 <strong>FLA</strong> ，在 FlashDevelop 中打开相应的 as 文件，下个能运行到的断点。</p><p>红框右边选择为 Debug ，点击运行（F5），Happy Debugging！</p><p><img src="/img/DebugAsInFlashdevelop/Play.png" alt="Play"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就算是过气的语言也有使用场景啊（页游）。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="ActionScript" scheme="http://en.ors-sro.com/tags/ActionScript/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下安装 Emacs+Sbcl+Slime</title>
    <link href="http://en.ors-sro.com/Install-Emacs-Sbcl-and-Slime/"/>
    <id>http://en.ors-sro.com/Install-Emacs-Sbcl-and-Slime/</id>
    <published>2017-05-28T10:04:02.000Z</published>
    <updated>2017-11-24T13:07:23.190Z</updated>
    
    <content type="html"><![CDATA[<p>旧文重发，略作修改</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实网上已经有很多类似的文章了，我也是按照上面的来做。在做的过程中会遇到几个很坑的地方，我自己也是折腾了好久才弄好。所以现在写出来希望能对大家有所帮助。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="下载和安装-Emacs"><a href="#下载和安装-Emacs" class="headerlink" title="下载和安装 Emacs"></a>下载和安装 Emacs</h3><p><a href="http://ftp.gnu.org/gnu/emacs/windows/emacs-24.3-bin-i386.zip" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/emacs/windows/emacs-24.3-bin-i386.zip</a> </p><p>解压运行安装</p><h3 id="下载-Sbcl"><a href="#下载-Sbcl" class="headerlink" title="下载 Sbcl"></a>下载 Sbcl</h3><p><a href="http://www.sbcl.org/platform-table.html" target="_blank" rel="noopener">http://www.sbcl.org/platform-table.html</a></p><p>选 Windows 和你的架构。如果不知道的话就选 X86 就行了。</p><h3 id="下载-Slime"><a href="#下载-Slime" class="headerlink" title="下载 Slime"></a>下载 Slime</h3><p><a href="https://github.com/slime/slime" target="_blank" rel="noopener">https://github.com/slime/slime</a></p><p>如果你有 github 帐户就直接 git clone 吧。如果没有的话，点 download zip 然后解压。 </p><h3 id="安装Sbcl"><a href="#安装Sbcl" class="headerlink" title="安装Sbcl"></a>安装Sbcl</h3><p>双击安装包，改一下安装路径到你想安装的地方。但是这里有一个坑。</p><p><strong>坑1：系统变量重启才会更新</strong></p><p>这是因为在安装的过程中会给系统加一个 Sbcl 路径的变量。</p><p>所以一定要安装完后重启，不然就会提示</p><blockquote><p>fatal error encountered in SBCL pid 10236(tid 9971200):<br>can’t find core file at XXXXX</p></blockquote><p>安装成功的标志是运行 sbcl.exe 会出现类似这样的界面：</p><p><img src="/img/InstallEmacsSbclandSlime/sbcl.png" alt="运行 sbcl"></p><h3 id="配置-Emacs"><a href="#配置-Emacs" class="headerlink" title="配置 Emacs"></a>配置 Emacs</h3><p>本来在 Linux 下配置 Emacs 是一件简单的事，但在 Windows 下就不那么容易了。因为 Windows 文件名命名机制这里有一个坑。</p><p><strong>坑2:找不到 Emacs 的配置文件 .emacs</strong></p><p>这是因为 Windows 不允许只有扩展名而没有文件名（在 Windows 看来是 .emacs 非法的，必须是 XXX.emacs 才是合法的。Linux 则是看成一个隐藏文件而已）</p><p>所以要做的第一步是生成 .emacs 配置文件</p><p>原理是通过修改选项之后点保存选项会生成 .emacs 配置文件</p><p>方法很简单。在 Emacs 目录下双击 runemacs.exe 打开 emacs</p><p>然后在菜单栏里点 Options—-Show/Hide—-tool-bar</p><p>之后点 Options—-Save options</p><p>这样就会在 <code>C:\Users\你的用户名\AppData\Roaming</code> 下生成一个 .emacs</p><p>打开 .emacs 输入以下内容以配置 Slime</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> inferior-lisp-program <span class="string">"sbcl路径"</span>)<span class="comment">; 设置优先使用哪种 Common Lisp 实现</span></span><br><span class="line">(<span class="name">add-to-list</span> <span class="symbol">'load-path</span> <span class="string">"slime路径"</span>)<span class="comment">; 设置 Slime 路径</span></span><br><span class="line">(<span class="name"><span class="builtin-name">require</span></span> <span class="symbol">'slime</span>)</span><br><span class="line">(<span class="name">slime-setup</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">require</span></span> <span class="symbol">'slime-autoloads</span>)</span><br><span class="line">(<span class="name">slime-setup</span> '(slime-fancy))<span class="comment">; 让 slime 变得更好看，比如把 sbcl 的*变成 CL-USER&gt;</span></span><br></pre></td></tr></table></figure><p>其中路径使用<code>/</code>或者<code>//</code>分隔</p><p>这其中有一个坑需要小心</p><p><strong>坑3：sbcl 的路径一定要写到 sbcl.exe 不然会提示</strong></p><blockquote><p>Specified program for new process is a directory</p></blockquote><p>这个真的是深坑啊。当时我花了不少时间才折腾好</p><p>原理就是 slime 调用的时候不会从你填的路径找到 sbcl.exe 而是需要给出 sbcl.exe 的完整路径</p><p>我的 .emacs 配置是这样的</p><p><img src="/img/InstallEmacsSbclandSlime/emacs-setting.png" alt="Emacs 配置"></p><p>打开 Emacs 按 M-x（window下就是Alt+x）输入 slime 之后会出现像这样的</p><p><img src="/img/InstallEmacsSbclandSlime/run-emacs.png" alt="运行 Slime"></p><p>输入<code>&quot;Hello Common Lisp!&quot;</code> 一声长叹</p><p><img src="/img/InstallEmacsSbclandSlime/hello-world.png" alt="Hello World"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>一些常用的 Slime 快捷键</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-k 编译当前文件 （也就是Ctrl+c后再Ctrl+k） </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-c 增量编译（这是我自己的理解） </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-z 切换到Slime </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-l 加载文件</span><br></pre></td></tr></table></figure><p>当然以上快捷键都可以再 .emacs 里面改。</p><p>PS:我的配色是 solarized 字体是 Monaco</p><p>PSS：以上是 Vim 的配色。Emacs 的配色是自带的 dichromacy</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;旧文重发，略作修改&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="Emacs" scheme="http://en.ors-sro.com/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>侃类型</title>
    <link href="http://en.ors-sro.com/About-Type/"/>
    <id>http://en.ors-sro.com/About-Type/</id>
    <published>2017-05-21T06:34:24.000Z</published>
    <updated>2017-12-03T07:19:08.303Z</updated>
    
    <content type="html"><![CDATA[<p>随便说一说类型。</p><a id="more"></a><h2 id="类型的作用"><a href="#类型的作用" class="headerlink" title="类型的作用"></a>类型的作用</h2><p>如果用记事本写一段程序，就会发现两个问题。</p><p>一个是没有代码提示，一个变量点另一个变量也不知道有没有拼写对。</p><p>另一个是很容易编译失败，因为可能会发生一些类型出错的问题。</p><p>有了类型能够避免手误，编辑器会提示不存在相应的成员变量，从而更早的发现问题。</p><p>使用类型可以显式地表达一种约束。比如加减乘除需要数字，如果传入了字符串就可以在编译期报错，而不是等到运行时才出错。</p><p>许许多多的类型组成了类型系统。类型系统按不同的维度可以分为好几种。</p><h2 id="强类型和弱类型"><a href="#强类型和弱类型" class="headerlink" title="强类型和弱类型"></a>强类型和弱类型</h2><p>如果一个类型系统允许隐式类型转换，就是弱类型。否则为强类型。</p><p>C 系列语言就是弱类型。它允许隐式类型转换，如整数类型转为浮点数类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFloat</span><span class="params">(<span class="keyword">float</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">printFloat(i);        <span class="comment">// 隐式类型转换</span></span><br><span class="line">printFloat((<span class="keyword">float</span>)i); <span class="comment">// 显式类型转换</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Haskell 不允许隐式类型转换。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">printFloat</span> :: <span class="type">Float</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printFloat</span> v = putStrLn (show v)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> printFloat (toInteger <span class="number">1</span>)</span><br><span class="line">          printFloat <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>会编译失败。报错类型不匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Couldn&apos;t match expected type ‘Float’ with actual type ‘Integer’</span><br><span class="line">In the first argument of ‘printFloat’, namely ‘(toInteger 1)’</span><br><span class="line">In a stmt of a &apos;do&apos; block: printFloat (toInteger 1)</span><br></pre></td></tr></table></figure><p>强类型看起似乎麻烦一些，但是类型转换的工作总是要做的。类型转换的规则应该按照实际情况来，是向下取整还是四舍五入。强类型逼迫思考这部分的逻辑，避免错误被隐藏。</p><h2 id="动态类型和静态类型"><a href="#动态类型和静态类型" class="headerlink" title="动态类型和静态类型"></a>动态类型和静态类型</h2><p>如果类型能够在编译期确定，就是静态类型，否则为动态类型。</p><p>C 系列语言都是静态类型。举一个 C# 的例子。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(PlusSecond(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PlusSecond</span>(<span class="params"><span class="keyword">int</span> donation</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> life = <span class="keyword">int</span>.MaxValue;</span><br><span class="line"><span class="keyword">return</span> life + donation; <span class="comment">// donation 一定是 int 类型</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分的脚本语言都是动态类型，比如又爱又恨的 JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlusSecond</span>(<span class="params">donation</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> life = <span class="literal">Infinity</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(donation)) <span class="comment">// 运行时才能确定 donation 的类型。</span></span><br><span class="line">  <span class="keyword">return</span> life + donation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至不能确定函数的返回类型</span></span><br><span class="line">PlusSecond(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// =&gt; number</span></span><br><span class="line"><span class="comment">// =&gt; Infinity</span></span><br><span class="line">PlusSecond(<span class="string">" life"</span>);</span><br><span class="line"><span class="comment">// =&gt; string</span></span><br><span class="line"><span class="comment">// =&gt; "Infinity life"</span></span><br></pre></td></tr></table></figure><p>动态类型虽然不能确定类型但还是有类型的。</p><p>动态类型虽然没有类型，容易出错，但是有 REPL 可以快速迭代代码啊，撸起袖子就是干。只可惜动态一时爽，重构火葬场。</p><h2 id="无类型"><a href="#无类型" class="headerlink" title="无类型"></a>无类型</h2><p>现在大部分的语言都是有类型的。毕竟有类型很方便啊。但还是存在一些无类型的语言，虽然可能算不上编程语言。</p><p>入演算（滑稽），Lambda Calculus，就是一种无类型的，与图灵机等价的计算模型。</p><p>语法为</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= &lt;var&gt;</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (λ&lt;var&gt;.&lt;exp&gt;)</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (&lt;exp&gt; &lt;exp&gt;)</span><br></pre></td></tr></table></figure><p>规约规则有 α-变换（重命名），β-归约（应用）和 η-变换（外延性相等）。</p><p>具体规则可以参考未来的我写的<a href="/Lambda-calculus">λ 演算</a>。</p><p>从语法中没有看到半点关于类型的东西，甚至连循环都看不到。</p><p>没有循环还能不能愉快的写代码了。</p><p>循环可以用递归代替。那递归怎么实现呢？</p><p>虽然定义中没有给出递归，但是可以通过不动点组合子实现。</p><p>比如著名的 Y 组合子</p><p> $Y=\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$ </p><p>利用不动点的性质就可以达到递归。</p><p>$Y\ g=g\ (Y\ g)=g\ (g\ (Y\ g))=g\ (\ldots g\ (Y\ g)\ldots )$</p><p>不过因为 Y 组合子是 Call by name。而传统的语言一般是立即求值，所以需要 Y 组合子的 Call by value 版 Z 组合子。</p><p>$Z=\lambda f.(\lambda x.f(\lambda v.xxv))(\lambda x.f(\lambda v.xxv))$</p><p>Z 组合子的用法很简单，比如在 ES6 中用递归的方式写阶乘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Z = <span class="function"><span class="params">f</span> =&gt;</span> (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)))</span><br><span class="line">               (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fact = Z (<span class="function"><span class="params">f</span> =&gt;</span> n =&gt; n == <span class="number">1</span> ? <span class="number">1</span> : n * f(n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fact(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure><p>那么问题来了，Z 的类型是？</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>在无类型的入演算引入蕴含（$\to$）就会变成简单类型的入演算（$\lambda^\to$）。</p><p>类型规则很简单</p><p>$\dfrac{}{x:\sigma \vdash x : \sigma}$</p><p>$\dfrac{\Gamma\vdash x:\sigma\quad x\not=y}{\Gamma,y:\tau \vdash x : \sigma}$</p><p>$\dfrac{\Gamma,x:\sigma\vdash t:\tau} {\Gamma\vdash \lambda x : \sigma.t : \sigma \to \tau}$</p><p>$\dfrac{\Gamma\vdash t:\sigma\to\tau\quad\Gamma\vdash u:\sigma}{\Gamma\vdash t\,u : \tau}$</p><p>例如组合子 IKS 的类型为</p><p>$\lambda x:\alpha.x : \alpha\to\alpha$ <strong>(I)</strong></p><p>$\lambda x:\alpha.\lambda y:\beta.x:\alpha \to \beta \to \alpha$ (<strong>K</strong>)</p><p>$\lambda x:\alpha\to\beta\to\gamma.\lambda y:\alpha\to\beta.\lambda z:\alpha.x z (y z) : (\alpha\to\beta\to\gamma)\to(\alpha\to\beta)\to\alpha\to\gamma$  (<strong>S</strong>)</p><p>注意有不少类型是简单类型不能表达的。比如 <code>call/cc</code> 柯里-霍华德同构于皮尔士定律，这在直觉逻辑中是不成立的。所以 <code>call/cc</code> 不能居留。</p><p>函数类型是一种值依赖值的例子。</p><h2 id="和类型与积类型"><a href="#和类型与积类型" class="headerlink" title="和类型与积类型"></a>和类型与积类型</h2><p>在简单类型的入演算（$\lambda^\to$）引入类型操作符就会变成带类型操作符的简单类型入演算（$\lambda\underline\omega$）</p><p>普通的函数是一种操作值的操作符。</p><p>类似的，接收类型为参数返回类型的函数成为类型操作符。</p><p>有很多类型操作符，所以也会产生很多类型。这里主要提两种类型和类型与积类型。</p><p>很多编程语言使用 null 或者类似的原语来表达缺少值的情况。</p><p>但这会有两个问题。</p><p>一个是 null 只适用于引用类型，如果是值类型比如 int ，那么该怎么表示缺少值的情况呢？</p><p>有些人会取一个范围外的值比如对于输入一定是整数的情况的下可以取 -1 用于表达缺少值。</p><p>在输入包含负数的情况下不能用，这就很尴尬了。</p><p>值类型还好，错误的输入最多是得到错误的值，而引用类型就不一样了。</p><p>如果使用了 null 就必须检查，否则可能会因为空引用而崩溃。</p><p>而且使用了 null 相当于绕过了类型系统的检查，是不是 null 只能在运行时确定，做不到检查出 null 而编译失败。</p><p>理论上只要做了空检查就不会有问题，但是在复杂的数据结构嵌套中很容易就忘了对某个成员的检查。</p><p>这样的感觉像是写动态类型一样，觉得应该是没问题的，最后运行代码然后祈祷不要出错。</p><p>Haskell 中使用 Maybe 类型操作符来表达缺少值的情况。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a  <span class="comment">-- a 为类型参数</span></span></span><br></pre></td></tr></table></figure><p>注意到 a 为类型变量，可以是 Int，String，Char 等。例如</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="type">Just</span> <span class="number">84</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Maybe</span> t</span><br></pre></td></tr></table></figure><p>使用 Maybe 必须检查是否为 Nothing 否则编译失败。不过检查的过程是自动的（多亏了 Monad 和 do-notation）。</p><p>引入 null 不是错误，错误的是没有强制检查 null （C# 可以使用 <code>?.</code> 和 <code>??</code> 简化检查）。</p><p>当 a 为 Int 时 Maybe 返回 Maybe Int 。</p><p>Maybe Int 是什么类型呢。其实是一种和类型，是 Int + Nothing 。</p><p>所以 Maybe 之所以能表达缺少值的情况是因为它可以容纳两种类型。</p><p>类似的，积类型可以用 <code>(,)</code> 操作符或者 <code>std::pair</code> 生成。</p><p>$(A, B)$ 的类型是 A 类型和 B 类型的笛卡儿积 $A \times B$ 。</p><p>类型操作符是一种类型依赖类型的例子。 </p><h2 id="多态类型"><a href="#多态类型" class="headerlink" title="多态类型"></a>多态类型</h2><p>在简单类型的入演算（$\lambda^\to$）引入全称量词（$\forall$）就会变成二阶入演算（$\lambda2$），又称为系统 F 。</p><p>引入 $\forall$ 后获得多态的能力。系统 F 的多态是参数化多态。</p><p>参数化多态类似于泛型。比如对于 <code>List&lt;T&gt;</code> 有</p><p>$length: \forall T.[T] \to int$ </p><p>注意到 <code>length</code> 是 Rank-1 类型。但有的函数可能是 Rank-2 类型。</p><p>比如 $(\forall a.a \to a) \to (\forall b.b \to b)$  就是 Rank-2 类型。</p><p>但不是有 N 个全称量词就是 Rank-N 类型。</p><p>$\forall a. a \to (\forall b.b \to a)$ 是 Rank-1 类型。</p><p>因为可以规约为 $\forall a b . a \to b \to a$ 。</p><p>通常的类型系统是 Rank-1 类型。系统 F 支持 Rank-N 类型。</p><p>Haskell 的类型系统 Hindley–Milner 类型系统是一种带类型类的系统 F 。默认是 Rank-1 ，需要手动开启 Rank-N 。</p><p>比如要使用代替 getter / setter 的光学棱镜组就要开启 Rank-N 。</p><p>除了参数化多态，还有特设多态。</p><p>特设多态是指一个多态函数有多种实现，依赖于参数的类型，调用相应的版本，类似于面向对象中的重载（overload）。</p><p>所以特设多态只能支持有限数量的类型。而参数化多态更为通用。</p><p>多态类型是一种值依赖类型的例子。</p><h2 id="依赖类型"><a href="#依赖类型" class="headerlink" title="依赖类型"></a>依赖类型</h2><p>容器类型除了元素类型还跟长度有关，不同长度的同元素类型构成了一个容器簇。</p><p>如果把长度当作容器类型构造器的参数，那么就形成了依赖类型。</p><p>依赖类型分为依赖乘积类型（Π-类型）和依赖总和类型（Σ-类型）。</p><p>依赖乘积类型可以写作 $\displaystyle \Pi (x:A),B(x)$ ，当 $B$ 为常数时，即 $\displaystyle \Pi {(x:A)},B$ ，退化为函数类型 $A \to B$</p><p>依赖总和类型可以写作 $\displaystyle \Sigma {(x:A)},B(x)$ ，当 $B$ 为常数时，即 $\displaystyle \Sigma {(x:A)},B$ ，退化为乘积类型 $A \times B$</p><p>依赖类型使得容器类型长度变成了一种约束。</p><p>例如对于元素类型为 T，长度为 n 的 <code>List</code> 类型 $List(T,n)$ ，它的 <code>append</code> 操作类型为</p><p>$append : List(T,n) \to List(T,m) \to List(T,m + n)$ </p><p>如果最后返回值长度不是 $m+n$ 就会被编译器踢屁股，编译失败。</p><p>这样尽可能用类型表达更多的约束，将逻辑问题扑灭在编译期，就能写出更正确的程序。</p><p>毕竟业务逻辑应该写在函数类型里，你之所以要写函数实现是因为编译器还没有聪明到自动做 $\beta$ 规约啊科科。</p><p>依赖类型是一种类型依赖值的例子。</p><p>这样就集齐了值和类型的四种关系。</p><p>简单类型($\lambda^\to$)是<strong>值</strong>依赖<strong>值</strong>的关系。</p><p>带类型操作符的简单类型($\lambda\underline\omega$)是<strong>类型</strong>依赖<strong>类型</strong>的关系。</p><p>二阶入演算（$\lambda2$）是<strong>值</strong>依赖<strong>类型</strong>的关系。</p><p>依赖类型（$\lambda P$）是<strong>类型</strong>依赖<strong>值</strong>的关系。</p><p>以 $\lambda^\to$ 为原点，其他三种关系为基底，就得到了常见类型系统的入立方。</p><p><img src="/img/AboutType/Lambda_cube.png" alt="入立方"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随便说一说类型。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="类型" scheme="http://en.ors-sro.com/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>非对称加密</title>
    <link href="http://en.ors-sro.com/asymmetric-cryptography/"/>
    <id>http://en.ors-sro.com/asymmetric-cryptography/</id>
    <published>2017-05-14T10:23:50.000Z</published>
    <updated>2017-12-10T04:02:54.769Z</updated>
    
    <content type="html"><![CDATA[<p>非常有趣的思想。</p><a id="more"></a><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>为什么要加密呢？因为有些羞羞的东西不想让他人看到。</p><p>比如甲给乙传小纸条，必须要经过捣蛋鬼的手中。如果不加密，捣蛋鬼就会知道其中的内容，然后发出嘿嘿嘿的猥琐笑声。BAD ENDING 1</p><p>甲和乙都很无语。所以他们决定以后发消息的时候要加密。</p><p>甲把信息加密后写在小纸条上，传给乙。</p><p>捣蛋鬼即使在途中看到了也没有办法知道里面的内容。HAPPY ENDING (DREAMING)</p><p>但是现实很残忍，甲和乙不能私下接触，所以只能通过传小纸条的方式来交换信息。</p><p>那么加解密用的密钥，甲该怎么传给乙呢？</p><p>假设甲把密钥加密后传给乙，乙不知道加密过后的密钥怎么解密。看不懂。BAD ENDING 2</p><p>假设甲把没加密的密钥传给乙，捣蛋鬼也知道了密钥，甲再发羞羞的内容给乙时，捣蛋鬼用已知的密钥解密，再次发出嘿嘿嘿的猥琐笑声。BAD ENDING 3</p><p>甲感到很绝望。不加密会被偷窥。加密了也会被偷窥。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>甲在想如果加密和解密用的不是同一个密钥，那么这样就不怕被偷窥了。那要怎么做呢？</p><p>后来老师在密码学课上讲了方法。</p><p>甲准备两个密钥，这两个密钥有这样的特点，知道一个密钥不能推出另外一个密钥，但是两个密钥对于某些数学运算能得到相同的结果，也就是一个密钥加密的文本只能用另外一个密钥解密。</p><p>甲随机选择一个密钥，不加密，写在小纸条上传给乙。捣蛋鬼和乙一看这乱七八糟的数字一定是密钥，这个密钥已经公开了。所以称为公钥。剩下那个没公开的称为私钥。</p><p>乙心神领会后，也把公钥发给了甲。</p><p>这样两轮信息交换后</p><p>甲知道了乙的公钥、甲的公钥、甲的私钥。</p><p>乙知道了甲的公钥、乙的公钥、乙的私钥。</p><p>捣蛋鬼知道了甲的公钥和乙的公钥。</p><p>甲用乙的公钥加密羞羞的东西，发给乙。</p><p>捣蛋鬼看到莫名其妙的东西，知道是被加密了。但是乙的公钥不能解密，能解密的只有乙的私钥。捣蛋鬼并不知道乙的私钥。只好放行。传给乙。</p><p>乙收到密文后，用乙的私钥解密，看到了羞羞的东西，决定回复甲。</p><p>乙用甲的公钥加密回复，发给甲。</p><p>捣蛋鬼再次看到莫名其妙的东西，知道肯定又是加密了。而且肯定使用甲的公钥加密了。因为如果用乙的公钥加密，甲没有乙的私钥没有办法解密。捣蛋鬼没有甲的私钥，不能解密，只好放行。</p><p>甲收到密文后用甲的私钥解密。看到了回复。 HAPPY ENDING</p><p>在上述两个例子中，有两种加密方式。</p><p>加密和解密用的是同一个密钥，这叫对称加密。</p><p>相应地，加密和解密用的不是同一个密钥，这叫非对称加密。</p><p>对称加密很容易做到。那么非对称加密是怎么做到密钥不一样还能解密的呢？</p><p>有好几种方法，比如有一种方法是这样的。</p><p>在数学运算中，有些运算会产生信息丢失，也就是即便知道了运算结果也不一定能推出运算前的数。</p><p>比如对于取膜 $\bmod$ </p><p>$3 \bmod 2 = 1$  。如果只知道运算结果是 $1$ 是不能确定运算前是 $3$ 的，因为有可能是 $1, 3, 5, 7, 9\dots$ 中的任何一个。</p><p>虽然不知道原来的数，但是只要知道数学关系就能得到相同的结果。比如只要奇数模 2 都会等于 1 。</p><p>所以可以这么做。</p><p>甲先公开生成密钥的两个常数 $g = 5$ 和 $p = 23$ 。</p><p>甲随机选取一个数字 $a$ 比如 $a = 6$ ，算出公钥 $A = g^a \bmod p = 5^6 \bmod 23 = 8$</p><p>甲把公钥 $A = 23$ 发给乙，把私钥 $a = 6$ 偷偷藏起来。</p><p>捣蛋鬼知道了 $5^? \bmod 23 = 8$ ，但是推不出甲的私钥 $a$ 。</p><p>乙随机选取一个数字 $b$ 比如 $b = 15$ ，算出公钥 $B = g^b \bmod p = 5^{15} \bmod 23 = 19$</p><p>乙把公钥 $B = 19$ 发给甲，把私钥 $b = 15$ 偷偷藏起来。</p><p>捣蛋鬼知道了 $5^? \bmod 23 = 19$ ，但是推不出乙的私钥 $b$ 。</p><p>因为 $(g^a)b = (g^b)^a$ 所以 $(g^a)^b \bmod p = (g^b)^a \bmod p$ </p><p>由于取模的性质有</p><p>$(g^a)^b \bmod p = A^b \bmod p$</p><p>$(g^b)^a \bmod p = B^a \bmod p$</p><p>所以</p><p>$A^b \bmod p = B^a \bmod p$</p><p>也就是甲可以通过甲的私钥和乙的公钥组合来解密，不能只通过乙的公钥来解密。</p><p>同样，乙可以通过乙的私钥和甲的公钥组合来解密，不能只通过甲的公钥来解密。</p><p>在实际应用中通常选择比较大的数防止暴力穷举。</p><p>因为非对称加密相比于对称加密较慢，所以通常使用非对称加密传递对称加密的密钥后使用对称加密通信。</p><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>以上情况建立在捣蛋鬼没有好好听课的前提下。实际上捣蛋鬼刚好认真听了老师那节介绍非对称加密的课。</p><p>于是甲传递甲的公钥时，捣蛋鬼替换为捣蛋鬼的公钥。</p><p>乙收到捣蛋鬼的公钥后发出乙的公钥。</p><p>捣蛋鬼收到乙的公钥后替换为捣蛋鬼的公钥。</p><p>甲收到捣蛋鬼的公钥后，用捣蛋鬼的公钥加密羞羞的东西，发给乙。</p><p>捣蛋鬼收到加密的内容后，用捣蛋鬼的私钥解密后看到羞羞的内容。发出嘿嘿嘿的猥琐笑声。BAD ENDING 4</p><h2 id="应对非对称加密"><a href="#应对非对称加密" class="headerlink" title="应对非对称加密"></a>应对非对称加密</h2><p>如果文件被非对称加密（如 RSA）加密了。有什么办法解密吗？</p><p>目前能想到的有以下几种方法。</p><ol><li>暴力穷举，假设你有银河超级计算器的话。</li><li>获取私钥，假设你可以有资本色诱或威胁的话。</li><li>找到快速的大质数分解方式，顺便拿个炸药奖。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在现实生活中，甲传纸条给乙，经过捣蛋鬼的手，捣蛋鬼噌地站起来指着甲说：“老师他上课传纸条！”。REAL ENDING </p><p>参考链接</p><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">公开密钥加密</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">迪菲-赫爾曼密鑰交換</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常有趣的思想。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="密码学" scheme="http://en.ors-sro.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于原型的面向对象</title>
    <link href="http://en.ors-sro.com/Prototype-base-object-oriented-programming/"/>
    <id>http://en.ors-sro.com/Prototype-base-object-oriented-programming/</id>
    <published>2017-05-07T11:50:45.000Z</published>
    <updated>2017-12-17T04:54:11.227Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象不必基于类。</p><a id="more"></a><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>ES6 引入基于类的对象声明方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeDPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, z)&#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">', '</span> + <span class="keyword">this</span>.z + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这只是为了照顾 Java 和 C++ 程序员而引入的语法糖。底层面向对象的实现没有改变。</p><h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>ES5 之前的对象声明是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>继承的方式很灵活，根据不同的目的有不同的写法。</p><p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">JavaScript 继承</a></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>面向对象强调的是对象，而不是类。所以没有叫面向类编程。</p><p>面向对象的实现方式除了基于类的方式，还有基于原型的方式。</p><p>基于原型的方式能够实现基于类的方式，如 ES6 引入的语法糖。</p><p>而基于类的实现方式大部分不能实现基于原型的方式。因为大部分的语言类型层级是静态的。</p><p>也就是说在编译的时候类型继承树是已经确定的，运行的时候不能更改继承关系。</p><p>而基于原型的方式在运行的时候可以更改继承关系。更改 <code>prototype</code> 即可。</p><p>基于类的面向对象编程经常有基本类型难以更改的问题。这是因为类型继承树是定死的，后期改起来影响很大。</p><p>比如你有一个列表的基本组件 <code>ListBase</code> 。所有列表继承它。</p><p>如果你想来一个新的列表跟 <code>ListBase</code> 表现不一致，那么就要重载其中不一致的部分。</p><p>如果被重载的函数太长，或者里面引用了私有变量，就很难实现。</p><p>这时候要么改 <code>ListBase</code> 要么把 <code>ListBase</code> 的代码复制一遍，重新做一个 <code>NewListBase</code>。</p><p>改动 <code>ListBase</code>，因为用到的地方很多，无法保证不会出问题。</p><p>复制一遍，如果 <code>ListBase</code> 改动很难同步。也是产生代码腐臭的经典方式。</p><p>如果是用原型的方式，直接继承 <code>prototype</code> 。然后改想要改的部分就可以了。</p><p>相当于复制了代码，但是这段复制的代码是在运行的时候复制出来的。所以 <code>ListBase</code> 的改动都会同步。</p><p>基于原型的继承最大的缺点是接受了基于类继承的先入为主后很难理解。</p><p>基于原型的继承在代码中没有类的概念，所有类的概念都是人为为了模拟基于类的面向对象而产生的。</p><p>基于原型的继承只有对象的复制和修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象不必基于类。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="JavaScript" scheme="http://en.ors-sro.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
