<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拖鞋党的拖鞋摊</title>
  <subtitle>写一些有的没的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://en.ors-sro.com/"/>
  <updated>2017-06-18T13:16:47.631Z</updated>
  <id>http://en.ors-sro.com/</id>
  
  <author>
    <name>拖鞋党</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>柯里-霍华德同构</title>
    <link href="http://en.ors-sro.com/Curry-Howard-correspondence/"/>
    <id>http://en.ors-sro.com/Curry-Howard-correspondence/</id>
    <published>2017-06-18T13:08:03.000Z</published>
    <updated>2017-06-18T13:16:47.631Z</updated>
    
    <content type="html"><![CDATA[<p>这真的只是一种巧合吗？</p>
<a id="more"></a>
<h2 id="命题与类型">命题与类型</h2><p>一个函数的类型可以是 <code>A -&gt; B -&gt; A</code> 。</p>
<p>一个命题的类型可以是 $\alpha \to \beta \to \alpha$ 。</p>
<p>可以发现，这两个类型是类似的。</p>
<p>类型 <code>A</code> 类似于命题 $\alpha$ 。</p>
<p>函数 <code>-&gt;</code> 类似于蕴含 $\to$ 。</p>
<p>实际上这是柯里-霍华德同构。</p>
<h2 id="定义">定义</h2><p><strong>柯里-霍华德同构</strong>揭示了计算机程序和数学证明之间的紧密联系。</p>
<p>类型即命题，程序即证明。</p>
<p>也就是函数的类型相当于命题，函数的实现相当于证明。这在 Coq 中体现得很明显。</p>
<p>用 <a href="https://www.zhihu.com/people/be5invis/answers" target="_blank" rel="external">be5</a> 大大<a href="https://zhihu.com/question/22959608/answer/24770830" target="_blank" rel="external">一针见血的解释</a>来说就是</p>
<blockquote>
<p>Lambda 演算同构为 Gentzen 的自然演绎</p>
<ul>
<li>函数调用就是蕴含消除</li>
<li>函数抽象就是蕴含介入</li>
<li>参数多态就是全称量化</li>
<li>模板类型就是谓词</li>
<li>结构类型就是合取</li>
<li>联合类型就是析取</li>
<li>收参数但不返回就是否定</li>
<li>高洋上的 call/cc 就是双重否定消除</li>
</ul>
</blockquote>
<h2 id="详述">详述</h2><p>函数调用的规则是<br>$$<br>{\Gamma\vdash t:\sigma\to\tau\quad\Gamma\vdash u:\sigma}\over{\Gamma\vdash t\,u : \tau}<br>$$<br>结果从 $\sigma\to\tau$ 变成 $\tau$ ，少了蕴含 $\to$ 所以称为蕴含消除。</p>
<p>相应的函数调用的逆操作函数抽象的规则是<br>$$<br>{\Gamma,x:\sigma\vdash t:\tau}\over{\Gamma\vdash \lambda x : \sigma.t : \sigma \to \tau}<br>$$<br>结果从 $\tau$ 变成 $\sigma\to\tau$ ，多了蕴含 $\to$ 所以称为蕴含介入。</p>
<p>参数多态实际上是对于某个参数不限制类型，相当于逻辑量词 $\forall$ ，也就是全称量化。</p>
<p>联合类型，例如 <code>Maybe Int</code> ，表示可能是 <code>Int</code> 或者是 <code>Nothing</code> 。关系是<strong>或</strong>，也就是析取。</p>
<p>相应地，结构类型表示可以同时是多个类型，关系是<strong>且</strong>，也就是合取。</p>
<p>对于接受参数而不返回的函数，或者返回 Unit 的函数，实际上类似于 $A \to \bot$ ，返回一个底。 </p>
<p>CPS 转换对应的是双重否定转换，也就是双重否定介入。</p>
<p>相应地，<code>call/cc</code> 对应的是双重否定消除。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这真的只是一种巧合吗？&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="同构" scheme="http://en.ors-sro.com/tags/%E5%90%8C%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Coq  入门学习笔记 （1）</title>
    <link href="http://en.ors-sro.com/Coq-Notes-1/"/>
    <id>http://en.ors-sro.com/Coq-Notes-1/</id>
    <published>2017-06-11T08:11:55.000Z</published>
    <updated>2017-06-11T08:20:58.300Z</updated>
    
    <content type="html"><![CDATA[<p>鸡年当然要学习鸡语言啦。</p>
<a id="more"></a>
<h1 id="简介">简介</h1><p><a href="https://zh.wikipedia.org/wiki/Coq" target="_blank" rel="external">Coq</a> 是一个基于<a href="https://zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E6%BC%94%E7%AE%97" target="_blank" rel="external">构造演算</a>的定理证明辅助工具。</p>
<p>在开始玩耍之前需要到官网<a href="https://coq.inria.fr/download" target="_blank" rel="external">下载 Coq</a></p>
<p>安装完成后打开 Coq 的 REPL —— Coq.exe 。</p>
<p>打开后能看到类似内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Coq 8.6 (December 2016)&#10;&#10;Coq &#60;</span><br></pre></td></tr></table></figure>
<p>输入 <code>&quot;Hello World&quot;.</code> 打印 Hello World 。</p>
<p>然而并没有什么 Hello World :P 。</p>
<h2 id="普通的引理">普通的引理</h2><p>先来证明一个普通的引理，算是 Hello World 吧。</p>
<p>在 Coq 中输入一下内容。 被 <code>(*</code> 和 <code>*)</code> 括起来的是注释不用输入。  <code>Coq &lt;</code> 也不用输入。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coq &#60; Section Minimal_Logic. (* &#20197;&#28857;&#21495;&#32467;&#23614;&#65292;&#31867;&#20284; C &#35821;&#35328;&#30340;&#20998;&#21495; *)&#10;&#10;Coq &#60; Variables A B C : Prop. (* &#27809;&#36755;&#20837;&#28857;&#23601;&#25442;&#34892;&#20102;&#21482;&#38656;&#36755;&#20837;&#28857;&#28982;&#21518;&#25442;&#34892; *)&#10;A is assumed&#10;B is assumed&#10;C is assumed&#10;&#10;Coq &#60; Goal (A -&#62; B -&#62; C) -&#62; (A -&#62; B) -&#62; A -&#62; C.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  ============================&#10;  (A -&#62; B -&#62; C) -&#62; (A -&#62; B) -&#62; A -&#62; C&#10;&#10;Unnamed_thm &#60; auto.&#10;No more subgoals.</span><br></pre></td></tr></table></figure>
<p>证明完毕！到此结束，手动再见。</p>
<h2 id="简单的过程">简单的过程</h2><p>既然愿意了解，那么就一步步来。先撤销证明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; Undo. &#65288;* U &#26159;&#22823;&#20889; *&#65289;&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  ============================&#10;  (A -&#62; B -&#62; C) -&#62; (A -&#62; B) -&#62; A -&#62; C</span><br></pre></td></tr></table></figure>
<p>输出的内容中 1 subgoal 说明只有一个目标需要证明</p>
<p><code>A, B, C : Prop</code> 表示 A B C 都是 Prop 。Prop 是命题 （<strong>Prop</strong>osition）的缩写。</p>
<p><code>============================</code> 是分割线。上面的内容是假设和条件。下面的内容是需要证明的部分。</p>
<p><code>(A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C</code> 需要证明的内容。 用 <code>()</code> 括起来表示视为一个整体， <code>-&gt;</code> 为蕴涵。</p>
<p><code>A -&gt; B</code> 读作若 A 则 B。</p>
<p>接下来为了方便证明，需要引入一些假设。</p>
<p>使用 <code>intro</code> 引入<strong>一个</strong>假设。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; intro H.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  ============================&#10;  (A -&#62; B) -&#62; A -&#62; C</span><br></pre></td></tr></table></figure>
<p>引入了假设 <code>H : A -&gt; B -&gt;C</code> 。证明的目标就变成了 <code>(A -&gt; B) -&gt; A -&gt; C</code>。</p>
<p>还可以引入多个假设。</p>
<p>多个假设使用 <code>intros</code> 就是 <code>intro</code> 加了 s 。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; intros H&#39; HA.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  H&#39; : A -&#62; B&#10;  HA : A&#10;  ============================&#10;  C</span><br></pre></td></tr></table></figure>
<p>现在需要证明的目标变成了 <code>C</code> 。</p>
<p>观察已有条件，发现假设 <code>H : A -&gt; B -&gt; C</code> 蕴涵 <code>C</code>。当然演绎出 <code>C</code> 还需要 <code>A -&gt; B</code> 。</p>
<p>可以先应用假设，转化证明的目标。</p>
<p>应用假设使用 <code>apply</code> </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; apply H.&#10;2 subgoals&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  H&#39; : A -&#62; B&#10;  HA : A&#10;  ============================&#10;  A&#10;&#10;subgoal 2 is:&#10; B</span><br></pre></td></tr></table></figure>
<p>现在目标变成了两个，一个 <code>A</code> 一个 <code>B</code> 。</p>
<p>观察已有条件，<code>A</code> 刚好是假设 <code>HA : A</code> 。</p>
<p>使用 <code>exact</code> 表示刚好。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; exact HA.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  H&#39; : A -&#62; B&#10;  HA : A&#10;  ============================&#10;  B</span><br></pre></td></tr></table></figure>
<p>现在目标变成了 <code>B</code> 。</p>
<p>观察已有条件，假设 <code>H&#39; : A -&gt; B</code> 蕴含了 <code>B</code> 。</p>
<p>那么应用 <code>H&#39;</code> 即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; apply H&#39;.&#10;1 subgoal&#10;&#10;  A, B, C : Prop&#10;  H : A -&#62; B -&#62; C&#10;  H&#39; : A -&#62; B&#10;  HA : A&#10;  ============================&#10;  A</span><br></pre></td></tr></table></figure>
<p>现在目标变成了 <code>A</code>。</p>
<p>之前已经证明了 <code>A</code> 。这里可以用 <code>exact HA.</code> 。</p>
<p>也可以直接总结，表示目标已经证明。</p>
<p>总结使用 <code>assumption</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; assumption.&#10;No more subgoals.</span><br></pre></td></tr></table></figure>
<p><code>No more subgoals</code> 说明没有需要证明的目标了。证明结束。</p>
<p>证明可以使用 <code>Save</code> 保存。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed_thm &#60; Save trivial_lemma.&#10;intro H.&#10;(intros H&#39; HA).&#10;(apply H).&#10; exact HA.&#10;&#10; (apply H&#39;).&#10; assumption.&#10;&#10;Save trivial_lemma.&#10;trivial_lemma is defined</span><br></pre></td></tr></table></figure>
<p>中间的部分就是证明的过程。</p>
<h2 id="最后">最后</h2><p>这次就简单的写个 Hello World 的笔记。<a href="https://coq.inria.fr/tutorial/1-basic-predicate-calculus" target="_blank" rel="external">后面的内容</a>还需要慢慢整理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鸡年当然要学习鸡语言啦。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Coq" scheme="http://en.ors-sro.com/tags/Coq/"/>
    
  </entry>
  
  <entry>
    <title>用 Flashdevelop 调试 ActionScript</title>
    <link href="http://en.ors-sro.com/Debug-As-in-Flashdevelop/"/>
    <id>http://en.ors-sro.com/Debug-As-in-Flashdevelop/</id>
    <published>2017-06-04T07:20:42.000Z</published>
    <updated>2017-06-10T12:52:32.384Z</updated>
    
    <content type="html"><![CDATA[<p>就算是过气的语言也有使用场景啊（页游）。</p>
<a id="more"></a>
<p>FlashDevelop 调试还要装杂七杂八的东西。</p>
<p>配置过程如下</p>
<h2 id="安装_Java">安装 Java</h2><p>因为大多数人的 FlashDevelop 用的是 32 位版，所以需要下载 32 位版的 Java</p>
<p><a href="https://www.java.com/zh_CN/download/manual.jsp" target="_blank" rel="external">https://www.java.com/zh_CN/download/manual.jsp</a></p>
<p><img src="/img/DebugAsInFlashdevelop/SelectJava.png" alt="SelectJava"></p>
<p>安装完成后打开命令行输入 <code>java</code> 应该返回类似画面</p>
<p><img src="/img/DebugAsInFlashdevelop/Java.png" alt="Java"></p>
<p>如果不是这样，需要<a href="https://jingyan.baidu.com/article/925f8cb836b26ac0dde0569e.html" target="_blank" rel="external">配置 Java_Home 环境变量</a></p>
<p>环境变量生效需要<strong>重启</strong></p>
<h2 id="安装_Flex_SDk">安装 Flex SDk</h2><p>打开 FlashDevelop -&gt; Tool -&gt; Install Software…</p>
<p>勾选 <strong>Flex SDK(OLD)</strong> </p>
<p><img src="/img/DebugAsInFlashdevelop/InstallSDK.png" alt="InstallSDK"></p>
<p>点击 <strong>Install 1 items</strong> 安装</p>
<p>安装完成后<strong>重启 FlashDevelop</strong></p>
<p>如果提示找不到 SDK 描述文件，则需要从刚装好的 SDK 目录下复制 <strong>flex-sdk-description.xml</strong> （可以用 everything 查找）到提示的路径中。</p>
<p><img src="/img/DebugAsInFlashdevelop/Warning.png" alt="Warning"></p>
<p>复制后<strong>重启 FlashDevelop</strong></p>
<h2 id="配置工程">配置工程</h2><p>打开 FlashDevelop -&gt; Project -&gt; Propperties</p>
<p><strong>Compilation Target</strong> 选为 <strong>Other IDE</strong></p>
<p><strong>Test Project</strong> 选为 <strong>Play: External Player</strong></p>
<p><img src="/img/DebugAsInFlashdevelop/ExternalPlayer.png" alt="SelectExternalPlayer"></p>
<p><strong>Install SDK(s)</strong> 选为 <strong>Flex</strong></p>
<p><img src="/img/DebugAsInFlashdevelop/SelectSDK.png" alt="SelectSDK"></p>
<h2 id="配置外部播放器">配置外部播放器</h2><p>打开 FlashDevelop -&gt; Programs Settings… -&gt; 往下拖动找到 FlashViewer</p>
<p>设置 <strong>External Player Path</strong> 为 <code>C:\Program Files (x86)\Adobe\Adobe Flash CS6\Players\Debug\FlashPlayerDebugger.exe</code></p>
<p><img src="/img/DebugAsInFlashdevelop/SetExternalPlayer.png" alt="SetExternalPlayer"></p>
<h2 id="开始调试">开始调试</h2><p>打开想要调试的 <strong>FLA</strong> ，在 FlashDevelop 中打开相应的 as 文件，下个能运行到的断点。</p>
<p>点击运行（F5），Happy Debugging！</p>
<p><img src="/img/DebugAsInFlashdevelop/Play.png" alt="Play"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就算是过气的语言也有使用场景啊（页游）。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="ActionScript" scheme="http://en.ors-sro.com/tags/ActionScript/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下安装 Emacs+Sbcl+Slime</title>
    <link href="http://en.ors-sro.com/Install-Emacs-Sbcl-and-Slime/"/>
    <id>http://en.ors-sro.com/Install-Emacs-Sbcl-and-Slime/</id>
    <published>2017-05-28T10:04:02.000Z</published>
    <updated>2017-05-28T10:17:35.379Z</updated>
    
    <content type="html"><![CDATA[<p>旧文重发，略作修改</p>
<a id="more"></a>
<h2 id="前言">前言</h2><p>其实网上已经有很多类似的文章了，我也是按照上面的来做。在做的过程中会遇到几个很坑的地方，我自己也是折腾了好久才弄好。所以现在写出来希望能对大家有所帮助。</p>
<h2 id="正文">正文</h2><h3 id="下载和安装_Emacs">下载和安装 Emacs</h3><p><a href="http://ftp.gnu.org/gnu/emacs/windows/emacs-24.3-bin-i386.zip" target="_blank" rel="external">http://ftp.gnu.org/gnu/emacs/windows/emacs-24.3-bin-i386.zip</a> </p>
<p>解压运行安装</p>
<h3 id="下载_Sbcl">下载 Sbcl</h3><p><a href="http://www.sbcl.org/platform-table.html" target="_blank" rel="external">http://www.sbcl.org/platform-table.html</a></p>
<p>选 Windows 和你的架构。如果不知道的话就选 X86 就行了。</p>
<h3 id="下载_Slime">下载 Slime</h3><p><a href="https://github.com/slime/slime" target="_blank" rel="external">https://github.com/slime/slime</a></p>
<p>如果你有 github 帐户就直接 git clone 吧。如果没有的话，点 download zip 然后解压。 </p>
<h3 id="安装Sbcl">安装Sbcl</h3><p>双击安装包，改一下安装路径到你想安装的地方。但是这里有一个坑。</p>
<p><strong>坑1：系统变量重启才会更新</strong></p>
<p>这是因为在安装的过程中会给系统加一个 Sbcl 路径的变量。</p>
<p>所以一定要安装完后重启，不然就会提示</p>
<blockquote>
<p>fatal error encountered in SBCL pid 10236(tid 9971200):<br>can’t find core file at XXXXX</p>
</blockquote>
<p>安装成功的标志是运行 sbcl.exe 会出现类似这样的界面：</p>
<p><img src="/img/InstallEmacsSbclandSlime/sbcl.png" alt="运行 sbcl"></p>
<h3 id="配置_Emacs">配置 Emacs</h3><p>本来在 Linux 下配置 Emacs 是一件简单的事，但在 Windows 下就不那么容易了。因为 Windows 文件名命名机制这里有一个坑。</p>
<p><strong>坑2:找不到 Emacs 的配置文件 .emacs</strong></p>
<p>这是因为 Windows 允许这样的命名规则，也是就不允许只有扩展名而没有文件名（在 Windows 看来是 .emacs 非法的，必须是 XXX.emacs 才是合法的。Linux 则是看成一个隐藏文件而已）</p>
<p>所以要做的第一步是生成 .emacs 配置文件</p>
<p>原理是通过修改选项之后点保存选项会生成 .emacs 配置文件</p>
<p>方法很简单。在 Emacs 目录下双击 runemacs.exe 打开 emacs</p>
<p>然后在菜单栏里点 Options——Show/Hide——tool-bar</p>
<p>之后点 Options——Save options</p>
<p>这样就会在 <code>C:\Users\你的用户名\AppData\Roaming</code> 下生成一个 .emacs</p>
<p>打开 .emacs 输入以下内容以配置 Slime</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">setq</span> inferior-lisp-program <span class="string">"sbcl路径"</span>)</span><span class="comment">; 设置优先使用哪种 Common Lisp 实现</span></span><br><span class="line"><span class="list">(<span class="keyword">add-to-list</span> <span class="variable">'load-path</span> <span class="string">"slime路径"</span>)</span><span class="comment">; 设置 Slime 路径</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">require</span></span> <span class="variable">'slime</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">slime-setup</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">require</span></span> <span class="variable">'slime-autoloads</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">slime-setup</span> '<span class="list">(<span class="keyword">slime-fancy</span>)</span>)</span><span class="comment">; 让 slime 变得更好看，比如把 sbcl 的*变成 CL-USER&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中路径使用<code>/</code>或者<code>//</code>分隔</p>
<p>这其中有一个坑需要小心</p>
<p><strong>坑3：sbcl 的路径一定要写到 sbcl.exe 不然会提示</strong></p>
<blockquote>
<p>Specified program for new process is a directory</p>
</blockquote>
<p>这个真的是深坑啊。当时我花了不少时间才折腾好</p>
<p>原理就是 slime 调用的时候不会从你填的路径找到 sbcl.exe 而是需要给出 sbcl.exe 的完整路径</p>
<p>我的 .emacs 配置是这样的</p>
<p><img src="/img/InstallEmacsSbclandSlime/emacs-setting.png" alt="Emacs 配置"></p>
<p>打开 Emacs 按 M-x（window下就是Alt+x）输入 slime 之后会出现像这样的</p>
<p><img src="/img/InstallEmacsSbclandSlime/run-emacs.png" alt="运行 Slime"></p>
<p>输入<code>&quot;Hello Common Lisp!&quot;</code> 一声长叹</p>
<p><img src="/img/InstallEmacsSbclandSlime/hello-world.png" alt="Hello World"></p>
<h2 id="后记">后记</h2><p>一些常用的 Slime 快捷键</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-k 编译当前文件 （也就是Ctrl+c后再Ctrl+k） </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-c 增量编译（这是我自己的理解） </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-z 切换到Slime </span><br><span class="line"><span class="keyword">C</span>-c <span class="keyword">C</span>-l 加载文件</span><br></pre></td></tr></table></figure>
<p>当然以上快捷键都可以再 .emacs 里面改。</p>
<p>PS:我的配色是 solarized 字体是 Monaco</p>
<p>PSS：以上 Vim 的配色。Emacs 的配色是自带的 dichromacy</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;旧文重发，略作修改&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="Emacs" scheme="http://en.ors-sro.com/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>侃类型</title>
    <link href="http://en.ors-sro.com/About-Type/"/>
    <id>http://en.ors-sro.com/About-Type/</id>
    <published>2017-05-21T06:34:24.000Z</published>
    <updated>2017-06-18T13:19:47.451Z</updated>
    
    <content type="html"><![CDATA[<p>随便说一说类型。</p>
<a id="more"></a>
<h2 id="类型的作用">类型的作用</h2><p>如果用记事本写一段程序，就会发现两个问题。</p>
<p>一个是没有代码提示，一个变量点出来的变量也不知道存不存在。</p>
<p>另一个是很容易编译失败，因为可能会发生一些不符合类型的问题。</p>
<p>有了类型能够避免手误，编辑器会提示不存在相应的成员变量。从而更早的发现问题。</p>
<p>使用类型可以显式地表达一种约束。比如加减乘除需要数字，如果传入了字符串就可以在编译期报错，而不是等到运行时才出错。</p>
<p>许许多多的类型组成了类型系统。类型系统按不同的维度可以分为好几种。</p>
<h2 id="强类型和弱类型">强类型和弱类型</h2><p>如果一个类型系统允许隐式类型转换，就是弱类型。否则为强类型。</p>
<p>C 系列语言就是弱类型。它允许隐式类型转换，如整数类型转为浮点数类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFloat</span><span class="params">(<span class="keyword">float</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%f\n"</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	printFloat(i);        <span class="comment">// 隐式类型转换</span></span><br><span class="line">	printFloat((<span class="keyword">float</span>)i); <span class="comment">// 显式类型转换</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Haskell 不允许隐式类型转换。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">printFloat</span> :: <span class="type">Float</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printFloat</span> v = putStrLn (show v)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> printFloat (toInteger <span class="number">1</span>)</span><br><span class="line">          printFloat <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>会编译失败。报错类型不匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Couldn&#39;t match expected type &#8216;Float&#8217; with actual type &#8216;Integer&#8217;&#10;In the first argument of &#8216;printFloat&#8217;, namely &#8216;(toInteger 1)&#8217;&#10;In a stmt of a &#39;do&#39; block: printFloat (toInteger 1)</span><br></pre></td></tr></table></figure>
<p>强类型看起似乎麻烦一些，但是类型转换的工作总是要做的。类型转换的规则应该按照实际情况来，是向下取整还是四舍五入。强类型逼迫思考这部分的逻辑，避免错误被隐藏。</p>
<h2 id="动态类型和静态类型">动态类型和静态类型</h2><p>如果类型能够在编译期确定，就是静态类型，否则为动态类型。</p>
<p>C 系列语言都是静态类型。举一个 C# 的例子。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		Console.WriteLine(PlusSecond(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PlusSecond</span>(<span class="params"><span class="keyword">int</span> donation</span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> life = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">		<span class="keyword">return</span> life + donation; <span class="comment">// donation 一定是 int 类型</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分的脚本语言都是动态类型，比如又爱又恨的 JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlusSecond</span>(<span class="params">donation</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> life = <span class="literal">Infinity</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(donation)) <span class="comment">// 运行时才能确定 donation 的类型。</span></span><br><span class="line">  <span class="keyword">return</span> life + donation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至不能确定函数的返回类型</span></span><br><span class="line">PlusSecond(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// =&gt; number</span></span><br><span class="line"><span class="comment">// =&gt; Infinity</span></span><br><span class="line">PlusSecond(<span class="string">" life"</span>);</span><br><span class="line"><span class="comment">// =&gt; string</span></span><br><span class="line"><span class="comment">// =&gt; "Infinity life"</span></span><br></pre></td></tr></table></figure>
<p>动态类型虽然不能确定类型但还是有类型的。</p>
<p>动态类型虽然没有类型，容易出错，但是有 REPL 可以快速迭代代码啊，撸起袖子就是干。只可惜动态一时爽，重构火葬场。</p>
<h2 id="无类型">无类型</h2><p>现在大部分的语言都是有类型的。毕竟有类型很方便啊。但还是存在一些无类型的语言，虽然可能算不上编程语言。</p>
<p>入演算（滑稽），Lambda Calculus，就是一种无类型的，与图灵机等价的计算模型。</p>
<p>语法为</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= &lt;var&gt;</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (λ&lt;var&gt;.&lt;exp&gt;)</span><br><span class="line"><span class="attribute">&lt;exp&gt;</span> ::= (&lt;exp&gt; &lt;exp&gt;)</span><br></pre></td></tr></table></figure>
<p>规约规则有 α-变换（重命名），β-归约（应用）和 η-变换（外延性相等）。</p>
<p>具体规则我懒病发作，就不贴了。可以去<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="external">维基</a>看。</p>
<p>从语法中没有看到半点关于类型的东西，甚至连循环都看不到。</p>
<p>没有循环还能不能愉快的写代码了。</p>
<p>循环可以用递归代替。那递归怎么实现呢？</p>
<p>虽然定义中没有给出递归，但是可以通过不动点组合子实现。</p>
<p>比如著名的 Y 组合子</p>
<p> $Y=\lambda f.(\lambda x.f (x x)) (\lambda x.f (x x))$ </p>
<p>利用不动点的性质就可以达到递归。</p>
<p>$Y g=g (Y g)=g (g (Y g))=g (\ldots g (Y g)\ldots )$</p>
<p>不过因为 Y 组合子是 Call by name。而传统的语言一般是立即求值，所以需要 Y 组合子的 Call by value 版 Z 组合子。</p>
<p>$Z=\lambda f.(\lambda x.f(\lambda v.xxv))(\lambda x.f(\lambda v.xxv))$</p>
<p>Z 组合子的用法很简单，比如在 ES6 中用递归的方式写阶乘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Z = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))</span><br><span class="line">               (x =&gt; f(v =&gt; x(x)(v)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fact = Z (f =&gt; n =&gt; n == <span class="number">1</span> ? <span class="number">1</span> : n * f(n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fact(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure>
<p>那么问题来了，Z 的类型是？</p>
<h2 id="函数类型">函数类型</h2><p>在无类型的入演算引入蕴含（$\to$）就会变成简单类型的入演算（$\lambda^\to$）。</p>
<p>类型规则很简单</p>
<p>$\displaystyle \frac{}{x:\sigma \vdash x : \sigma}$</p>
<p>$\displaystyle \frac{\Gamma\vdash x:\sigma\quad x\not=y}{\Gamma,y:\tau \vdash x : \sigma}$</p>
<p>$\displaystyle \frac{\Gamma,x:\sigma\vdash t:\tau} {\Gamma\vdash \lambda x : \sigma.t : \sigma \to \tau}$</p>
<p>$\displaystyle \frac{\Gamma\vdash t:\sigma\to\tau\quad\Gamma\vdash u:\sigma}{\Gamma\vdash t\,u : \tau}$</p>
<p>例如组合子 IKS 的类型为</p>
<p>$\lambda x:\alpha.x : \alpha\to\alpha$ <strong>(I)</strong></p>
<p>$\lambda x:\alpha.\lambda y:\beta.x:\alpha \to \beta \to \alpha$ (<strong>K</strong>)</p>
<p>$\lambda x:\alpha\to\beta\to\gamma.\lambda y:\alpha\to\beta.\lambda z:\alpha.x z (y z) : (\alpha\to\beta\to\gamma)\to(\alpha\to\beta)\to\alpha\to\gamma$  (<strong>S</strong>)</p>
<p>注意有不少类型是简单类型不能表达的。比如 <code>call/cc</code> 柯里-霍华德同构于皮尔士定律，这在直觉逻辑中是不成立的。所以 <code>call/cc</code> 不能居留。</p>
<p>函数类型是一种值依赖值的例子。</p>
<h2 id="和类型与积类型">和类型与积类型</h2><p>在简单类型的入演算（$\lambda^\to$）引入类型操作符就会变成带类型操作符的简单类型入演算（$\lambda\underline\omega$）</p>
<p>普通的函数是一种操作值的操作符。</p>
<p>类似的，接收类型为参数返回类型的函数成为类型操作符。</p>
<p>有很多类型操作符，所以也会产生很多类型。这里主要提两种类型和类型与积类型。</p>
<p>很多变成使用 null 或者类似的原语来表达缺少值的情况。</p>
<p>但这会有两个问题。</p>
<p>一个是 null 只适用于引用类型，如果是值类型比如 int ，那么该怎么表示缺少值的情况呢？</p>
<p>有些人会取一个范围外的值比如对于输入一定是整数的情况的下可以取 -1 用于表达缺少值。</p>
<p>在输入包含负数的情况下不能用，这就很尴尬了。</p>
<p>值类型还好，错误的输入最多是得到错误的值，而引用类型就不一样了。</p>
<p>如果使用了 null 就必须检查，否则可能会因为空引用而崩溃。</p>
<p>而且使用了 null 相当于绕过了类型系统的检查，是不是 null 只能在运行时确定，做不到检查出 null 而编译失败。</p>
<p>理论上只要做了空检查就不会有问题，但是在复杂的数据结构嵌套中很容易就忘了对某个成员的检查。</p>
<p>这样的感觉像是写动态类型一样，觉得应该是没问题的，最后运行代码然后祈祷不要出错。</p>
<p>Haskell 中使用 Maybe 类型操作符来表达缺少值的情况。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a  <span class="comment">-- a 为类型参数</span></span></span><br></pre></td></tr></table></figure>
<p>注意到 a 为类型变量，可以是 Int，String，Char 等。例如</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Just</span> <span class="string">"Haha"</span>  </span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Just</span> <span class="number">84</span>  </span><br><span class="line"><span class="type">Just</span> <span class="number">84</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Maybe</span> t</span><br></pre></td></tr></table></figure>
<p>使用 Maybe 必须检查是否为 Nothing 否则编译失败。不过检查的过程是自动的（多亏了 Monad 和 do-notation）。</p>
<p>引入 null 不是错误，错误的是没有强制检查 null （C# 可以使用 <code>?.</code> 和 <code>??</code> 简化检查）。</p>
<p>当 a 为 Int 时 Maybe 返回 Maybe Int 。</p>
<p>Maybe Int 是什么类型呢。其实是一种和类型，是 Int + Nothing 。</p>
<p>所以 Maybe 之所以能表达缺少值的情况是因为它可以容纳两种类型。</p>
<p>类似的，积类型可以用 <code>(,)</code> 操作符或者 <code>std::pair</code> 生成。</p>
<p>$(A, B)$ 的类型是 A 类型和 B 类型的笛卡儿积 $A \times B$ 。</p>
<p>类型操作符是一种类型依赖类型的例子。 </p>
<h2 id="多态类型">多态类型</h2><p>在简单类型的入演算（$\lambda^\to$）引入全称量词（$\forall$）就会变成二阶入演算（$\lambda2$），又称为系统 F 。</p>
<p>引入 $\forall$ 后获得多态的能力。系统 F 的多态是参数化多态。</p>
<p>参数化多态类似于泛型。比如对于 <code>List&lt;T&gt;</code> 有</p>
<p>$length: \forall T.[T] \to int$ </p>
<p>注意到 <code>length</code> 是 Rank-1 类型。但有的函数可能是 Rank-2 类型。</p>
<p>比如 $(\forall a.a \to a) \to (\forall b.b \to b)$  就是 Rank-2 类型。</p>
<p>但不是有 N 个全称量词就是 Rank-N 类型。</p>
<p>$\forall a. a \to (\forall b.b \to a)$ 是 Rank-1 类型。</p>
<p>因为可以规约为 $\forall a b . a \to b \to a$ 。</p>
<p>通常的类型系统是 Rank-1 类型。系统 F 支持 Rank-N 类型。</p>
<p>Haskell 的类型系统 Hindley–Milner 类型系统是一种带类型类的系统 F 。默认是 Rank-1 ，需要手动开启 Rank-N 。</p>
<p>比如要使用代替 getter / setter 的光学棱镜组就要开启 Rank-N 。</p>
<p>除了参数化多态，还有特设多态。</p>
<p>特设多态是指一个多态函数有多种实现，依赖于参数的类型，调用相应的版本，类似于面向对象中的重载（overload）。</p>
<p>所以特设多态只能支持有限数量的类型。而参数化多态更为通用。</p>
<p>多态类型是一种值依赖类型的例子。</p>
<h2 id="依赖类型">依赖类型</h2><p>容器类型除了元素类型还跟长度有关，不同长度的同元素类型构成了一个容器簇。</p>
<p>如果把长度当作容器类型构造器的参数，那么就形成了依赖类型。</p>
<p>依赖类型分为依赖乘积类型（Π-类型）和依赖总和类型（Σ-类型）。</p>
<p>依赖乘积类型可以写作 $\displaystyle \Pi (x:A),B(x)$ ，当 $B$ 为常数时，即 $\displaystyle \Pi {(x:A)},B$ ，退化为函数类型 $A \to B$</p>
<p>依赖总和类型可以写作 $\displaystyle \Sigma {(x:A)},B(x)$ ，当 $B$ 为常数时，即 $\displaystyle \Sigma {(x:A)},B$ ，退化为乘积类型 $A \times B$</p>
<p>依赖类型使得容器类型长度变成了一种约束。</p>
<p>例如对于元素类型为 T，长度为 n 的 <code>List</code> 类型 $List(T,n)$ ，它的 <code>append</code> 操作类型为</p>
<p>$append : List(T,n) \to List(T,m) \to List(T,m + n)$ </p>
<p>如果最后返回值长度不是 $m+n$ 就会被编译器踢屁股，编译失败。</p>
<p>这样尽可能用类型表达更多的约束，将逻辑问题扑灭在编译期，就能写出更正确的程序。</p>
<p>毕竟业务逻辑应该写在函数类型里，你之所以要写函数实现是因为编译器还没有聪明到自动做 $\beta$ 规约啊科科。</p>
<p>依赖类型是一种类型依赖值的例子。</p>
<p>这样就集齐了值和类型的三种关系。</p>
<p>以这三种关系为基底，就得到了入立方。</p>
<p><img src="/img/AboutType/Lambda_cube.png" alt="入立方"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随便说一说类型。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="类型" scheme="http://en.ors-sro.com/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>非对称加密</title>
    <link href="http://en.ors-sro.com/asymmetric-cryptography/"/>
    <id>http://en.ors-sro.com/asymmetric-cryptography/</id>
    <published>2017-05-14T10:23:50.000Z</published>
    <updated>2017-05-14T10:31:00.960Z</updated>
    
    <content type="html"><![CDATA[<p>非常有趣的思想。</p>
<a id="more"></a>
<h2 id="对称加密">对称加密</h2><p>为什么要加密呢？因为有些羞羞的东西不想让他人看到。</p>
<p>比如甲给乙传小纸条，必须要经过捣蛋鬼的手中。如果不加密，捣蛋鬼就会知道其中的内容，然后发出嘿嘿嘿的猥琐笑声。BAD ENDING 1</p>
<p>甲和乙都很无语。所以他们决定以后发消息的时候要加密。</p>
<p>甲把信息加密后写在小纸条上，传给乙。</p>
<p>捣蛋鬼即使在途中看到了也没有办法知道里面的内容。HAPPY ENDING (DREAMING)</p>
<p>但是现实很残忍，甲和乙不能私下接触，所以只能通过传小纸条的方式来交换信息。</p>
<p>那么加密的密钥，甲该怎么传给乙呢？</p>
<p>假设甲把密钥加密后传给乙，乙不知道加密的密钥怎么解密。看不懂。BAD ENDING 2</p>
<p>假设甲把没加密的密钥传给乙，捣蛋鬼也知道了密钥，甲再发羞羞的内容给乙时，捣蛋鬼用已知的密钥解密，再次发出嘿嘿嘿的萎缩笑声。BAD ENDING 3</p>
<p>甲感到很绝望。不加密会被偷窥。加密了也会被偷窥。</p>
<h2 id="非对称加密">非对称加密</h2><p>甲在想如果加密和解密用的不是同一个密钥，那么这样就不怕被偷窥了。那要怎么做呢？</p>
<p>后来老师在密码学课上讲了方法。</p>
<p>甲先生成两个密钥，这两个密钥有这样的特点，知道一个密钥不能推出另外一个密钥，但是两个密钥对于某些数学运算能得到相同的结果，也就是一个密钥加密的文本只能用另外一个密钥解密。</p>
<p>甲随机选择一个密钥，不加密，写在小纸条上传给乙。捣蛋鬼和乙一看这乱七八糟的数字一定是密钥，这个密钥已经公开了。所以称为公钥。剩下那个没公开的称为私钥。</p>
<p>乙心神领会后，也把公钥发给了甲。</p>
<p>这样两轮信息交换后</p>
<p>甲知道了乙的公钥、甲的公钥、甲的私钥。</p>
<p>乙知道了甲的公钥、乙的公钥、乙的私钥。</p>
<p>捣蛋鬼知道了甲的公钥和乙的公钥。</p>
<p>甲用乙的公钥加密羞羞的东西，发给乙。</p>
<p>捣蛋鬼看到莫名其妙的东西，知道是被加密了。但是乙的公钥不能解密，能解密的只有乙的私钥。捣蛋鬼并不知道乙的私钥。只好放行。传给乙。</p>
<p>乙收到密文后，用乙的私钥解密，看到了羞羞的东西，决定回复甲。</p>
<p>乙用甲的公钥加密回复，发给甲。</p>
<p>捣蛋鬼再次看到莫名其妙的东西，知道肯定又是加密了。而且肯定使用甲的公钥加密了。因为如果用乙的公钥加密，甲没有乙的私钥没有办法解密。捣蛋鬼没有甲的私钥，不能解密，只好放行。</p>
<p>甲收到密文后用甲的私钥解密。看到了回复。 HAPPY ENDING</p>
<p>在上述两个例子中，有两种加密方式。</p>
<p>加密和解密用的是同一个密钥，这叫对称加密。</p>
<p>相应地，加密和解密用的不是同一个密钥，这叫非对称机密。</p>
<p>对称加密很容易做到。那么非对称加密是怎么做到密钥不一样还能解密的呢？</p>
<p>有好几种方法，比如有一种方法是这样的。</p>
<p>在数学运算中，有些运算会产生信息丢失，也就是即便知道了运算结果也不一定能确定运算前的数。</p>
<p>比如对于取膜 $\bmod$ </p>
<p>$3 \bmod 2 = 1$  。如果只知道运算结果是 $1$ 是不能确定运算前是 $3$ 的，因为有可能是 $1, 3, 5, 7, 9\dots$ 中的任何一个。</p>
<p>虽然不知道原来的数，但是只要知道数学关系就能得到相同的结果。比如只要奇数模 2 都会等于 1 。</p>
<p>所以可以这么做。</p>
<p>甲先公开生成密钥的两个常数 $g = 5$ 和 $p = 23$ 。</p>
<p>甲随机选取一个数字 $a$ 比如 $a = 6$ ，算出公钥 $A = g^a \bmod p = 5^6 \bmod 23 = 8$</p>
<p>甲把公钥 $A = 23$ 发给乙，把私钥 $a = 6$ 偷偷藏起来。</p>
<p>捣蛋鬼知道了 $5^? \bmod 23 = 8$ ，但是推不出甲的私钥 $a$ 。</p>
<p>乙随机选取一个数字 $b$ 比如 $b = 15$ ，算出公钥 $B = g^b \bmod p = 5^{15} \bmod 23 = 19$</p>
<p>乙把公钥 $B = 19$ 发给甲，把私钥 $b = 15$ 偷偷藏起来。</p>
<p>捣蛋鬼知道了 $5^? \bmod 23 = 19$ ，但是推不出乙的私钥 $b$ 。</p>
<p>因为 $(g^a)b = (g^b)^a$ 所以 $(g^a)^b \bmod p = (g^b)^a \bmod p$ </p>
<p>由于取模的性质有</p>
<p> $(g^a)^b \bmod p = A^b \bmod p$</p>
<p>$(g^b)^a \bmod p = B^a \bmod p$</p>
<p>所以</p>
<p>$A^b \bmod p = B^a \bmod p$</p>
<p>也就是甲可以通过甲的私钥和乙的公钥组合来解密，不能只通过乙的公钥来解密。</p>
<p>同样，乙可以通过乙的私钥和甲的公钥组合来解密，不能只通过甲的公钥来解密。</p>
<p>在实际应用中通常选择比较大的数防止暴力穷举。</p>
<p>因为非对称加密相比于对称加密较慢，所以通常使用非对称加密传递对称加密的密钥后使用对称加密通信。</p>
<h2 id="中间人攻击">中间人攻击</h2><p>以上情况建立在捣蛋鬼没有好好听课的前提下。实际上捣蛋鬼刚好认真听了老师那节介绍非对称加密的课。</p>
<p>于是甲传递甲的公钥时，捣蛋鬼替换为捣蛋鬼的公钥。</p>
<p>乙收到捣蛋鬼的公钥后发出乙的公钥。</p>
<p>捣蛋鬼收到乙的公钥后替换为捣蛋鬼的公钥。</p>
<p>甲收到捣蛋鬼的公钥后，用捣蛋鬼的公钥加密羞羞的东西，发给乙。</p>
<p>捣蛋鬼收到加密的内容后，用捣蛋鬼的私钥解密后看到羞羞的内容。发出嘿嘿嘿的萎缩笑声。BAD ENDING 4</p>
<h2 id="应对非对称加密">应对非对称加密</h2><p>如果文件被非对称加密（如 RSA）加密了。有什么办法解密吗？</p>
<p>目前能想到的有以下几种方法。</p>
<ol>
<li>暴力穷举，假设你有银河超级计算器的话。</li>
<li>获取私钥，假设你可以有资本色诱或威胁的话。</li>
<li>找到快速的大质数分解方式，顺便拿个炸药奖。</li>
</ol>
<h2 id="最后">最后</h2><p>在现实生活中，甲传纸条给乙，经过捣蛋鬼的手，捣蛋鬼噌地站起来指着甲说：“老师他上课传纸条！”。</p>
<p>参考链接</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="external">公开密钥加密</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="external">迪菲-赫爾曼密鑰交換</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常有趣的思想。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="密码学" scheme="http://en.ors-sro.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于原型的面向对象</title>
    <link href="http://en.ors-sro.com/Prototype-base-object-oriented-programming/"/>
    <id>http://en.ors-sro.com/Prototype-base-object-oriented-programming/</id>
    <published>2017-05-07T11:50:45.000Z</published>
    <updated>2017-05-07T11:52:10.222Z</updated>
    
    <content type="html"><![CDATA[<p>实现面向对象不一定是基于类的方式。</p>
<a id="more"></a>
<h2 id="现在">现在</h2><p>ES6 引入基于类的对象声明方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeDPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  constructor(x, y, z)&#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">', '</span> + <span class="keyword">this</span>.z + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这只是为了照顾 Java 和 C++ 程序员而引入的语法糖。底层的实现还是没有变的。</p>
<h2 id="过去">过去</h2><p>ES5 之前的对象声明是这样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>为什么没有写继承呢？因为继承了灵活，有很多中方法，取决于你的目的。</p>
<p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">JavaScript 继承</a></p>
<h2 id="区别">区别</h2><p>面向对象强调的是对象，而不是类。所以没有叫面向类编程。</p>
<p>面向对象的实现方式除了基于类的方式，还有基于原型的方式。</p>
<p>基于原型的方式能够实现基于类的方式，如 ES6 引入的语法糖。</p>
<p>而基于类的实现方式大部分不能实现基于原型的方式。因为大部分的语言类型层级是静态的。</p>
<p>也就是说在编译的时候类型继承是已经确定的，运行的时候不能更改继承关系。</p>
<p>而基于原型的方式在运行的时候可以更改继承关系。更改 <code>prototype</code> 即可。</p>
<p>基于类的面向对象编程经常有基本类型难以更改的问题。这是因为类型继承树是定死的，后期改起来影响很大。</p>
<p>比如你有一个列表的基本组件 <code>ListBase</code> 。所有列表集成于它。</p>
<p>如果你想来一个新的列表跟 <code>ListBase</code> 表现不一致，那么就要重载其中不一致的部分。</p>
<p>如果被重载的函数太长，或者里面引用了私有变量，就很难实现。</p>
<p>这时候要么改 <code>ListBase</code> 要么把 <code>ListBase</code> 的代码复制一遍，重新做一个 <code>NewListBase</code>。</p>
<p>改动 <code>ListBase</code>，因为用到的地方很多，无法保证不会出问题。</p>
<p>复制一遍，如果 <code>ListBase</code> 改动很难同步。也是产生代码腐臭的经典方式。</p>
<p>如果是用原型的方式，直接继承 <code>prototype</code> 。然后改想要改的部分就可以了。</p>
<p>相当于复制了代码，但是这段复制的代码是在运行的时候复制出来的。所以 <code>ListBase</code> 的改动都会同步。</p>
<p>基于原型的继承最大的缺点是接受了基于类继承的先入为主后很难理解。</p>
<p>基于原型的继承在代码中没有类的概念，所有类的概念都是人为为了模拟基于类的面向对象而产生的。</p>
<p>基于原型的集成只有对象的复制和修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现面向对象不一定是基于类的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="JavaScript" scheme="http://en.ors-sro.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>SICP 2.2 层级数据和闭包属性</title>
    <link href="http://en.ors-sro.com/SICP-2-2-Hierarchical-Data-and-the-Closure-Property/"/>
    <id>http://en.ors-sro.com/SICP-2-2-Hierarchical-Data-and-the-Closure-Property/</id>
    <published>2017-04-30T15:05:52.000Z</published>
    <updated>2017-04-30T15:25:05.645Z</updated>
    
    <content type="html"><![CDATA[<p>好久没填坑都快忘了……</p>
<a id="more"></a>
<h2 id="笔记">笔记</h2><p><code>cons</code> 可以嵌套</p>
<p><code>(cons 1 (cons 2 (cons 3 (cons 4 nil))))</code> 相当于 <code>list(1 2 3 4)</code></p>
<p>那 <code>(cons 1 (cons 2 (cons 3 4)))</code> 呢？</p>
<p>原来 <code>nil</code> 来源于意大利语 <strong>nihil</strong> ，以为无，没有。</p>
<p><code>cons</code> 还可用于在列表前面附加元素</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">cons</span> <span class="number">10</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; (10 1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<p>那要在列表后面附加元素呢，使用 <code>append</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; (1 2 3 4)</span></span><br><span class="line"><span class="comment">;; 如果第二个不是列表而是一个元素的话，结果会是 cons</span></span><br><span class="line"><span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="number">3</span>)</span></span><br><span class="line"><span class="comment">; (1 2 . 3)</span></span><br></pre></td></tr></table></figure>
<p>用 <code>null?</code> 来判断列表是否为空。（为什么不是 <code>nil?</code> ……）</p>
<p><code>((1 2) 3 4)</code> 可以看成 <code>(cons (list 1 2) (list 3 4))</code> </p>
<p>也可以看成树状结构，取决于目标和解释方式。</p>
<p>在递归的过程中有时候需要判断参数是不是 pair 。可以用 <code>pair?</code> 来判断。</p>
<h2 id="习题">习题</h2><h3 id="习题_2-17">习题 2.17</h3><blockquote>
<p><strong>Exercise 2.17.</strong>  Define a procedure last-pair that returns the list that contains only the last element of a given (nonempty) list:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">list</span> <span class="number">23</span> <span class="number">72</span> <span class="number">149</span> <span class="number">34</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">34</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>列表就是一系列的 pair 。最后一个元素一定处于 <code>(cons xxx nil)</code> 的类似列表。所以通过基本的操作 <code>car</code> 和 <code>cdr</code> 不断的取尾，最后一个元素为 <code>nil</code> 时所处的 pair 第一个元素就是整个列表的最后一个元素。最后再用 <code>list</code> 封装以达到题目要求。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">last-pair</span> alist)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? <span class="list">(<span class="keyword">cdr</span> alist)</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">car</span> alist)</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">cdr</span> alist)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (4)</span></span><br><span class="line"><span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1)</span></span><br><span class="line"><span class="list">(<span class="keyword">last-pair</span> <span class="list">(<span class="keyword">list</span> <span class="number">23</span> <span class="number">72</span> <span class="number">149</span> <span class="number">34</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (34)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-18">习题 2.18</h3><blockquote>
<p><strong>Exercise 2.18.</strong>  Define a procedure reverse that takes a list as argument and returns a list of the same elements in reverse order:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">reverse</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">25</span> <span class="number">16</span> <span class="number">9</span> <span class="number">4</span> <span class="number">1</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>因为列表是一个递归嵌套 pair 的结构，所以很自然要用递归的方式处理。</p>
<p>用递归的方式处理，最基本的是先确定递归退出条件。通常是考虑最小子问题。</p>
<p>在这个例子中，最小的列表是空列表。</p>
<p>逆转空列表结果还是空列表。</p>
<p>接着就是找递归的递进条件，也就是怎么把问题变成更小的问题。</p>
<p>考虑到一个列表可以拆分为第一个元素和剩余列表。</p>
<p>那么逆转一个列表，相当于逆转过后的剩余列表拼接上第一个元素。</p>
<p>这样问题的规模就缩小了。只要同样地逆转剩余列表即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">reverse</span> alist)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? alist)</span></span><br><span class="line">      alist</span><br><span class="line">      <span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">reverse</span> <span class="list">(<span class="keyword">cdr</span> alist)</span>)</span> </span><br><span class="line">              <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">car</span> alist)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">reverse</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (4 3 2 1)</span></span><br><span class="line"><span class="list">(<span class="keyword">reverse</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (25 16 9 4 1)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-19">习题 2.19</h3><blockquote>
<p><strong>Exercise 2.19.</strong>  Consider the change-counting program of section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.2" target="_blank" rel="external">1.2.2</a>. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the procedure first-denomination and partly into the procedure count-change (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.</p>
<p>We want to rewrite the procedure cc so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> us-coins <span class="list">(<span class="keyword">list</span> <span class="number">50</span> <span class="number">25</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> uk-coins <span class="list">(<span class="keyword">list</span> <span class="number">100</span> <span class="number">50</span> <span class="number">20</span> <span class="number">10</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0.5</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>We could then call cc as follows:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> us-coins)</span></span><br><span class="line"><span class="number">292</span></span><br></pre></td></tr></table></figure></p>
<p>To do this will require changing the program cc somewhat. It will still have the same form, but it will access its second argument differently, as follows:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">cc</span> amount coin-values)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">=</span> amount <span class="number">0</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">or</span> <span class="list">(<span class="keyword">&lt;</span> amount <span class="number">0</span>)</span> <span class="list">(<span class="keyword">no-more</span>? coin-values)</span>)</span> <span class="number">0</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">else</span></span><br><span class="line">         <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">cc</span> amount</span><br><span class="line">                <span class="list">(<span class="keyword">except-first-denomination</span> coin-values)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">cc</span> <span class="list">(<span class="keyword">-</span> amount</span><br><span class="line">                   <span class="list">(<span class="keyword">first-denomination</span> coin-values)</span>)</span></span><br><span class="line">                coin-values)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>Define the procedures first-denomination, except-first-denomination, and no-more? in terms of primitive operations on list structures. Does the order of the list coin-values affect the answer produced by cc? Why or why not?</p>
</blockquote>
<p>题目要求实现 <code>first-denomination</code> 、<code>except-first-denomination</code> 和 <code>no-more?</code> 。</p>
<p>其实函数名字已经提示很多了。</p>
<p><code>first-denomination</code> 是取第一个货币单位。</p>
<p><code>except-first-denomination</code> 是排除第一个货币单位。</p>
<p><code>no-more?</code> 是判断是否还有货币单位。</p>
<p>参考列表的操作，很容易写出来</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> except-first-denomination cdr)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> first-denomination car)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> no-more? null?)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> us-coins)</span></span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> uk-coins)</span></span><br><span class="line"><span class="comment">; =&gt; 104561</span></span><br></pre></td></tr></table></figure>
<p>题目还问改变货币列表中的顺序是否会影响结果。</p>
<p>考虑到换零钱的计算方式是换某种货币的组合数加上不换某种货币的组合数。</p>
<p>显然换 100 加上不换 100 的组合等于换 5 加上不换 5 的组合。因为要兑换的总额是一样的。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> us-coins2 <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">25</span> <span class="number">50</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> us-coins2)</span></span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br><span class="line"><span class="list">(<span class="keyword">cc</span> <span class="number">100</span> us-coins)</span></span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-20">习题 2.20</h3><blockquote>
<p><strong>Exercise 2.20.</strong>  The procedures +, <em>, and list take arbitrary numbers of arguments. One way to define such procedures is to use define with \</em>dotted-tail notation<em>. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedure is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter’s value will be a </em>list* of any remaining arguments. For instance, given the definition<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">f</span> x y . z)</span> &lt;body&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p>the procedure f can be called with two or more arguments. If we evaluate<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">f</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>then in the body of f, x will be 1, y will be 2, and z will be the list (3 4 5 6). Given the definition<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">g</span> . w)</span> &lt;body&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p>the procedure g can be called with zero or more arguments. If we evaluate<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">g</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>then in the body of g, w will be the list <code>(1 2 3 4 5 6)</code>.<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_164" target="_blank" rel="external">11</a></p>
<p>Use this notation to write a procedure same-parity that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">same-parity</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">same-parity</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="list">(<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>题目介绍了不定参数的函数定义方式，通过类似 pair 的形式来定义，还是很有趣的。</p>
<p><code>same-parity</code> 肯定要支持不定参数。那么最少有几个参数？</p>
<p>是 1 个。如果是 1 个直接返回该元素即可。</p>
<p>所以 <code>same-parity</code> 的定义如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">same-parity</span> element . alist)</span> &lt;body&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 点两边都要有空格，不然会视作函数名为 same-parity.alist 的函数。</span></span><br></pre></td></tr></table></figure>
<p>第一个参数是 <code>alist</code> 的第一个元素。</p>
<p>第二个参数是剩余的列表。</p>
<p>然后考虑如何把子问题规模缩小。</p>
<p>比如对于列表 <code>(1 2 3 4)</code></p>
<p>可以拆分为 <code>(same-parity 1 2)</code> 和 <code>(same-parity 1 (3 4))</code></p>
<p>这样问题的规模就变小了。</p>
<p>因为 <code>(same-parity 1 2)</code> 会把参数收集为列表，这样递归不是很方便，所以创建一个 <code>(same-parity-iter)</code> 。</p>
<p>完整代码如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">same-parity</span> . alist)</span></span><br><span class="line">  <span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">same-parity-iter</span> first rest result)</span></span><br><span class="line">    <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? rest)</span></span><br><span class="line">        result</span><br><span class="line">        <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">same-parity</span>? first <span class="list">(<span class="keyword">car</span> rest)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">same-parity-iter</span> first <span class="list">(<span class="keyword">cdr</span> rest)</span> <span class="list">(<span class="keyword">append</span> result <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">car</span> rest)</span>)</span>)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">same-parity-iter</span> first <span class="list">(<span class="keyword">cdr</span> rest)</span> result)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">or</span> <span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">length</span> alist)</span> <span class="number">0</span>)</span></span><br><span class="line">          <span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">length</span> alist)</span> <span class="number">1</span>)</span>)</span></span><br><span class="line">      alist</span><br><span class="line">      <span class="list">(<span class="keyword">same-parity-iter</span> <span class="list">(<span class="keyword">car</span> alist)</span> <span class="list">(<span class="keyword">cdr</span> alist)</span> <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">car</span> alist)</span>)</span>)</span>)</span>)</span></span><br><span class="line">      </span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">same-parity</span>? a b)</span></span><br><span class="line"></span><br><span class="line">  <span class="list">(<span class="keyword">or</span> <span class="list">(<span class="keyword">and</span> <span class="list">(<span class="keyword">even</span>? a)</span> <span class="list">(<span class="keyword">even</span>? b)</span>)</span></span><br><span class="line"></span><br><span class="line">      <span class="list">(<span class="keyword">and</span> <span class="list">(<span class="keyword">odd</span>? a)</span> <span class="list">(<span class="keyword">odd</span>? b)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">same-parity</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1 3 5 7)</span></span><br><span class="line"><span class="list">(<span class="keyword">same-parity</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (2 4 6)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-21">习题 2.21</h3><blockquote>
<p><strong>Exercise 2.21.</strong>  The procedure <code>square-list</code> takes a list of numbers as argument and returns a list of the squares of those numbers.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>Here are two different definitions of <code>square-list</code>. Complete both of them by filling in the missing expressions:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? items)</span></span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      <span class="list">(<span class="keyword">cons</span> &lt;??&gt; &lt;??&gt;)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> &lt;??&gt; &lt;??&gt;)</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>仿照 <code>scale-list</code> 即可得到答案</p>
<p>第一种</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? items)</span></span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">*</span> <span class="list">(<span class="keyword">car</span> items)</span> <span class="list">(<span class="keyword">car</span> items)</span>)</span> <span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">cdr</span> items)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">*</span> x x)</span>)</span> items)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-22">习题 2.22</h3><blockquote>
<p><strong>Exercise 2.22.</strong>  Louis Reasoner tries to rewrite the first square-list procedure of exercise 2.21 so that it evolves an iterative process:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">iter</span> things answer)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? things)</span></span><br><span class="line">      answer</span><br><span class="line">      <span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">cdr</span> things)</span> </span><br><span class="line">            <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">square</span> <span class="list">(<span class="keyword">car</span> things)</span>)</span></span><br><span class="line">                  answer)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">iter</span> items <span class="literal">nil</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>Unfortunately, defining square-list this way produces the answer list in the reverse order of the one desired. Why?</p>
<p>Louis then tries to fix his bug by interchanging the arguments to cons:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">iter</span> things answer)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? things)</span></span><br><span class="line">      answer</span><br><span class="line">      <span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">cdr</span> things)</span></span><br><span class="line">            <span class="list">(<span class="keyword">cons</span> answer</span><br><span class="line">                  <span class="list">(<span class="keyword">square</span> <span class="list">(<span class="keyword">car</span> things)</span>)</span>)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">iter</span> items <span class="literal">nil</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>This doesn’t work either. Explain.</p>
</blockquote>
<p>这么做显然是有问题的。用 Applicative Order 展开就清楚了</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="literal">nil</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">cons</span> <span class="number">1</span> <span class="literal">nil</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">cons</span> <span class="number">4</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="literal">nil</span> <span class="list">(<span class="keyword">cons</span> <span class="number">9</span> <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="number">1</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="literal">nil</span> <span class="list">(<span class="keyword">list</span> <span class="number">9</span> <span class="number">4</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="comment">; (9 4 1)</span></span><br></pre></td></tr></table></figure>
<p>再看修正版，还是使用 Applicative Order 展开</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="literal">nil</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">cons</span> <span class="literal">nil</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">cons</span> <span class="literal">nil</span> <span class="number">1</span>)</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">iter</span> <span class="literal">nil</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">cons</span> <span class="literal">nil</span> <span class="number">1</span>)</span> <span class="number">4</span>)</span> <span class="number">9</span>)</span>)</span></span><br><span class="line"><span class="comment">; (((1) . 4) . 9)</span></span><br></pre></td></tr></table></figure>
<p>这次他虽然调整了顺序，但是没有使用正确的方式附加元素。</p>
<p>按照提供的现有函数，如果想在列表后面附加元素应该使用 <code>append</code> 和 <code>list</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<p>所以这么改就可以了。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-list</span> items)</span></span><br><span class="line">  <span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">iter</span> things answer)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? things)</span></span><br><span class="line">      answer</span><br><span class="line">      <span class="list">(<span class="keyword">iter</span> <span class="list">(<span class="keyword">cdr</span> things)</span></span><br><span class="line">            <span class="list">(<span class="keyword">append</span> answer</span><br><span class="line">                  <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">square</span> <span class="list">(<span class="keyword">car</span> things)</span>)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">iter</span> items <span class="literal">nil</span>)</span>)</span></span></span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; =&gt; (1 4 9 16)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-23">习题 2.23</h3><blockquote>
<p><strong>Exercise 2.23.</strong>  The procedure for-each is similar to map. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, for-each just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all — for-each is used with procedures that perform an action, such as printing. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">for-each</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">newline</span>)</span> <span class="list">(<span class="keyword">display</span> x)</span>)</span></span><br><span class="line"> <span class="list">(<span class="keyword">list</span> <span class="number">57</span> <span class="number">321</span> <span class="number">88</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>573<br>21<br>88</p>
<p>The value returned by the call to for-each (not illustrated above) can be something arbitrary, such as true. Give an implementation of for-each.</p>
</blockquote>
<p>比起 <code>map</code> ，<code>for-each</code> 更注重操作的副作用，而不是结果。</p>
<p>所以如果不介意返回值的话，完全可以把 <code>map</code> 当作 <code>for-each</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> for-each map)</span></span><br></pre></td></tr></table></figure>
<p>如果自己写是这样的。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">for-each</span> f alist)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? alist)</span></span><br><span class="line">      #t</span><br><span class="line">      <span class="list">(<span class="keyword">list</span>  <span class="list">(<span class="keyword">for-each</span> f <span class="list">(<span class="keyword">cdr</span> alist)</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="keyword">car</span> alist)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>注意把 <code>(f (car alist))</code> 放在后面，因为参数求值从后面开始。</p>
<h3 id="习题_2-24">习题 2.24</h3><blockquote>
<p><strong>Exercise 2.24.</strong>  Suppose we evaluate the expression <code>(list 1 (list 2 (list 3 4)))</code>. Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree (as in figure <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_fig_2.6" target="_blank" rel="external">2.6</a>).</p>
</blockquote>
<p>表达式的结果是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; =&gt; (1 (2 (3 4)))</span></span><br></pre></td></tr></table></figure>
<p>盒子图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+---+---+      +---+---+&#10;&#10;|   |   | +--&#62; |   |   |&#10;&#10;+-+-+---+      +-+-+---+&#10;&#10;  |              |&#10;&#10;  v              v&#10;&#10;+---+---+      +---+---+       +---+---+&#10;&#10;|   |   |      |   |   | +---&#62; |   |   |&#10;&#10;+-+-+---+      +-+-+---+       +-+-+---+&#10;&#10;  |              |               |&#10;&#10;  v              v               v&#10;&#10;+---+---+      +---+---+       +---+---+      +---+---+&#10;&#10;|   |   |      |   |   |       |   |   | +--&#62; |   |   |&#10;&#10;+-+-+---+      +-+-+---+       +-+-+---+      +-+-+---+&#10;&#10;  |              |               |              |&#10;&#10;  v              v               v              v&#10;&#10;+-+             +-+             +-+            +-+&#10;&#10;|1|             |2|             |3|            |4|&#10;&#10;+-+             +-+             +-+            +-+</span><br></pre></td></tr></table></figure>
<p>树状图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 (2 (3 4)))&#10;&#9500;&#9472;1&#10;&#9492;&#9472;&#9472;(2 (3 4))&#10;    &#9500;&#9472;&#9472;2&#10;    &#9492;&#9472;&#9472;(3 4)&#10;        &#9500;&#9472;&#9472;3&#10;        &#9492;&#9472;&#9472;4</span><br></pre></td></tr></table></figure>
<h3 id="习题_2-25">习题 2.25</h3><blockquote>
<p><strong>Exercise 2.25.</strong>  Give combinations of <code>car</code>s and <code>cdr</code>s that will pick 7 from each of the following lists:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="number">1</span> <span class="number">3</span> <span class="list">(<span class="number">5</span> <span class="number">7</span>)</span> <span class="number">9</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="list">(<span class="number">7</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="list">(<span class="number">2</span> <span class="list">(<span class="number">3</span> <span class="list">(<span class="number">4</span> <span class="list">(<span class="number">5</span> <span class="list">(<span class="number">6</span> <span class="number">7</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>由内往外，一步步使用 <code>car</code> 和 <code>cdr</code> 即可。</p>
<p>比如对于<code>(1 3 (5 7) 9)</code> 先从 <code>(5 7)</code>下手。</p>
<p>想要得到 <code>(5 7)</code> 中的 7 只需要 <code>(car (cdr (5 7))</code></p>
<p>对于 <code>(1 3 (5 7) 9)</code> 先要 <code>cdr</code> 得到 <code>(3 (5 7) 9)</code> </p>
<p>然后再 <code>cdr</code> 得到 <code>((5 7) 9)</code> </p>
<p>再 <code>car</code> 一下就能得到 <code>(5 7)</code>了。</p>
<p>所以答案如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; (1 3 (5 7) 9)</span></span><br><span class="line"><span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">3</span> <span class="list">(<span class="keyword">list</span> <span class="number">5</span> <span class="number">7</span>)</span> <span class="number">9</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">; ((7))</span></span><br><span class="line"><span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">7</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">; (1 (2 (3 (4 (5 (6 7))))))</span></span><br><span class="line"><span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="list">(<span class="keyword">list</span> <span class="number">5</span> <span class="list">(<span class="keyword">list</span> <span class="number">6</span> <span class="number">7</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>要注意 <code>cdr</code> 始终返回一个列表，所以 <code>(cdr (5 (6 7)))</code> 是 <code>((6 7))</code> 不是 <code>(6 7)</code> 。</p>
<h3 id="习题_2-26">习题 2.26</h3><blockquote>
<p><strong>Exercise 2.26.</strong>  Suppose we define <code>x</code> and <code>y</code> to be two lists:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> y <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>What result is printed by the interpreter in response to evaluating each of the following expressions:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">append</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword">cons</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword">list</span> x y)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>答案如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> y <span class="list">(<span class="keyword">list</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">append</span> x y)</span></span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4 5 6)</span></span><br><span class="line"><span class="list">(<span class="keyword">cons</span> x y)</span></span><br><span class="line"><span class="comment">; =&gt; ((1 2 3) 4 5 6)</span></span><br><span class="line"><span class="list">(<span class="keyword">list</span> x y)</span></span><br><span class="line"><span class="comment">; =&gt; ((1 2 3) (4 5 6))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-27">习题 2.27</h3><blockquote>
<p><strong>Exercise 2.27.</strong>  Modify your <code>reverse</code> procedure of exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_thm_2.18" target="_blank" rel="external">2.18</a> to produce a <code>deep-reverse</code> procedure that takes a list as argument and returns as its value the list with its elements reversed and with all subsists deep-reversed as well. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line">x</span><br><span class="line"><span class="list">(<span class="list">(<span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">reverse</span> x)</span></span><br><span class="line"><span class="list">(<span class="list">(<span class="number">3</span> <span class="number">4</span>)</span> <span class="list">(<span class="number">1</span> <span class="number">2</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">deep-reverse</span> x)</span></span><br><span class="line"><span class="list">(<span class="list">(<span class="number">4</span> <span class="number">3</span>)</span> <span class="list">(<span class="number">2</span> <span class="number">1</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>首先定义规则，深度反转空列表还是空列表。</p>
<p>深度反转单个叶子节点还是单个叶子节点。</p>
<p>深度反正一棵树等于反转剩余列表拼接上反转第一个列表。</p>
<p>翻译成代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">deep-reverse</span> tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">null</span>? tree)</span> <span class="list">()</span>)</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? tree)</span>)</span> <span class="list">(<span class="keyword">list</span> tree)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">else</span> <span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">deep-reverse</span> <span class="list">(<span class="keyword">cdr</span> tree)</span>)</span></span><br><span class="line">                      <span class="list">(<span class="keyword">deep-reverse</span> <span class="list">(<span class="keyword">car</span> tree)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">deep-reverse</span> x)</span></span><br><span class="line"><span class="comment">; =&gt; ((4 3) (2 1))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-28">习题 2.28</h3><blockquote>
<p><strong>Exercise 2.28.</strong>  Write a procedure <code>fringe</code> that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">fringe</span> x)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">fringe</span> <span class="list">(<span class="keyword">list</span> x x)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>类似上一题， <code>fringe</code> 空列表为空列表</p>
<p><code>fringe</code> 单个元素为单个元素。</p>
<p><code>fringe</code> 一棵树为<code>fringe</code> 第一个列表拼接上 <code>fringe</code> 剩余元素。</p>
<p>翻译成代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">fringe</span> tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">null</span>? tree)</span> <span class="list">()</span>)</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? tree)</span>)</span> <span class="list">(<span class="keyword">list</span> tree)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">else</span> <span class="list">(<span class="keyword">append</span> <span class="list">(<span class="keyword">fringe</span> <span class="list">(<span class="keyword">car</span> tree)</span>)</span></span><br><span class="line">                      <span class="list">(<span class="keyword">fringe</span> <span class="list">(<span class="keyword">cdr</span> tree)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">list</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">fringe</span> x)</span></span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4)</span></span><br><span class="line"><span class="list">(<span class="keyword">fringe</span> <span class="list">(<span class="keyword">list</span> x x)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4 1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-29">习题 2.29</h3><blockquote>
<p><strong>Exercise 2.29.</strong>  A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using <code>list</code>):</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">make-mobile</span> left right)</span></span><br><span class="line">  <span class="list">(<span class="keyword">list</span> left right)</span>)</span></span><br></pre></td></tr></table></figure>
<p>A branch is constructed from a <code>length</code> (which must be a number) together with a <code>structure</code>, which may be either a number (representing a simple weight) or another mobile:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">make-branch</span> length structure)</span></span><br><span class="line">  <span class="list">(<span class="keyword">list</span> length structure)</span>)</span></span><br></pre></td></tr></table></figure>
<p>a.  Write the corresponding selectors <code>left-branch</code> and <code>right-branch</code>, which return the branches of a mobile, and <code>branch-length</code> and <code>branch-structure</code>, which return the components of a branch.</p>
<p>b.  Using your selectors, define a procedure <code>total-weight</code> that returns the total weight of a mobile.</p>
<p>c.  A mobile is said to be <em>balanced</em> if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate that tests whether a binary mobile is balanced.</p>
<p>d.  Suppose we change the representation of mobiles so that the constructors are</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">make-mobile</span> left right)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cons</span> left right)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">make-branch</span> length structure)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cons</span> length structure)</span>)</span></span><br></pre></td></tr></table></figure>
<p>How much do you need to change your programs to convert to the new representation?</p>
</blockquote>
<p>问题 a 。只需要看数据结构的定义，所以四个选择器的定义如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> left-branch car)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">right-branch</span> tree)</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> tree)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> branch-length car)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">branch-structure</span> branch)</span> <span class="list">(<span class="keyword">car</span> <span class="list">(<span class="keyword">cdr</span> branch)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>接着实现问题 b 要求的 <code>total-weight</code> 。</p>
<p>分支的最基本类型是形如 <code>(5 3)</code> 这种第一个是长度，第二个是重量的类型。</p>
<p>这种情况分支的重量为 3</p>
<p>其他情况下分支的重量等于左子树的重量加上右子树的重量。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">total-weight</span> mobile)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? mobile)</span>)</span></span><br><span class="line">      mobile</span><br><span class="line">      <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">branch-structure</span> <span class="list">(<span class="keyword">left-branch</span> mobile)</span>)</span>)</span></span><br><span class="line">         <span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">branch-structure</span> <span class="list">(<span class="keyword">right-branch</span> mobile)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> l <span class="list">(<span class="keyword">make-branch</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> r <span class="list">(<span class="keyword">make-branch</span> <span class="number">6</span> <span class="number">7</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> s <span class="list">(<span class="keyword">make-branch</span> <span class="number">1</span> <span class="number">2</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">make-mobile</span> s <span class="list">(<span class="keyword">make-branch</span> <span class="number">7</span> <span class="list">(<span class="keyword">make-mobile</span> l r)</span>)</span>)</span>)</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">; =&gt; ((1 2) (7 ((3 4) (6 7))))</span></span><br><span class="line"><span class="list">(<span class="keyword">total-weight</span> x)</span></span><br><span class="line"><span class="comment">; =&gt; 13</span></span><br><span class="line"><span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">make-mobile</span> l r)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; 11</span></span><br></pre></td></tr></table></figure>
<p>问题 c 中定义平衡为所有的左右子数长度和重量的乘积相等。</p>
<p>对于最基本的 mobile 比如 2 。因为没有左右子树，所以认为是相等的。</p>
<p>对于其他的 mobile 比如 <code>((1 2) (3 4))</code> 判断左右重量和长度的乘积是否相等。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">balanced</span>? mobile)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? mobile)</span>)</span></span><br><span class="line">      #t</span><br><span class="line">      <span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">*</span> <span class="list">(<span class="keyword">branch-length</span> <span class="list">(<span class="keyword">left-branch</span> mobile)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">branch-structure</span> <span class="list">(<span class="keyword">left-branch</span> mobile)</span>)</span>)</span>)</span></span><br><span class="line">         <span class="list">(<span class="keyword">*</span> <span class="list">(<span class="keyword">branch-length</span> <span class="list">(<span class="keyword">right-branch</span> mobile)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">total-weight</span> <span class="list">(<span class="keyword">branch-structure</span> <span class="list">(<span class="keyword">right-branch</span> mobile)</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> l <span class="list">(<span class="keyword">make-branch</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span> </span><br><span class="line"><span class="list">(<span class="keyword">define</span> r <span class="list">(<span class="keyword">make-branch</span> <span class="number">6</span> <span class="number">7</span>)</span>)</span> </span><br><span class="line"><span class="list">(<span class="keyword">define</span> s <span class="list">(<span class="keyword">make-branch</span> <span class="number">1</span> <span class="number">2</span>)</span>)</span> </span><br><span class="line"><span class="list">(<span class="keyword">define</span> x <span class="list">(<span class="keyword">make-mobile</span> s <span class="list">(<span class="keyword">make-branch</span> <span class="number">7</span> <span class="list">(<span class="keyword">make-mobile</span> l r)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">balanced</span>? x)</span></span><br><span class="line"><span class="comment">; =&gt; #f</span></span><br><span class="line"><span class="list">(<span class="keyword">balanced</span>? <span class="list">(<span class="keyword">make-mobile</span> l l)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br><span class="line"><span class="list">(<span class="keyword">balanced</span>? <span class="list">(<span class="keyword">make-mobile</span> r r)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br><span class="line"><span class="list">(<span class="keyword">balanced</span>? <span class="list">(<span class="keyword">make-mobile</span> <span class="list">(<span class="keyword">make-branch</span> <span class="number">3</span> <span class="number">4</span>)</span> <span class="list">(<span class="keyword">make-branch</span> <span class="number">2</span> <span class="number">6</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br></pre></td></tr></table></figure>
<p>问题 d 。如果改变了定义中的数据结构，需要改动哪些。</p>
<p>基本的选择子肯定要改，还有要改的地方是 <code>total-weight</code> 和 <code>balanced?</code> 中判断是否为最基本的 mobile 的 语句。</p>
<p>也就是 <code>(not (pair? mobile))</code> 。</p>
<p>之所以要该这里是因为这里没有引入抽象屏障，<code>total-weight</code> 和 <code>balanced?</code> 知道了 mobile 的实现。</p>
<h3 id="习题_2-30">习题 2.30</h3><blockquote>
<p><strong>Exercise 2.30.</strong>  Define a procedure <code>square-tree</code> analogous to the <code>square-list</code> procedure of exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.21" target="_blank" rel="external">2.21</a>. That is, <code>square-list</code> should behave as follows:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-tree</span></span><br><span class="line"> <span class="list">(<span class="keyword">list</span> <span class="number">1</span></span><br><span class="line">       <span class="list">(<span class="keyword">list</span> <span class="number">2</span> <span class="list">(<span class="keyword">list</span> <span class="number">3</span> <span class="number">4</span>)</span> <span class="number">5</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">list</span> <span class="number">6</span> <span class="number">7</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1</span> <span class="list">(<span class="number">4</span> <span class="list">(<span class="number">9</span> <span class="number">16</span>)</span> <span class="number">25</span>)</span> <span class="list">(<span class="number">36</span> <span class="number">49</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>Define <code>square-tree</code> both directly (i.e., without using any higher-order procedures) and also by using <code>map</code> and recursion.</p>
</blockquote>
<p>仿照 <code>scale-tree</code> 来做即可。</p>
<p>第一种，不使用高阶函数的类型</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-tree</span> tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">null</span>? tree)</span> <span class="list">()</span>)</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? tree)</span>)</span> <span class="list">(<span class="keyword">square</span> tree)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">else</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">square-tree</span> <span class="list">(<span class="keyword">car</span> tree)</span>)</span></span><br><span class="line">                    <span class="list">(<span class="keyword">square-tree</span> <span class="list">(<span class="keyword">cdr</span> tree)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>第二种，使用 <code>map</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-tree</span> tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">sub-tree</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? sub-tree)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">square</span> sub-tree)</span></span><br><span class="line">            <span class="list">(<span class="keyword">square-tree</span> sub-tree)</span>)</span>)</span></span><br><span class="line">      tree)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-31">习题 2.31</h3><blockquote>
<p><strong>Exercise 2.31.</strong>  Abstract your answer to exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.30" target="_blank" rel="external">2.30</a> to produce a procedure <code>tree-map</code> with the property that <code>square-tree</code> could be defined as</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">square-tree</span> tree)</span> <span class="list">(<span class="keyword">tree-map</span> square tree)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>只要照着上题把用到 <code>square</code> 的替换即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">tree-map</span> f tree)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">sub-tree</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? sub-tree)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">f</span> sub-tree)</span></span><br><span class="line">            <span class="list">(<span class="keyword">tree-map</span> f sub-tree)</span>)</span>)</span></span><br><span class="line">      tree)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">square-tree</span> <span class="quoted">'(<span class="number">1</span> (<span class="number">2</span> (<span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>) (<span class="number">6</span> <span class="number">7</span>))</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (1 (4 (9 16) 25) (36 49))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-32">习题 2.32</h3><blockquote>
<p><strong>Exercise 2.32.</strong>  We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is <code>(1 2 3)</code>, then the set of all subsets is <code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code>. Complete the following definition of a procedure that generates the set of subsets of a set and give a clear explanation of why it works:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">subsets</span> s)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? s)</span></span><br><span class="line">      <span class="list">(<span class="keyword">list</span> <span class="literal">nil</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">let</span> <span class="list">(<span class="list">(<span class="keyword">rest</span> <span class="list">(<span class="keyword">subsets</span> <span class="list">(<span class="keyword">cdr</span> s)</span>)</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">append</span> rest <span class="list">(<span class="keyword">map</span> &lt;??&gt; rest)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于 <code>(subset (list 1 2 3))</code> 中 <code>rest</code> 为 <code>(subset (list 2 3))</code> </p>
<p>即 <code>((3) (2) (2 3) () )</code> 。对比 <code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code></p>
<p>发现少了 <code>(1) (1 3) (1 2)</code>。</p>
<p>所以需要用 <code>map</code> 把每一个元素拼接成子集。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">subsets</span> s)</span></span><br><span class="line">    <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? s)</span></span><br><span class="line">        <span class="list">(<span class="keyword">list</span> <span class="quoted">'()</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">let</span> <span class="list">(<span class="list">(<span class="keyword">rest</span> <span class="list">(<span class="keyword">subsets</span> <span class="list">(<span class="keyword">cdr</span> s)</span>)</span>)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">append</span> rest <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span></span><br><span class="line">                                <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">car</span> s)</span> x)</span>)</span></span><br><span class="line">                              rest)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>()</code> 的子集是 <code>(())</code>。</p>
<h3 id="习题_2-33">习题 2.33</h3><blockquote>
<p><strong>Exercise 2.33.</strong>  Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">map</span> p sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span> y)</span> &lt;??&gt;)</span> <span class="literal">nil</span> sequence)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">append</span> seq1 seq2)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> cons &lt;??&gt; &lt;??&gt;)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">length</span> sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> &lt;??&gt; <span class="number">0</span> sequence)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意到 <code>accumulate</code> 中的函数第一个参数 <code>x</code> 是当前 <code>sequance</code> 的值，<code>y</code> 是累积的值。</p>
<p>所以只需要运算后拼接起来就可以了。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">map</span> p sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span> y)</span> <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">p</span> x)</span> y)</span>)</span> <span class="literal">nil</span> sequence)</span>)</span></span><br></pre></td></tr></table></figure>
<p>对于 <code>append</code> 只需要将 <code>seq1</code> 中的元素一个个 <code>cons</code> 上去即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">append</span> seq1 seq2)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> cons seq2 seq1)</span>)</span></span><br></pre></td></tr></table></figure>
<p>计算长度，每个元素 + 1 长度。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">length</span> sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span> y)</span> <span class="list">(<span class="keyword">+</span> y <span class="number">1</span>)</span>)</span> <span class="number">0</span> sequence)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-34">习题 2.34</h3><blockquote>
<p><strong>Exercise 2.34.</strong>  Evaluating a polynomial in $x$ at a given value of $x$ can be formulated as an accumulation. We evaluate the polynomial<br>$$<br>a_nr^n + a_{n-1}r^{n-1} + \cdots + a_1r + a_0<br>$$<br>using a well-known algorithm called <em>Horner’s rule</em>, which structures the computation as<br>$$<br>(\cdots(a_nr + a_{n-1})r + \cdots + a_1)r + a_0<br>$$<br>In other words, we start with $a_n$ multiply by $x$, add $a_{n-1}$, multiply by $x$, and so on, until we reach $a_0$.<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_186" target="_blank" rel="external">16</a> Fill in the following template to produce a procedure that evaluates a polynomial using Horner’s rule. Assume that the coefficients of the polynomial are arranged in a sequence, from $a_0$ through $a_n$.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">horner-eval</span> x coefficient-sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">this-coeff</span> higher-terms)</span> &lt;??&gt;)</span></span><br><span class="line">              <span class="number">0</span></span><br><span class="line">              coefficient-sequence)</span>)</span></span><br></pre></td></tr></table></figure>
<p>For example, to compute $1+3x+5x^3+x^5$ at  $x = 2$ you would evaluate</p>
<p><code>(horner-eval 2 (list 1 3 0 5 0 1))</code></p>
</blockquote>
<p>注意到 <code>accumulate</code> 的计算顺序是从右到左。所以只需要重复计算 $a_nr+a_{n-1}$ 即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">horner-eval</span> x coefficient-sequence)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">this-coeff</span> higher-terms)</span>   <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">*</span> higher-terms x)</span></span><br><span class="line">                                                       this-coeff)</span>)</span></span><br><span class="line">              <span class="number">0</span></span><br><span class="line">              coefficient-sequence)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">horner-eval</span> <span class="number">1</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; 10</span></span><br><span class="line"><span class="list">(<span class="keyword">horner-eval</span> <span class="number">2</span> <span class="list">(<span class="keyword">list</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; 79</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-35">习题 2.35</h3><blockquote>
<p><strong>Exercise 2.35.</strong>  Redefine <code>count-leaves</code> from section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.2" target="_blank" rel="external">2.2.2</a> as an accumulation:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">count-leaves</span> <span class="literal">t</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> &lt;??&gt; &lt;??&gt; <span class="list">(<span class="keyword">map</span> &lt;??&gt; &lt;??&gt;)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>用 <code>map</code> 遍历数，如果是叶子就长度 + 1，不是就计算叶子数量。这样累加就能得到答案。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">count-leaves</span> <span class="literal">t</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> + <span class="number">0</span> <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">sub-tree</span>)</span></span><br><span class="line">                         <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">not</span> <span class="list">(<span class="keyword">pair</span>? sub-tree)</span>)</span></span><br><span class="line">                             <span class="number">1</span></span><br><span class="line">                             <span class="list">(<span class="keyword">count-leaves</span> sub-tree)</span>)</span>)</span></span><br><span class="line">                       <span class="literal">t</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-36">习题 2.36</h3><blockquote>
<p><strong>Exercise 2.36.</strong>  The procedure <code>accumulate-n</code> is similar to <code>accumulate</code> except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation procedure to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results. For instance, if <code>s</code> is a sequence containing four sequences, <code>((1 2 3) (4 5 6) (7 8 9) (10 11 12))</code>, then the value of <code>(accumulate-n + 0 s)</code> should be the sequence <code>(22 26 30)</code>. Fill in the missing expressions in the following definition of <code>accumulate-n</code>:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">accumulate-n</span> op init seqs)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? <span class="list">(<span class="keyword">car</span> seqs)</span>)</span></span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">accumulate</span> op init &lt;??&gt;)</span></span><br><span class="line">            <span class="list">(<span class="keyword">accumulate-n</span> op init &lt;??&gt;)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于空的序列 <code>(())</code> 结果为 <code>()</code>。</p>
<p>对于非空序列 <code>((1 2) (3 4))</code> 结果是 <code>(cons (list 1 3) (list 2 4))</code></p>
<p>所以要得到序列中的每一个元素，使用 <code>map car</code> 。</p>
<p>剩下的类似</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">accumulate-n</span> op init seqs)</span></span><br><span class="line">  <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">null</span>? <span class="list">(<span class="keyword">car</span> seqs)</span>)</span></span><br><span class="line">      <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">cons</span> <span class="list">(<span class="keyword">accumulate</span> op init <span class="list">(<span class="keyword">map</span> car seqs)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">accumulate-n</span> op init <span class="list">(<span class="keyword">map</span> cdr seqs)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">accumulate-n</span> + <span class="number">0</span> <span class="quoted">'(())</span>)</span></span><br><span class="line"><span class="comment">; =&gt; ()</span></span><br><span class="line"><span class="list">(<span class="keyword">accumulate-n</span> + <span class="number">0</span> <span class="quoted">'((<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) (<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>) (<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>))</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (12 15 18)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-37">习题 2.37</h3><blockquote>
<p><strong>Exercise 2.37.</strong>  Suppose we represent vectors $v = (v_i)$  as sequences of numbers, and matrices $m = (m_{ij})$ as sequences of vectors (the rows of the matrix). For example, the matrix<br>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 &amp; 4\\<br>4 &amp; 5 &amp; 6 &amp; 6\\<br>6 &amp; 7 &amp; 8 &amp; 9<br>\end{bmatrix}<br>$$<br>is represented as the sequence <code>((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>. With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:</p>
<table>
<thead>
<tr>
<th><code>(dot-product v w)</code></th>
<th>returns the sum $\sum_{i} v_iw_i$</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(matrix-*-vector m v)</code></td>
<td>returns the vector $t$, where $t_i = \sum_j m_{ij}v_j$</td>
</tr>
<tr>
<td><code>(matrix-*-matrix m n)</code></td>
<td>returns the matrix $p$, where $p_{ij} = \sum_{k} m_{ik}n_{kj}$</td>
</tr>
<tr>
<td><code>(transpose m)</code></td>
<td>returns the matrix $n$, where $n_{ij} = m_{ji}$</td>
</tr>
</tbody>
</table>
<p>We can define the dot product as<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_190" target="_blank" rel="external">17</a></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">dot-product</span> v w)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate</span> + <span class="number">0</span> <span class="list">(<span class="keyword">map</span> <span class="variable">* v w)))</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>Fill in the missing expressions in the following procedures for computing the other matrix operations. (The procedure <code>accumulate-n</code> is defined in exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.36" target="_blank" rel="external">2.36</a>.)</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">matrix-*-vector</span> m v)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> &lt;??&gt; m)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">transpose</span> mat)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate-n</span> &lt;??&gt; &lt;??&gt; mat)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">matrix-*-matrix</span> m n)</span></span><br><span class="line">  <span class="list">(<span class="keyword">let</span> <span class="list">(<span class="list">(<span class="keyword">cols</span> <span class="list">(<span class="keyword">transpose</span> n)</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">map</span> &lt;??&gt; m)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>先看 <code>matrix-*-vector</code> 中 <code>map</code> 后是一个 vector ，根据矩阵和向量乘法的定义，需要两个向量相乘。</p>
<p>所以需要使用 <code>dot-product</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">matrix-*-vector</span> m v)</span></span><br><span class="line">  <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">mi</span>)</span> <span class="list">(<span class="keyword">dot-product</span> v mi)</span>)</span> m)</span>)</span></span><br></pre></td></tr></table></figure>
<p>对于转置 <code>transpose</code> ，每个元素之间只需要 <code>cons</code> </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">transpose</span> mat)</span></span><br><span class="line">  <span class="list">(<span class="keyword">accumulate-n</span> cons <span class="quoted">'()</span> mat)</span>)</span></span><br></pre></td></tr></table></figure>
<p>然后是矩阵相乘，<code>matrix-*-matrix</code> 中的 <code>map</code> 后是一个 vector，而 $n$ 转置后还是一个矩阵。</p>
<p>将转置过后 $n$ 的每一行和 $m$ 每一行相乘。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">matrix-*-matrix</span> m n)</span></span><br><span class="line">  <span class="list">(<span class="keyword">let</span> <span class="list">(<span class="list">(<span class="keyword">cols</span> <span class="list">(<span class="keyword">transpose</span> n)</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">mi</span>)</span> <span class="list">(<span class="keyword">map</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">ni</span>)</span> <span class="list">(<span class="keyword">dot-product</span> ni mi)</span>)</span> cols)</span> m)</span>)</span>)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没填坑都快忘了……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SICP" scheme="http://en.ors-sro.com/tags/SICP/"/>
    
  </entry>
  
  <entry>
    <title>词法作用域和动态作用域</title>
    <link href="http://en.ors-sro.com/Lexical-scoppe-and-Dynamic-scoppe/"/>
    <id>http://en.ors-sro.com/Lexical-scoppe-and-Dynamic-scoppe/</id>
    <published>2017-04-23T08:29:24.000Z</published>
    <updated>2017-04-23T08:48:02.363Z</updated>
    
    <content type="html"><![CDATA[<p>不知道也可以好好写程序。</p>
<a id="more"></a>
<h2 id="定义">定义</h2><p>写代码的时候，经常使用变量名来代替字面量和输入的内容。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String prefix = <span class="string">"Your name is "</span>;</span><br><span class="line">String name = Console.readLine();</span><br><span class="line">Console.WriteLine(prefix + name);</span><br></pre></td></tr></table></figure>
<p><strong>定义变量</strong>是将值（字面量或者输入）绑定到变量名字的一个过程。</p>
<p>那使用变量的时候，就要有一个相反的过程。</p>
<p><strong>解析变量</strong>是将变量名字按照绑定解析为值的一个过程。</p>
<p>在上述例子中 <code>String prefix = &quot;Your name is &quot;</code> 定义了一个绑定 <code>prefix -&gt; &quot;Your name is &quot;</code></p>
<p>在 <code>Console.WriteLine(prefix + name)</code> 解析 <code>prefix</code> 时，</p>
<p>按照绑定 <code>prefix -&gt; &quot;Your name is &quot;</code> 替换 <code>prefix</code> 为 <code>&quot;Your name is &quot;</code>。</p>
<p>词法作用域和动态作用域描述的是变量解析时的规则。</p>
<p><strong>词法作用域</strong>是解析变量时从词法环境查找变量值的规则。在实际应用中，词法环境通常是块级作用域，函数作用域等。也就是会跟源码有关，先从定义时的作用域查找，找不到再查找外层作用域。因为查找的路径跟源码有关，可以在编译时确定，所以又称为静态作用域。现代语言大多使用静态作用域。</p>
<p><strong>动态作用域</strong>是解析变量时从执行环境查找变量值的规则。在实际应用中，执行环境通常是调用栈。也就是会跟运行状态有关。先从运行的函数中查找，找不到再顺着调用栈中的其他函数查找。因为查找的路径与调用顺序有关，只能在运行时确定，所以称为动态作用域。只有少数语言使用动态作用域。</p>
<h2 id="例子">例子</h2><p>定义不是那么直观。看一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">g(); <span class="comment">// 返回 0 还是返回 1 ？</span></span><br></pre></td></tr></table></figure>
<p>按照直觉，也就是现代语言的方式（静态作用域），执行 <code>f()</code>  ，<code>f</code> 中返回 <code>x</code> 。</p>
<p><code>x</code> 没有在 <code>f</code> 中定义，所以就去外层（全局）中查找，找到定义为 <code>var x = 0</code> 。</p>
<p>所以返回 0 。</p>
<p>按照动态作用域的定义，执行 <code>f()</code> ，<code>f</code> 中返回 <code>x</code> 。</p>
<p><code>x</code> 没有在 <code>f</code> 中定义，所以顺着调用栈查找，<code>f</code> 是被 <code>g</code> 调用的。</p>
<p><code>g</code> 中定义 <code>var x = 1</code> 。</p>
<p>所以返回 1 。</p>
<p>因此词法作用域可以看源代码就能确定 <code>f()</code> 的返回值，而动态作用域得在运行时才能确定，取决于谁调用了 <code>f()</code>。</p>
<h2 id="历史">历史</h2><p>静态作用域因为很符合直觉。所以一出现就纷纷被采用。所以现在大部分语言都是静态作用域。</p>
<p>那为什么一开始语言没有采用静态作用域而是动态作用域呢？</p>
<p>因为动态作用域太容易实现了。</p>
<p>定义变量就把变量名和值的绑定推到栈上。</p>
<p>解析变量就是顺着栈查找。</p>
<p>相当于只有一个词法环境，也就是全局词法环境。</p>
<p>而要实现词法作用域就不是那么简单了。首先要规定词法环境，最小的词法环境是块级作用域还是函数作用域。</p>
<p>然后还要在词法分析的时候做相应的工作。</p>
<p>词法作用域首先出现于 ALGOL ，后被 Scheme 和 Common Lisp 采用。</p>
<p>现在大部分语言都使用词法作用域。</p>
<h2 id="现存">现存</h2><p>即使是采用词法作用域的语言，也有使用动态作用域的地方。</p>
<p>C 语言中，宏展开使用的是动态作用域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> a (x + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x = <span class="number">0</span>; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span> <span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span> </span>&#123; b(); c(); &#125;</span><br></pre></td></tr></table></figure>
<p>按照词法作用域的原则，宏 <code>a</code> 中的 <code>x</code> 应该为 2 。与被谁调用无关。</p>
<p>但实际是 <code>b()</code> 打印出 1 。<code>c()</code> 打印出 2 。</p>
<p>所以宏展开是动态作用域。</p>
<p>因此 《C ++ Primer 》推荐少用宏。当然除了这个原因还有一个宏卫生的原因。</p>
<p>JavaScript 也用静态作用域，但可以使用 <code>eval()</code> 模拟动态作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = x =&gt; <span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    print(x);</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g_ = <span class="built_in">eval</span>(<span class="string">"("</span> + <span class="built_in">String</span>(g) + <span class="string">")"</span>);</span><br><span class="line">    <span class="comment">/*  g_ = function g() &#123;</span><br><span class="line">      print(x);</span><br><span class="line">      x = 2;</span><br><span class="line">    &#125; */</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">    g_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();                         <span class="comment">// prints 3</span></span><br><span class="line"></span><br><span class="line">print(x);                    <span class="comment">// prints 1</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li><a href="1">维基</a></li>
<li><a href="http://stackoverflow.com/questions/11533771/scope-rules-for-c-macros" target="_blank" rel="external">Scope rules for C macros</a></li>
<li><a href="http://stackoverflow.com/questions/10060857/is-it-possible-to-achieve-dynamic-scoping-in-javascript-without-resorting-to-eva" target="_blank" rel="external">Is it possible to achieve dynamic scoping in JavaScript without resorting to eval?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道也可以好好写程序。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="作用域" scheme="http://en.ors-sro.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 闭包</title>
    <link href="http://en.ors-sro.com/JavaScript-Closure/"/>
    <id>http://en.ors-sro.com/JavaScript-Closure/</id>
    <published>2017-04-16T10:07:07.000Z</published>
    <updated>2017-04-16T10:13:35.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>闭包是穷人的对象。对象是穷人的闭包。</p>
</blockquote>
<a id="more"></a>
<h2 id="定义">定义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetCounter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> ++c&#125;</span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = GetCounter()</span><br><span class="line">counter()</span><br></pre></td></tr></table></figure>
<p>这段代码的返回值是 <code>undefined</code> 还是 1 ？</p>
<p>答案是 1 。</p>
<p>因为这是 JavaScript 的一个重要特性——闭包（Closure）。</p>
<p>闭包是一个包含函数和其变量绑定的对象。</p>
<p>例如上述代码中，<code>counter</code> 是一个闭包。</p>
<p>其中函数为 <code>function count() {return ++c}</code> ，变量绑定为 <code>{c: GetCounter.c}</code>。</p>
<h2 id="释疑">释疑</h2><p>如果你学习过 C 系列的语言，可能会感到疑惑。</p>
<p>函数返回了怎么还能引用其中的局部变量。</p>
<p>这是因为 JavaScript 有两个特性——词法作用域和一等公民函数。</p>
<p>先说词法作用域，简单来说词法作用域是描述查找变量的值的一种规则——从定义处查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = FunctionScope()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>这段代码的返回值是什么？是 <code>ReferenceError</code> 吗？</p>
<p>不一定。因为还不知道 <code>scope</code> 的定义。</p>
<p>那从哪获取 <code>scope</code> 的定义呢。当然是从这段代码所处的地方获取。</p>
<p>假设改成这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">"global scope"</span></span><br><span class="line"><span class="keyword">let</span> f = FunctionScope()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>那么代码的返回值就是 <code>&quot;global scope&quot;</code>。因为所处的作用域有变量绑定<code>{scope: global.scope}</code> （这里使用 Javascript 的对象语法来表示变量绑定）</p>
<p>如果改成这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> scope = <span class="string">"function scope"</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">"global scope"</span></span><br><span class="line"><span class="keyword">let</span> f = FunctionScope()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>那么代码的返回值是<code>&quot;function scope&quot;</code> 。为什么不是 <code>&quot;global scope&quot;</code> 呢？</p>
<p>因为定义函数同时会定义作用域。</p>
<p>定义 <code>FunctionScope</code> 的时候也定义了 <code>{scope: FunctionScope.scope}</code></p>
<p>将这个作用域插入到作用域链中，整个作用域链为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;scope: FunctionScope.scope&#125; -&gt; &#123;scope: global.scope&#125;</span><br></pre></td></tr></table></figure>
<p>按照词法作用域的规则，变量的值从定义处查找。所以先从 <code>{scope: FunctionScope}</code> 中查找。</p>
<p>发现有记录，通过引用 <code>FunctionScope.scope</code> 找到值 <code>&quot;function scope&quot;</code> 。所以返回 <code>&quot;function scope&quot;</code> 。如果找不到，就顺着作用域链查找直到找不到抛出 <code>ReferenceError</code></p>
<p>如果仅仅有词法作用域是不够的。C 语言也是词法作用域，但是并没有听说过闭包。</p>
<p>这是因为 Javascript 将函数视为一等公民。</p>
<p>所以函数可以随意的创建，赋值到变量，传递为参数，作为返回值等。</p>
<p>这里最重要的是可以在函数中定义函数。</p>
<p>JavaScript 定义函数的时候会创建函数作用域，将当前环境中的变量通过引用的方式记录下来。</p>
<p>在上述例子中，<code>f()</code> 定义的同时定义了函数作用域 <code>{scope: FunctionScope.scope}</code> </p>
<p>返回 <code>f()</code> 也会连同函数作用域一同返回。</p>
<p>如果一个变量没有引用，就会被垃圾收集器回收。比如函数中的局部变量，在函数执行完后没有引用就会被回收。</p>
<p>但是如果返回了函数，比如说 <code>f()</code> 因为函数作用域 <code>{scope: FunctionScope.scope}</code> 引用了 <code>scope</code> 所以 <code>scope</code> 不会被回收。</p>
<p>所以函数执行完后还可以使用局部变量。</p>
<h2 id="注意">注意</h2><p>理论上所有函数都是闭包，但是因为有的函数没有访问内部变量，所以没有闭包的感觉。</p>
<p>返回函数是定义闭包的一种方式，但不是唯一方式。</p>
<p>比如还可以返回一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">   reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; n = <span class="number">0</span>; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个闭包定义调用两次返回不同的闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = counter(), d = counter(); <span class="comment">// 创造两个 counter</span></span><br><span class="line">c.count() <span class="comment">// =&gt; 0</span></span><br><span class="line">d.count() <span class="comment">// =&gt; 0: 独立计数</span></span><br><span class="line">c.reset() <span class="comment">// reset() 和 count() 方法共享状态</span></span><br><span class="line">c.count() <span class="comment">// =&gt; 0: 因为重置了 c</span></span><br><span class="line">d.count() <span class="comment">// =&gt; 1: d 没有重置</span></span><br></pre></td></tr></table></figure>
<p>闭包中的变量绑定只记录引用，不记录具体的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Funcs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> funcs = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> i&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> functions = Funcs()</span><br><span class="line">functions[<span class="number">2</span>]()</span><br></pre></td></tr></table></figure>
<p>所以这段代码返回的是 5 不是 2。因为循环结束后 <code>i</code> 的值为 5。</p>
<p>还需要注意的一点是闭包中的 <code>this</code> 不是外层的 <code>this</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a &#125;</span><br><span class="line">  <span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = f()</span><br><span class="line">h()</span><br></pre></td></tr></table></figure>
<p>这段代码会返回 <code>undefined</code> 因为 <code>g</code> 中的 <code>this.a</code> 的 <code>this</code> 指的是 <code>g</code>。</p>
<p>因为 <code>g</code> 中没有变量 <code>a</code> 的定义，所以返回 <code>undefined</code>。</p>
<p>只要改成 <code>self.a</code> 就可以了。</p>
<p>此外还可以使用 ES6 的箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> g = () =&gt; a</span><br><span class="line">  <span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = f()</span><br><span class="line">h()</span><br></pre></td></tr></table></figure>
<h2 id="最后">最后</h2><p>文章的内容参考了<a href="http://shop.oreilly.com/product/9780596805531.do" target="_blank" rel="external">犀牛书</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;闭包是穷人的对象。对象是穷人的闭包。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavsScript" scheme="http://en.ors-sro.com/tags/JavsScript/"/>
    
  </entry>
  
  <entry>
    <title>值类别</title>
    <link href="http://en.ors-sro.com/Value-Category/"/>
    <id>http://en.ors-sro.com/Value-Category/</id>
    <published>2017-04-09T13:55:24.000Z</published>
    <updated>2017-04-09T14:14:11.532Z</updated>
    
    <content type="html"><![CDATA[<p>如何把一个简单的事情搞复杂。</p>
<a id="more"></a>
<h2 id="简单的开始">简单的开始</h2><p>左值和右值是 C 和 C++ 语言中表达式的一种值的分类。每个表达式都有类型和值类别。</p>
<p>如 <code>1 + 1</code> 的类型为 <code>int</code> ，值类别为右值。</p>
<p>在 C++ 03 左值和右值很容易区分。</p>
<p>左值（left value, lvalue）为内存地址，可以出现在赋值等号的左边和右边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// x 是左值</span></span><br><span class="line"><span class="keyword">int</span> y = x; <span class="comment">// x 可以出现在赋值等号的右边</span></span><br></pre></td></tr></table></figure>
<p>右值（right value, rvalue）为<strong>只能</strong>出现在赋值等号右边的表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// x 是右值</span></span><br><span class="line"><span class="number">1</span> = x; <span class="comment">// 出错， 1 是右值，只能出现在赋值等号的右边。</span></span><br></pre></td></tr></table></figure>
<h2 id="复杂的延续">复杂的延续</h2><p>C++ 11 引入了移动语义。</p>
<p>对于类型 T ，<code>T&amp;&amp;</code> 称为右值引用 （rvalue reference）。<code>T&amp;</code> 称为左值引用（lvalue reference）。</p>
<p>如果类型 T 实现了移动构造函数，则称 T 为可移动的。</p>
<p>引入了语义，问题随之而来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; f() &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>那么 <code>f()</code> 是左值还是右值？</p>
<p><code>f()</code> 不是左值因为左值不可移动。</p>
<p><code>f()</code> 不是右值因为可以出现在赋值等号的左边。</p>
<p>所以引入一种新的值类别，称为<strong>亡值</strong>（eXpiring value, <strong>xvalue</strong>）。<code>f()</code> 为亡值。</p>
<p>原先的左值变成了<strong>泛左值</strong>（generalized value, <strong>glvalue</strong>）。</p>
<p>原先的右值变成了<strong>纯右值</strong>（pure value, <strong>prvalue</strong>）。</p>
<p>定义新的<strong>左值</strong>为非亡值的泛左值。</p>
<p>定义新的<strong>右值</strong>为纯右值或者亡值。</p>
<p>用图表示就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;                                                                     +----------------+&#10;                                                                     |                |&#10;                                                          +---------&#62;+      &#24038; &#20540;     |&#10;                                                          |          |                |&#10;                                 +----------------+       |          +----------------+&#10;                                 |                |       |&#10;                         +------&#62;+    &#27867; &#24038; &#20540;    +-------+&#10;                         |       |                |       |&#10;+----------------+       |       +----------------+       |          +----------------+&#10;|                |       |                                |          |                |&#10;|    &#20540; &#31867; &#21035;     +-------+                                +---------&#62;+     &#20129; &#20540;      |&#10;|                |       |                                |          |                |&#10;+----------------+       |       +----------------+       |          +----------------+&#10;                         |       |                |       |&#10;                         +------&#62;+    &#32431; &#21491; &#20540;    +-------+&#10;                                 |                |       |&#10;                                 +----------------+       |          +----------------+&#10;                                                          |          |                |&#10;                                                          +---------&#62;+      &#21491; &#20540;     |&#10;                                                                     |                |&#10;                                                                     +----------------+</span><br></pre></td></tr></table></figure>
<p>表达式一定是左值，亡值，右值中的一种。</p>
<p>左值等具体代码可参考<a href="http://en.cppreference.com/w/cpp/language/value_category#Primary categories" target="_blank" rel="external">基础类别</a>。</p>
<p>具体的定义可以参考<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf" target="_blank" rel="external">n3055</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何把一个简单的事情搞复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://en.ors-sro.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>停机问题</title>
    <link href="http://en.ors-sro.com/Halting-problem/"/>
    <id>http://en.ors-sro.com/Halting-problem/</id>
    <published>2017-04-02T05:49:01.000Z</published>
    <updated>2017-04-09T10:26:08.513Z</updated>
    
    <content type="html"><![CDATA[<p>如果存在这样的算法就太完美了。</p>
<a id="more"></a>
<h2 id="定义">定义</h2><blockquote>
<p><strong>停机问题</strong>（英语：halting problem）是<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91" target="_blank" rel="external">逻辑数学</a>中<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%A1%E7%AE%97%E6%80%A7%E7%90%86%E8%AE%BA" target="_blank" rel="external">可计算性理论</a>的一个问题。通俗地说，停机问题就是判断任意一个<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F" target="_blank" rel="external">程序</a>是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。</p>
<p>—— 维基百科</p>
</blockquote>
<p>程序为什么会不停机呢？程序有三种结构 —— 顺序结构，条件结构，循环结构。</p>
<p>如果程序只允许使用顺序结构和条件结构，而且代码行数是有限的，那么程序一定会停机。</p>
<p>但如果使用了循环结构（包括递归），就有可能陷入死循环。因为可能由于程序 BUG 等原因导致无限递归或者无线循环。</p>
<p>停机问题找寻的是一种<strong>通用</strong>的算法。如果是一段具体的代码还是可以判断出是否停机的。</p>
<h2 id="理发师">理发师</h2><p>如果一个人不给自己理发，那么理发师就给他理发。</p>
<p>如果一个人自己理发，那么理发师就不给他理发。</p>
<p>那么理发师给不给自己理发？</p>
<p>如果理发师给自己理发，那么按照一个人自己理发的原则，理发师就不应该给这个理发。</p>
<p>如果理发师不给自己理发，那么按照一个人不给自己理发的原则，理发师应该给自己理发。</p>
<p>本质上这是一阶逻辑自我指涉的不自洽性。</p>
<h2 id="证明">证明</h2><p>停机问题的证明类似理发师悖论。</p>
<p>如果存在一个判断程序是否停机的算法，停机的时候返回 1 ，不停机返回 0 。</p>
<p>那么构造一个相反的算法，停机的时候返回 0 ，不停机的是否返回 1 。</p>
<p>如果用停机算法判断这个相反的算法结果会是怎样。</p>
<p>如果结果是停机，根据停机算法的定义得出相反的算法会停机。但是这跟相反算法的定义矛盾。相反算法定义为与停机算法结果相反。停机算法结果是停机，那么相反算法会不停机。</p>
<p>如果结果是不停机，根据停机算法的定义得出相反的算法不停机。但是这跟相反算法的定义矛盾。相反算法定义为与停机算法结果相反。停机算法的结果是不停机，那么相反算法会停机。</p>
<p>所以不存在<strong>通用</strong>的停机检测算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果存在这样的算法就太完美了。&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="逻辑" scheme="http://en.ors-sro.com/tags/%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>Monad Transformers</title>
    <link href="http://en.ors-sro.com/Monad-Transformers/"/>
    <id>http://en.ors-sro.com/Monad-Transformers/</id>
    <published>2017-03-26T11:22:50.000Z</published>
    <updated>2017-03-26T13:04:26.901Z</updated>
    
    <content type="html"><![CDATA[<p>组合两个 Monad 的 Monad</p>
<a id="more"></a>
<p>本文为 <a href="https://en.wikibooks.org/wiki/Haskell/Monad_transformers" target="_blank" rel="external">Monad Transformers</a> 的学习笔记。</p>
<h2 id="困境">困境</h2><p>有时候需要校验输入内容。比如验证是否为符合要求的密码</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="import"><span class="keyword">import</span> Data.Char</span></span><br><span class="line"><span class="import"><span class="keyword">import</span> Data.Maybe</span></span><br><span class="line"></span><br><span class="line"><span class="title">isValid</span> :: <span class="type">String</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isValid</span> s = length s &gt;= <span class="number">8</span></span><br><span class="line">            &amp;&amp; any isAlpha s</span><br><span class="line">            &amp;&amp; any isNumber s</span><br><span class="line">            &amp;&amp; any isPunctuation s</span><br></pre></td></tr></table></figure>
<p>获取输入</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 因为需要携带值，所以这里使用 Maybe String 而不是 Bool</span></span><br><span class="line"><span class="title">getPassphrase</span> :: <span class="type">IO</span> (<span class="type">Maybe</span> <span class="type">String</span>)</span><br><span class="line"><span class="title">getPassphrase</span> = <span class="keyword">do</span> s &lt;- getLine</span><br><span class="line">                   <span class="keyword">if</span> isValid s <span class="keyword">then</span> return $ <span class="type">Just</span> s</span><br><span class="line">                                <span class="keyword">else</span> return <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>校验</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">askPassphrase</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">askPassphrase</span> = <span class="keyword">do</span> putStrLn <span class="string">"请输入密码："</span></span><br><span class="line">                   maybe_value &lt;- getPassphrase</span><br><span class="line">                   <span class="keyword">if</span> isJust maybe_value <span class="comment">-- 这里手动判断是否合法</span></span><br><span class="line">                     <span class="keyword">then</span> <span class="keyword">do</span> putStrLn maybe_value ++ <span class="string">" 是个不错的密码"</span> </span><br><span class="line">                     <span class="keyword">else</span> return ()</span><br></pre></td></tr></table></figure>
<p>代码中使用 <code>isJust</code> 判断是否合法。在数量比较少的情况下不是什么问题。通常使用 Maybe Monad 是不需要手动判断是否为 <code>Just</code> 。因为有 <code>&gt;&gt;=</code> 。</p>
<p>所以这里是否能使用 Maybe Monad 来避免手动检查呢。</p>
<p>假设去点 <code>isJust</code> 的三行判断代码。从新编写一个函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">askPassphrase</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">askPassphrase</span> = <span class="keyword">do</span> putStrLn <span class="string">"请输入密码："</span></span><br><span class="line">                   maybe_value &lt;- getPassphrase</span><br><span class="line">                   maybe_value &gt;&gt;= f</span><br></pre></td></tr></table></figure>
<p>这个 <code>f</code> 的类型是什么呢？</p>
<p>首先 <code>askPassphrase</code> 的类型是 <code>IO ()</code> 。所以 <code>f</code> 需要返回 <code>IO ()</code></p>
<p>而 <code>f</code> 又接受一个 <code>String</code> 类型的参数。</p>
<p>所以 <code>f</code> 的类型应该是</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure>
<p>但是这样不能用于 <code>maybe_value &gt;&gt;= f</code> 因为 <code>&gt;&gt;=</code> 的类型是</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t (&gt;&gt;=)</span><br><span class="line">(&gt;&gt;=) :: <span class="type">Monad</span> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure>
<p>所以要使用 <code>&gt;&gt;=</code> ，<code>f</code> 的类型必须是</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">String</span> -&gt; <span class="type">Maybe</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>显然两个类型冲突了，所以写不出来。</p>
<p>所以需要一个能够组合 Maybe Monad 和 IO Monad 的类型。</p>
<p>这个就是 Monad Transformers</p>
<h2 id="定义">定义</h2><p>定义 Maybe Monad 的 Monad Transformer <code>MaybeT</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">newtype</span> <span class="type">MaybeT</span> m a = <span class="type">MaybeT</span> <span class="container">&#123; <span class="title">runMaybeT</span> :: <span class="title">m</span> (<span class="type">Maybe</span> <span class="title">a</span>) &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>其中 m 可以为任意 Monad</p>
<p>Monad Transformer 本身也是 Monad 。所以需要实现 <code>return</code> 和 <code>&gt;&gt;=</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">Monad</span> <span class="container">(<span class="type">MaybeT</span> <span class="title">m</span>)</span> <span class="keyword">where</span></span></span><br><span class="line">    return  = <span class="type">MaybeT</span> . return . <span class="type">Just</span></span><br><span class="line">    <span class="comment">-- return a = MaybeT . return . Just a</span></span><br></pre></td></tr></table></figure>
<p><code>Just</code> 将 a 转化为 <code>Maybe a</code> 类型</p>
<p><code>return</code> 将 <code>Maybe a</code> 转化为 <code>m (Maybe a)</code> 类型</p>
<p><code>MaybeT</code> 将 <code>m (Maybe a)</code> 转化为 <code>MaybeT m (Maybe a)</code> 类型。</p>
<p>接着实现 <code>&gt;&gt;=</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (&gt;&gt;=) 定义中的 m 为 MaybeT m</span></span><br><span class="line">(&gt;&gt;=) :: <span class="type">MaybeT</span> m a -&gt; (a -&gt; <span class="type">MaybeT</span> m b) -&gt; <span class="type">MaybeT</span> m b</span><br><span class="line"></span><br><span class="line"><span class="title">x</span> &gt;&gt;= f = <span class="type">MaybeT</span> $ <span class="keyword">do</span> maybe_value &lt;- runMaybeT x</span><br><span class="line">                      <span class="keyword">case</span> maybe_value <span class="keyword">of</span></span><br><span class="line">                           <span class="type">Nothing</span>    -&gt; return <span class="type">Nothing</span></span><br><span class="line">                           <span class="type">Just</span> value -&gt; runMaybeT $ f value</span><br></pre></td></tr></table></figure>
<p>为了使用方便，顺便实现相应的 MonadPlus 和 MonadTrans</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadPlus</span> <span class="container">(<span class="type">MaybeT</span> <span class="title">m</span>)</span> <span class="keyword">where</span></span></span><br><span class="line">    mzero     = <span class="type">MaybeT</span> $ return <span class="type">Nothing</span></span><br><span class="line">    mplus x y = <span class="type">MaybeT</span> $ <span class="keyword">do</span> maybe_value &lt;- runMaybeT x</span><br><span class="line">                            <span class="keyword">case</span> maybe_value <span class="keyword">of</span></span><br><span class="line">                                 <span class="type">Nothing</span>    -&gt; runMaybeT y</span><br><span class="line">                                 <span class="type">Just</span> _     -&gt; return maybe_value</span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">MonadTrans</span> <span class="type">MaybeT</span> <span class="keyword">where</span></span></span><br><span class="line">    lift = <span class="type">MaybeT</span> . (liftM <span class="type">Just</span>)</span><br></pre></td></tr></table></figure>
<h2 id="改写">改写</h2><p>有了 <code>MaybeT</code> 代码可以这么写</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getValidPassphrase</span> :: <span class="type">MaybeT</span> <span class="type">IO</span> <span class="type">String</span></span><br><span class="line"><span class="title">getValidPassphrase</span> = <span class="keyword">do</span> s &lt;- lift getLine <span class="comment">-- 将 IO String 提升为 Maybe (IO String)</span></span><br><span class="line">                        guard (isValid s) <span class="comment">-- MonadPlus 类型类使我们能够使用 guard. 这里 s 为 String 类型</span></span><br><span class="line">                        return s</span><br><span class="line"></span><br><span class="line"><span class="title">askPassphrase</span> :: <span class="type">MaybeT</span> <span class="type">IO</span> ()</span><br><span class="line"><span class="title">askPassphrase</span> = <span class="keyword">do</span> lift $ putStrLn <span class="string">"输入新密码:"</span> <span class="comment">-- 将 IO () 提升为 Maybe (IO ())</span></span><br><span class="line">                   value &lt;- getValidPassphrase <span class="comment">-- value 为 String 类型</span></span><br><span class="line">                   lift $ putStrLn <span class="string">"储存中..."</span></span><br></pre></td></tr></table></figure>
<p>没有了检查的过程，因为全都藏在 <code>MaybeT</code> 的 <code>&gt;&gt;=</code> 里面了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组合两个 Monad 的 Monad&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Haskell" scheme="http://en.ors-sro.com/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Generator</title>
    <link href="http://en.ors-sro.com/ES6-Generator/"/>
    <id>http://en.ors-sro.com/ES6-Generator/</id>
    <published>2017-03-19T10:09:15.000Z</published>
    <updated>2017-03-19T10:46:01.827Z</updated>
    
    <content type="html"><![CDATA[<p>类似 C# 的 IEmulator</p>
<a id="more"></a>
<h2 id="定义">定义</h2><p>ES6 新增了 Generator ，类似于 C# 的 IEmulator 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 函数前面加 * 表示是 generator 函数</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span> <span class="comment">// yield 返回一个值</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// undefine</span></span><br></pre></td></tr></table></figure>
<p>Generator 可以是无限的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="pi">  "use strict"</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    <span class="keyword">let</span> sum = a + b</span><br><span class="line">    a = b</span><br><span class="line">    b = sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印前十个斐波那契数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = Fibonacci();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f.next().value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 1 2 3 5 8 13 21 54</span></span><br></pre></td></tr></table></figure>
<p>Generator 可以嵌套</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span>* AnotherGen()</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">AnotherGen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"a"</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"b"</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"c"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// "a"</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// "b"</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// "c"</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>Generator 可以模拟线程调度实现携程的效果，因为 Generator 可以让出控制权，达到暂停的效果。</p>
<h2 id="参考">参考</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">MDN</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类似 C# 的 IEmulator&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://en.ors-sro.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>迁移到 ES6+</title>
    <link href="http://en.ors-sro.com/Migrate-to-es6/"/>
    <id>http://en.ors-sro.com/Migrate-to-es6/</id>
    <published>2017-03-12T08:23:40.000Z</published>
    <updated>2017-03-12T08:39:23.988Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些迁移到 ES6 、ES7 的笔记，主要参考了 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a></p>
<p>新增了很多内容，这里只记录常用的。</p>
<a id="more"></a>
<h2 id="变量声明">变量声明</h2><p>ES6 新增了两个变量声明的关键词 <code>let</code> 和 <code>const</code></p>
<p><code>let</code> 用于代替 <code>var</code> 。</p>
<p><code>let</code> 不会像 <code>var</code> 那样声明为全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以也不需要 IIFE 了。因为 <code>let</code> 声明相当于块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>const</code> 用于声明只读的常量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p><a href="/Airbnb-es6-style-guide/#引用">详情</a></p>
<h2 id="解构">解构</h2><p>ES6 增加了变量解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>解构赋值很灵活</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>解构赋值可用于多值返回，参数解构等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;z: <span class="number">3</span>, y: <span class="number">2</span>, x: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2><p>字符串操作新增了很多方法，主要说几个常用的。</p>
<p><code>includes()</code> 判断是否包含特定字符串</p>
<p><code>startsWith()</code> 判断是否以特定字符串开头</p>
<p><code>endsWith()</code> 判断是否以特定字符串结尾</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p> ES6 还新增了模板字符串，用``` 包裹 。模板字符串中的空格和换行都会保留。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span><br><span class="line">string text line 2`</span>);</span><br></pre></td></tr></table></figure>
<p>还可以用作插值表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>
<h2 id="数值">数值</h2><p>ES6 新增二进制和八进制的表示法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b10000000000</span> === <span class="number">1024</span> <span class="comment">//true</span></span><br><span class="line"><span class="number">0o2000</span> === <span class="number">1024</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>还新增了一些处理数字的方法，常用的有</p>
<p><code>Number.isNan()</code> 判断是否为 <code>NaN</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span>/<span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Math.truct()</code> 截断小数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">0.1234</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'123.456'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'foo'</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p><code>Math.sign()</code> 判断正负</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(-<span class="number">5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(-<span class="number">0</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">'foo'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign();      <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>此外还新增了指数运算符 <code>**</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a ** 2 = a * a;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2><p>数组也新增了方法，常用的有</p>
<p><code>Array.from()</code> 用于将类数组转为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Array.of()</code> 将一组值转化为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>find()</code> 返回符合条件的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find((n) =&gt; n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<p><code>findIndex()</code> 返回符合条件的元素索引</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>所以以后使用 <code>indexOf</code> 时优先考虑使用 <code>includes()</code> 、<code>find()</code> 、<code>findIndex()</code> </p>
<h2 id="函数声明">函数声明</h2><p>ES6 新增了胖箭头函数用于声明 $\lambda$ 表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = v =&gt; v;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = () =&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用箭头函数还有一个好处就是不用手动绑定 <code>this</code> 。</p>
<p>ES6 新增了对参数默认值的支持</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = 'World') &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log('Hello') // Hello World</span><br><span class="line">log('Hello', 'China') // Hello China</span><br><span class="line">log('Hello', '') // Hello</span><br></pre></td></tr></table></figure>
<p>可以和解构赋值搭配使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = 5&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined, 5</span></span><br><span class="line">foo(&#123;x: <span class="number">1</span>&#125;) <span class="comment">// 1, 5</span></span><br><span class="line">foo(&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;) <span class="comment">// 1, 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure>
<p>还新增了不定参数的支持</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>新增扩展运算符，将数组化为元素序列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>
<p>可以用于合并数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>
<p>还可以搭配解构赋值使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">let</span> a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">let</span> [a, ...rest] = list</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];</span><br><span class="line">first  <span class="comment">// "foo"</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h2 id="对象">对象</h2><p>ES6 新增对象声明语法糖 <code>class</code></p>
<p>用传统的原型链声明一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>用 <code>class</code> 语法糖</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>extends</code> 来继承，使用 <code>super()</code> 调用父类函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增了一些简化表示法</p>
<p>属性简写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x: x, y: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>方法简写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/Airbnb-es6-style-guide/#对象">详情</a></p>
<h2 id="Promise">Promise</h2><p><a href="/Promise">ES6 Promise</a></p>
<h2 id="迭代">迭代</h2><p>新增了 <code>for ... of</code> 迭代，相当于其他语言的 <code>for each</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可搭配新增的 <code>entries()</code> 、<code>key()</code> 、<code>value()</code> 使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>
<h2 id="代码风格">代码风格</h2><p>两空格缩进，不添加分号。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些迁移到 ES6 、ES7 的笔记，主要参考了 &lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新增了很多内容，这里只记录常用的。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://en.ors-sro.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 代码片段</title>
    <link href="http://en.ors-sro.com/Haskell-codes/"/>
    <id>http://en.ors-sro.com/Haskell-codes/</id>
    <published>2017-03-05T08:22:01.000Z</published>
    <updated>2017-03-05T08:27:14.665Z</updated>
    
    <content type="html"><![CDATA[<p>一些零碎的代码,摘自 《 Haskell 趣学指南》，包含常用函数等。</p>
<a id="more"></a>
<h4 id="succ">succ</h4><p><code>succ</code> 返回后继</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; succ <span class="number">8</span>  </span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h4 id="max">max</h4><p><code>max</code> 返回最大值</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; max <span class="number">100</span> <span class="number">101</span>  </span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure>
<h4 id="min">min</h4><p><code>min</code> 返回最小值</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; min <span class="number">9</span> <span class="number">10</span>  </span><br><span class="line"><span class="number">9</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; min <span class="number">3.4</span> <span class="number">3.2</span>  </span><br><span class="line"><span class="number">3.2</span></span><br></pre></td></tr></table></figure>
<h4 id="!!">!!</h4><p><code>!!</code> 按索引获取元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">"Steve Buscemi"</span> !! <span class="number">6</span>  </span><br><span class="line">'<span class="type">B'</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">9.4</span>,<span class="number">33.2</span>,<span class="number">96.2</span>,<span class="number">11.2</span>,<span class="number">23.25</span>] !! <span class="number">1</span>  </span><br><span class="line"><span class="number">33.2</span></span><br></pre></td></tr></table></figure>
<h4 id="head">head</h4><p><code>head</code> 取列表的第一个元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; head [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="tail">tail</h4><p><code>tail</code> 取列表除了第一个元素的所有元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; tail [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="last">last</h4><p><code>last</code> 取列表的最后一个元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; last [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="init">init</h4><p><code>init</code> 取列表除了最后一个元素的所有元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; init [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h4 id="inits">inits</h4><p><code>inits</code> 重复取 <code>init</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; inits <span class="string">"w00t"</span>  </span><br><span class="line">[<span class="string">""</span>,<span class="string">"w"</span>,<span class="string">"w0"</span>,<span class="string">"w00"</span>,<span class="string">"w00t"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="tails">tails</h4><p><code>tails</code> 重复取 <code>tail</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; tails <span class="string">"w00t"</span>  </span><br><span class="line">[<span class="string">"w00t"</span>,<span class="string">"00t"</span>,<span class="string">"0t"</span>,<span class="string">"t"</span>,<span class="string">""</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> w = <span class="string">"w00t"</span> <span class="keyword">in</span> zip (inits w) (tails w)  </span><br><span class="line">[(<span class="string">""</span>,<span class="string">"w00t"</span>),(<span class="string">"w"</span>,<span class="string">"00t"</span>),(<span class="string">"w0"</span>,<span class="string">"0t"</span>),(<span class="string">"w00"</span>,<span class="string">"t"</span>),(<span class="string">"w00t"</span>,<span class="string">""</span>)]</span><br></pre></td></tr></table></figure>
<h4 id="length">length</h4><p><code>length</code> 获取列表的长度</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; length [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="null">null</h4><p><code>null</code> 判断列表是否为空</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; null [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; null []  </span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>
<h4 id="reverse">reverse</h4><p><code>reverse</code> 反转一个列表</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; reverse [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h4 id="take">take</h4><p><code>take</code> 拿取一定数量的元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">3</span> [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">1</span> [<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">3</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">5</span> [<span class="number">1</span>,<span class="number">2</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">0</span> [<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]  </span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h4 id="drop">drop</h4><p><code>drop</code> 抛弃一定数量的元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; drop <span class="number">3</span> [<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; drop <span class="number">0</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; drop <span class="number">100</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h4 id="maximum">maximum</h4><p><code>maximum</code> 返回列表最大值</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; maximum [<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h4 id="minimum">minimum</h4><p><code>minimum</code> 返回列表最小值</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; minimum [<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="sum">sum</h4><p><code>sum</code> 列表求和</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sum [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>]  </span><br><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure>
<h4 id="product">product</h4><p><code>product</code> 列表求积</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; product [<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]  </span><br><span class="line"><span class="number">24</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; product [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>]  </span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="elem">elem</h4><p><code>elem</code> 判断元素是否存在</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `elem` [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">10</span> `elem` [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure>
<h4 id="elemIndex">elemIndex</h4><p><code>elemIndex</code> 返回第一个指定元素索引</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t elemIndex  </span><br><span class="line"><span class="title">elemIndex</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Maybe</span> <span class="type">Int</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `elemIndex` [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">3</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">10</span> `elemIndex` [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<h4 id="elemIndices">elemIndices</h4><p><code>elemIndices</code> 返回所有指定元素索引</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; ' ' `elemIndices` <span class="string">"Where are the spaces?"</span>  </span><br><span class="line">[<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>]</span><br></pre></td></tr></table></figure>
<h4 id="find">find</h4><p><code>find</code> 查找符合条件的元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; find (&gt;<span class="number">4</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">5</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; find (&gt;<span class="number">9</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t find  </span><br><span class="line"><span class="title">find</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Maybe</span> a</span><br></pre></td></tr></table></figure>
<h4 id="findIndex">findIndex</h4><p><code>findIndex</code> 返回符合条件的元素索引</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; findIndex (==<span class="number">4</span>) [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">5</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; findIndex (==<span class="number">7</span>) [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; findIndices (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"Where Are The Caps?"</span>  </span><br><span class="line">[<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">14</span>]</span><br></pre></td></tr></table></figure>
<h4 id="cycle">cycle</h4><p><code>cycle</code> 循环拼接列表</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (cycle [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">12</span> (cycle <span class="string">"LOL "</span>)  </span><br><span class="line"><span class="string">"LOL LOL LOL "</span></span><br></pre></td></tr></table></figure>
<h4 id="repeat">repeat</h4><p><code>repeat</code> 重复指定元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (repeat <span class="number">5</span>)  </span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h4 id="zip">zip</h4><p><code>zip</code> 压缩函数，类似拉链</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]  </span><br><span class="line">[(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">5</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span> .. <span class="number">5</span>] [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>]  </span><br><span class="line">[(<span class="number">1</span>,<span class="string">"one"</span>),(<span class="number">2</span>,<span class="string">"two"</span>),(<span class="number">3</span>,<span class="string">"three"</span>),(<span class="number">4</span>,<span class="string">"four"</span>),(<span class="number">5</span>,<span class="string">"five"</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>] [<span class="string">"im"</span>,<span class="string">"a"</span>,<span class="string">"turtle"</span>]  </span><br><span class="line">[(<span class="number">5</span>,<span class="string">"im"</span>),(<span class="number">3</span>,<span class="string">"a"</span>),(<span class="number">2</span>,<span class="string">"turtle"</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1.</span>.] [<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"cherry"</span>, <span class="string">"mango"</span>]  </span><br><span class="line">[(<span class="number">1</span>,<span class="string">"apple"</span>),(<span class="number">2</span>,<span class="string">"orange"</span>),(<span class="number">3</span>,<span class="string">"cherry"</span>),(<span class="number">4</span>,<span class="string">"mango"</span>)]</span><br></pre></td></tr></table></figure>
<h4 id="zipWith">zipWith</h4><p><code>zipWith</code> 用指定的方式 <code>zip</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith max [<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith (++) [<span class="string">"foo "</span>, <span class="string">"bar "</span>, <span class="string">"baz "</span>] [<span class="string">"fighters"</span>, <span class="string">"hoppers"</span>, <span class="string">"aldrin"</span>]  </span><br><span class="line">[<span class="string">"foo fighters"</span>,<span class="string">"bar hoppers"</span>,<span class="string">"baz aldrin"</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith (*) (replicate <span class="number">5</span> <span class="number">2</span>) [<span class="number">1.</span>.]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith (zipWith (*)) [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]] [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]]  </span><br><span class="line">[[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">9</span>,<span class="number">20</span>,<span class="number">30</span>],[<span class="number">10</span>,<span class="number">12</span>,<span class="number">12</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="zip3">zip3</h4><p><code>zip3</code> 是 <code>zip</code> 的 3 个参数版本</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip3 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] [<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>] </span><br><span class="line">[(<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<h4 id="zipWith3">zipWith3</h4><p><code>zipWith3</code> 是 <code>zipWith</code> 的 3 个参数版本</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith3 (\x y z -&gt; x + y + z) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>] [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<h4 id="map">map</h4><p><code>map</code> 对列表每个元素应用函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]  </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; map (++ <span class="string">"!"</span>) [<span class="string">"BIFF"</span>, <span class="string">"BANG"</span>, <span class="string">"POW"</span>]  </span><br><span class="line">[<span class="string">"BIFF!"</span>,<span class="string">"BANG!"</span>,<span class="string">"POW!"</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; map (replicate <span class="number">3</span>) [<span class="number">3.</span>.<span class="number">6</span>]  </span><br><span class="line">[[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; map (map (^<span class="number">2</span>)) [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>],[<span class="number">49</span>,<span class="number">64</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; map fst [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h4 id="filter">filter</h4><p><code>filter</code> 过滤出列表中复合条件的元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; filter (&gt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; filter (==<span class="number">3</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">3</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; filter even [<span class="number">1.</span>.<span class="number">10</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> notNull x = not (null x) <span class="keyword">in</span> filter notNull [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>],[],[],[]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; filter (`elem` ['a'..'z']) <span class="string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span>  </span><br><span class="line"><span class="string">"uagameasadifeent"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; filter (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"i lauGh At You BecAuse u r aLL the Same"</span>  </span><br><span class="line"><span class="string">"GAYBALLS"</span></span><br></pre></td></tr></table></figure>
<h4 id="takeWhile">takeWhile</h4><p><code>takeWhile</code> 一直 <code>take</code> 直到条件不满足</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; takeWhile (/=' ') <span class="string">"elephants know how to party"</span></span><br><span class="line"><span class="string">"elephants"</span></span><br><span class="line"><span class="title">ghci</span>&gt; sum (takeWhile (&lt;<span class="number">10000</span>) (filter odd (map (^<span class="number">2</span>) [<span class="number">1.</span>.])))  </span><br><span class="line"><span class="number">166650</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; sum (takeWhile (&lt;<span class="number">10000</span>) [n^<span class="number">2</span> | n &lt;- [<span class="number">1.</span>.], odd (n^<span class="number">2</span>)])  </span><br><span class="line"><span class="number">166650</span></span><br></pre></td></tr></table></figure>
<h4 id="dropWhile">dropWhile</h4><p><code>dropWhile</code> 一直 <code>drop</code> 直到条件不满足</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; dropWhile (/=' ') <span class="string">"This is a sentence"</span>  </span><br><span class="line"><span class="string">" is a sentence"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; dropWhile (&lt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="intersperse">intersperse</h4><p><code>intersperse</code> 在列表元素之间插入指定元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; intersperse '.' <span class="string">"MONKEY"</span>  </span><br><span class="line"><span class="string">"M.O.N.K.E.Y"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; intersperse <span class="number">0</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<h4 id="intercalate">intercalate</h4><p><code>intercalate</code> 将一个列表插入到另一个列表元素之间</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; intercalate <span class="string">" "</span> [<span class="string">"hey"</span>,<span class="string">"there"</span>,<span class="string">"guys"</span>]  </span><br><span class="line"><span class="string">"hey there guys"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; intercalate [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h4 id="transpose">transpose</h4><p><code>transpose</code> 转置矩阵</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; transpose [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; transpose [<span class="string">"hey"</span>,<span class="string">"there"</span>,<span class="string">"guys"</span>]  </span><br><span class="line">[<span class="string">"htg"</span>,<span class="string">"ehu"</span>,<span class="string">"yey"</span>,<span class="string">"rs"</span>,<span class="string">"e"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="concat">concat</h4><p><code>concat</code> 拍扁列表</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; concat [<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"car"</span>]  </span><br><span class="line"><span class="string">"foobarcar"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; concat [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="concatMap">concatMap</h4><p><code>concatMap</code> 先 <code>map</code> 后 <code>concat</code> </p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; concatMap (replicate <span class="number">4</span>) [<span class="number">1.</span>.<span class="number">3</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h4 id="and">and</h4><p><code>and</code> 返回列表是否全是 <code>true</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; and $ map (&gt;<span class="number">4</span>) [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; and $ map (==<span class="number">4</span>) [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure>
<h4 id="or">or</h4><p><code>or</code> 返回列表是否存在 true</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; or $ map (==<span class="number">4</span>) [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; or $ map (&gt;<span class="number">4</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure>
<h4 id="any">any</h4><p><code>any</code> 返回列表是否存在元素满足条件</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; any (==<span class="number">4</span>) [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; any (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"HEYGUYSwhatsup"</span>  </span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>
<h4 id="all">all</h4><p><code>all</code> 返回列表是否全部元素满足条件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ghci&#62; all (&#62;4) [6,9,10]  &#10;True  &#10;ghci&#62; all (`elem` [&#39;A&#39;..&#39;Z&#39;]) &#34;HEYGUYSwhatsup&#34;  &#10;False</span><br></pre></td></tr></table></figure>
<h4 id="iterate">iterate</h4><p><code>iterate</code> 返回重复迭代的结果</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> $ iterate (*<span class="number">2</span>) <span class="number">1</span>  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">3</span> $ iterate (++ <span class="string">"haha"</span>) <span class="string">"haha"</span>  </span><br><span class="line">[<span class="string">"haha"</span>,<span class="string">"hahahaha"</span>,<span class="string">"hahahahahaha"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="splitAt">splitAt</h4><p><code>splitAt</code> 在指定位置分隔数组</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; splitAt <span class="number">3</span> <span class="string">"heyman"</span>  </span><br><span class="line">(<span class="string">"hey"</span>,<span class="string">"man"</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; splitAt <span class="number">100</span> <span class="string">"heyman"</span>  </span><br><span class="line">(<span class="string">"heyman"</span>,<span class="string">""</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; splitAt (-<span class="number">3</span>) <span class="string">"heyman"</span>  </span><br><span class="line">(<span class="string">""</span>,<span class="string">"heyman"</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> (a,b) = splitAt <span class="number">3</span> <span class="string">"foobar"</span> <span class="keyword">in</span> b ++ a  </span><br><span class="line"><span class="string">"barfoo"</span></span><br></pre></td></tr></table></figure>
<h4 id="span">span</h4><p><code>span</code> 将列表分割为满足条件的列表和不满足条件的列表</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; span (/=<span class="number">4</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure>
<h4 id="break">break</h4><p><code>break</code> 在满足条件时分割列表</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; break (==<span class="number">4</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure>
<h4 id="partition">partition</h4><p><code>partition</code> 类似 <code>span</code> 和 <code>break</code> 不过会对整个列表进行过滤。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; partition (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"BOBsidneyMORGANeddy"</span>  </span><br><span class="line">(<span class="string">"BOBMORGAN"</span>,<span class="string">"sidneyeddy"</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; partition (&gt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>]  </span><br><span class="line">([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>])  </span><br><span class="line"><span class="title">ghci</span>&gt; span (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"BOBsidneyMORGANeddy"</span>  </span><br><span class="line">(<span class="string">"BOB"</span>,<span class="string">"sidneyMORGANeddy"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="sort">sort</h4><p><code>sort</code> 列表排序</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sort [<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sort <span class="string">"This will be sorted soon"</span>  </span><br><span class="line"><span class="string">"    Tbdeehiillnooorssstw"</span></span><br></pre></td></tr></table></figure>
<h4 id="group">group</h4><p><code>group</code> 列表分组</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; group [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">5</span>],[<span class="number">6</span>],[<span class="number">7</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; map (\l@(x:xs) -&gt; (x,length l)) . group . sort $ [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">[(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">7</span>),(<span class="number">3</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">1</span>),(<span class="number">6</span>,<span class="number">1</span>),(<span class="number">7</span>,<span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<h4 id="isPrefixOf">isPrefixOf</h4><p><code>isPrefixOf</code> 判断是否为前缀</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">"hey"</span> `isPrefixOf` <span class="string">"hey there!"</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"hey"</span> `isPrefixOf` <span class="string">"oh hey there!"</span>  </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure>
<h4 id="isInfixOf">isInfixOf</h4><p><code>isInfixOf</code> 判断是否为中缀</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">"cat"</span> `isInfixOf` <span class="string">"im a cat burglar"</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"Cat"</span> `isInfixOf` <span class="string">"im a cat burglar"</span>  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"cats"</span> `isInfixOf` <span class="string">"im a cat burglar"</span>  </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure>
<h4 id="isSuffixOf">isSuffixOf</h4><p><code>isSuffixOf</code> 判断是否为后缀</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">"there!"</span> `isSuffixOf` <span class="string">"oh hey there!"</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"there!"</span> `isSuffixOf` <span class="string">"oh hey there"</span>  </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure>
<h4 id="lines">lines</h4><p><code>lines</code> 将字符串拆为多行</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; lines <span class="string">"first line\nsecond line\nthird line"</span>  </span><br><span class="line">[<span class="string">"first line"</span>,<span class="string">"second line"</span>,<span class="string">"third line"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="unlines">unlines</h4><p><code>unlines</code> 与 <code>lines</code> 相反</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; unlines [<span class="string">"first line"</span>, <span class="string">"second line"</span>, <span class="string">"third line"</span>]  </span><br><span class="line"><span class="string">"first line\nsecond line\nthird line\n"</span></span><br></pre></td></tr></table></figure>
<h4 id="words">words</h4><p><code>words</code> 将字符串拆成多个词组</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; words <span class="string">"hey these are the words in this sentence"</span>  </span><br><span class="line">[<span class="string">"hey"</span>,<span class="string">"these"</span>,<span class="string">"are"</span>,<span class="string">"the"</span>,<span class="string">"words"</span>,<span class="string">"in"</span>,<span class="string">"this"</span>,<span class="string">"sentence"</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; words <span class="string">"hey these           are    the words in this\nsentence"</span>  </span><br><span class="line">[<span class="string">"hey"</span>,<span class="string">"these"</span>,<span class="string">"are"</span>,<span class="string">"the"</span>,<span class="string">"words"</span>,<span class="string">"in"</span>,<span class="string">"this"</span>,<span class="string">"sentence"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="unwords">unwords</h4><p><code>unwords</code> 与 <code>words</code> 相反</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; unwords [<span class="string">"hey"</span>,<span class="string">"there"</span>,<span class="string">"mate"</span>]  </span><br><span class="line"><span class="string">"hey there mate"</span></span><br></pre></td></tr></table></figure>
<h4 id="nub">nub</h4><p><code>nub</code> 移除重复元素，获得最小核心</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; nub [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; nub <span class="string">"Lots of words and stuff"</span>  </span><br><span class="line"><span class="string">"Lots fwrdanu"</span></span><br></pre></td></tr></table></figure>
<h4 id="delete">delete</h4><p><code>delete</code> 移除第一个指定元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; delete 'h' <span class="string">"hey there ghang!"</span>  </span><br><span class="line"><span class="string">"ey there ghang!"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; delete 'h' . delete 'h' $ <span class="string">"hey there ghang!"</span>  </span><br><span class="line"><span class="string">"ey tere ghang!"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; delete 'h' . delete 'h' . delete 'h' $ <span class="string">"hey there ghang!"</span>  </span><br><span class="line"><span class="string">"ey tere gang!"</span></span><br></pre></td></tr></table></figure>
<h4 id="\\">\\</h4><p><code>\\</code> 去除共同部分</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1.</span>.<span class="number">10</span>] \\ [<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"Im a big baby"</span> \\ <span class="string">"big"</span>  </span><br><span class="line"><span class="string">"Im a  baby"</span></span><br></pre></td></tr></table></figure>
<h4 id="union">union</h4><p><code>union</code> 集合并</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">"hey man"</span> `union` <span class="string">"man what's up"</span>  </span><br><span class="line"><span class="string">"hey manwt'sup"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1.</span>.<span class="number">7</span>] `union` [<span class="number">5.</span>.<span class="number">10</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<h4 id="intersect">intersect</h4><p><code>intersect</code> 集合交</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1.</span>.<span class="number">7</span>] `intersect` [<span class="number">5.</span>.<span class="number">10</span>]  </span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h4 id="fst">fst</h4><p><code>fst</code> 获取二元组的第一个元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fst (<span class="number">8</span>,<span class="number">11</span>)  </span><br><span class="line"><span class="number">8</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; fst (<span class="string">"Wow"</span>, <span class="type">False</span>)  </span><br><span class="line"><span class="string">"Wow"</span></span><br></pre></td></tr></table></figure>
<h4 id="snd">snd</h4><p><code>snd</code> 获取二元组的第二个元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; snd (<span class="number">8</span>,<span class="number">11</span>)  </span><br><span class="line"><span class="number">11</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; snd (<span class="string">"Wow"</span>, <span class="type">False</span>)  </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure>
<h4 id="flip">flip</h4><p><code>flip</code> 返回函数的翻转版本</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; flip zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">"hello"</span>  </span><br><span class="line">[('h',<span class="number">1</span>),('e',<span class="number">2</span>),('l',<span class="number">3</span>),('l',<span class="number">4</span>),('o',<span class="number">5</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith (flip' div) [<span class="number">2</span>,<span class="number">2.</span>.] [<span class="number">10</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]  </span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="when">when</h4><p><code>when</code> 相当于没有 <code>else</code> 的 <code>if</code> </p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="import"><span class="keyword">import</span> Control.Monad   </span></span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    when (c /= ' ') $ <span class="keyword">do</span>  </span><br><span class="line">        putChar c  </span><br><span class="line">        main</span><br></pre></td></tr></table></figure>
<h4 id="sequence">sequence</h4><p><code>sequence</code> 执行一系列的输入输出操作</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    a &lt;- getLine  </span><br><span class="line">    b &lt;- getLine  </span><br><span class="line">    c &lt;- getLine  </span><br><span class="line">    print [a,b,c]  </span><br><span class="line"><span class="comment">-- 相当于</span></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    rs &lt;- sequence [getLine, getLine, getLine]  </span><br><span class="line">    print rs</span><br></pre></td></tr></table></figure>
<h4 id="mapM">mapM</h4><p><code>mapM</code> 先进行 <code>map</code> 再遍历返回的 Monad</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sequence (map print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line"><span class="number">4</span>  </span><br><span class="line"><span class="number">5</span>  </span><br><span class="line">[(),(),(),(),()]  </span><br><span class="line"><span class="comment">-- 相当于</span></span><br><span class="line"><span class="title">ghci</span>&gt; mapM print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line">[(),(),()]</span><br></pre></td></tr></table></figure>
<p>mapM_</p>
<p><code>mapM_</code> 类似 <code>mapM</code> 只是不关心返回的结果</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mapM_ print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些零碎的代码,摘自 《 Haskell 趣学指南》，包含常用函数等。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Haskell" scheme="http://en.ors-sro.com/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>逆变和协变</title>
    <link href="http://en.ors-sro.com/Covariant-and-Contravariant/"/>
    <id>http://en.ors-sro.com/Covariant-and-Contravariant/</id>
    <published>2017-02-25T09:00:51.000Z</published>
    <updated>2017-02-25T10:24:24.994Z</updated>
    
    <content type="html"><![CDATA[<p>$$<br>\dfrac{T_1 \leq S_1 \quad S_2 \leq T_2}{S_1 \rightarrow S_2 \leq T_1 \rightarrow T_2}<br>$$</p>
<a id="more"></a>
<h2 id="简单的代换">简单的代换</h2><p>假设有三个类，Animal ，Cat，Dog。其中 Cat 和 Dog 是 Animal 的子类。</p>
<p>有一段这样的转换代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat b = <span class="keyword">new</span> Animal();</span><br><span class="line">Dog c = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>
<p>有哪些可以通过编译呢？</p>
<p>显然对面向对象有基本了解到人都能很快答出只有第一行能编译通过。</p>
<p>第二行因为不是所有 Animal 都是 Cat 。所以在赋值的时候转换失败。</p>
<p>第三行因为 Dog 和 Cat 是不同的类，除非定义转换方式或者内存分布一致，否则通常是失败的。</p>
<p>第一行是可以编译通过是因为面向对象的继承特性。</p>
<p>继承允许子类拥有父类相同的行为，又可以有自己独特的行为。</p>
<p>所以子类替换父类，也就是熟悉的里氏代换原则。</p>
<h2 id="复合类型">复合类型</h2><p>除了基本的类型比如 int ，bool 等，还有一种复合类型比如 int[]，List&lt; int &gt; 等。</p>
<p>复合类型通常由类型构造器和类型参数组合而成，类似与函数和参数的关系。</p>
<p>比如 List&lt; int &gt; 的类型构造器是 List ，参数为 int</p>
<p>简单类型的替换非常直观，子类能够替换父类，父类不能替换子类。</p>
<p>复合类型的替换就不是那么直观了。</p>
<p>比如对于类型 Animal[] Animal数组和Cat[] Cat数组，这两个类型。</p>
<p>这个两个类型是什么关系？是否与 Animal 和 Cat 的关系有关？</p>
<p>答案是这两个类型没有任何关系。</p>
<p>仔细想想就能发现</p>
<p>Cat[] 并不能替换所有 Animal[] 。因为 Animal[] 可以装入 Dog 的实例，而 Cat[] 不可以。</p>
<p>Animal[] 也不能替换所有 Cat[] 。因为 Cat[] 中的 Cat 可以调用 Cat 类独有的方法，替换为 Animal 后，Animal 没有这个独有的方法，调用失败。</p>
<p>所以 Animal[] 和 Cat[] 是没有关系的。</p>
<p>是不是所有的 Animal 的复合类型和 Cat 的复合类型都没有关系呢？</p>
<p>其实不是的。</p>
<p>对于 Reader <code>(-&gt;)</code> 有</p>
<p>(Animal -&gt; Cat) 是 (Animal -&gt; Animal) 的子类型</p>
<p>(Animal -&gt; Animal) 是 (Cat -&gt; Animal) 的子类型</p>
<p>先说比较直观的第一个</p>
<p>要想说明 (Animal -&gt; Cat) 是 (Animal -&gt; Animal) 的子类型，需要子类能够替换父类。</p>
<p>显然父类 (Animal -&gt; Animal) 的返回值是 Animal ，如果替换成子类 (Animal -&gt; Cat)</p>
<p>输入类型 Animal 不变没问题，输出变成了Cat 。因为 Cat 能够替换 Animal 所以是没问题的。</p>
<p>所以 (Animal -&gt; Cat) 可以替换 (Animal -&gt; Animal) </p>
<p>所以 (Animal -&gt; Cat) 是 (Animal -&gt; Animal) 的子类型。</p>
<p>再看第二个</p>
<p>如果 (Animal -&gt; Animal) 替换 (Cat -&gt; Animal)。</p>
<p>输出都是 Animal 没问题。</p>
<p>输入变成了 Animal。看起来似乎是有问题的，因为 (Cat -&gt; Animal) 中有可能调用 Cat 的独有方法</p>
<p>其实是没问题的，因为替换成 (Animal -&gt; Animal) 后，(Animal -&gt; Animal) 没有 Cat 的独有方法，所以不会报错。</p>
<p>而且原本的输入 Cat 是可以转成现在的输入 Animal 的。</p>
<p>所以 (Animal -&gt; Animal) 可以替换 (Cat -&gt; Animal) 。</p>
<p>所以 (Animal -&gt; Animal) 是 (Cat -&gt; Animal) 的子类型。</p>
<p>(Animal -&gt; Cat) 替换 (Animal -&gt; Animal) 中用 Cat 替换 Animal 与原本的继承关系 Cat 替换 Animal 一致，所以称为协变。</p>
<p>(Animal -&gt; Animal) 替换 (Cat -&gt; Animal) 中用 Animal 替换 Cat 与原本的继承关系 Cat 替换 Animal 相反，所以称为逆变。</p>
<h2 id="继承">继承</h2><p>C++ 和 Java 允许通过继承父类重载函数实现返回值的协变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Frog : Animal &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Parent </span><br><span class="line">&#123;</span><br><span class="line">    Animal a;</span><br><span class="line">    <span class="function">Animal <span class="title">GetAnAnimal</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child : Parent</span><br><span class="line">&#123;</span><br><span class="line">    Frog f;</span><br><span class="line">    <span class="function">Frog <span class="title">GetAnAnimal</span><span class="params">()</span> <span class="comment">// 返回值协变</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参数化多态">参数化多态</h2><p>C# 支持在参数化多态中使用 <code>in</code> 和 <code>out</code> 标记逆变和协变</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">OutExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> i</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        i = <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">        Method(<span class="keyword">out</span> <span class="keyword">value</span>);</span><br><span class="line">        <span class="comment">// value is now 44</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不对，走错片场了。是这个</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GrandParent</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Parent</span> : <span class="title">GrandParent</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child</span> : <span class="title">Parent</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">delegate</span> TResult Demo&lt;<span class="keyword">in</span> T, <span class="keyword">out</span> TResult&gt;(T argument);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Child <span class="title">Sample</span>(<span class="params">GrandParent person</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Child();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// 参数逆变，返回值协变</span></span><br><span class="line">            Demo&lt;Parent, Parent&gt; d = Sample;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2><p><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" target="_blank" rel="external">逆变和协变的维基百科</a><br><a href="https://msdn.microsoft.com/zh-cn/library/t3c3bfhx.aspx" target="_blank" rel="external">C# Out</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$$&lt;br&gt;\dfrac{T_1 \leq S_1 \quad S_2 \leq T_2}{S_1 \rightarrow S_2 \leq T_1 \rightarrow T_2}&lt;br&gt;$$&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="逆变" scheme="http://en.ors-sro.com/tags/%E9%80%86%E5%8F%98/"/>
    
  </entry>
  
  <entry>
    <title>SICP 2.1 数据抽象导论</title>
    <link href="http://en.ors-sro.com/SICP-2-1-Introduction-to-Data-Bbstraction/"/>
    <id>http://en.ors-sro.com/SICP-2-1-Introduction-to-Data-Bbstraction/</id>
    <published>2017-02-19T07:35:10.000Z</published>
    <updated>2017-02-19T09:04:58.014Z</updated>
    
    <content type="html"><![CDATA[<p>翻车到坑里</p>
<a id="more"></a>
<h2 id="笔记">笔记</h2><p>这一小节主要将数据封装的抽象，类似接口的感觉。</p>
<h2 id="习题">习题</h2><h3 id="习题_2-1">习题 2.1</h3><blockquote>
<p><strong>Exercise 2.1.</strong>  Define a better version of make-rat that handles both positive and negative arguments. Make-ratshould normalize the sign so that if the rational number is positive, both  the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.</p>
</blockquote>
<p>想要得到最简的表达式需要两个步骤，一个是需要除以最大公约数，第二个是符号处理。</p>
<p>最大公约数很简单，直接用前面小节的程序即可。</p>
<p>接着处理符号，考虑到负负得正，而题目中已经说明如果整个分式是负数，则分子保留负号。</p>
<p>那只需要判断分母符号就可以了。因为分母不可以有负号。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">gcd</span></span> a b)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">=</span></span> b <span class="number">0</span>)</span></span><br><span class="line">      a</span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">gcd</span></span> b <span class="list">(<span class="keyword"><span class="built_in">remainder</span></span> a b)</span>)</span>)</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">remainder</span></span> a b)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">&lt;</span></span> a b)</span></span><br><span class="line">      a</span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">remainder</span></span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> a b)</span> b)</span>)</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">nagetive?</span> x)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">&lt;</span></span> x <span class="number">0</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">make-rat</span> n d)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">define</span></span> g <span class="list">(<span class="keyword"><span class="built_in">gcd</span></span> <span class="list">(<span class="keyword"><span class="built_in">abs</span></span> n)</span> <span class="list">(<span class="keyword"><span class="built_in">abs</span></span> d)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword">nagetive?</span> d)</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> n g)</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> d g)</span>)</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> n g)</span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> d g)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">make-rat</span> <span class="number">2</span> <span class="number">4</span>)</span></span><br><span class="line"><span class="comment">;=&gt; (1 . 2)</span></span><br><span class="line"><span class="list">(<span class="keyword">make-rat</span> <span class="number">2</span> <span class="number">-4</span>)</span></span><br><span class="line"><span class="comment">;=&gt; (-1 . 2)</span></span><br><span class="line"><span class="list">(<span class="keyword">make-rat</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="number">2</span>)</span> <span class="number">4</span>)</span></span><br><span class="line"><span class="comment">;=&gt; (-1 . 2)</span></span><br><span class="line"><span class="list">(<span class="keyword">make-rat</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="number">4</span>)</span>)</span></span><br><span class="line"><span class="comment">;=&gt; (1 . 2)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-2">习题 2.2</h3><blockquote>
<p><strong>Exercise 2.2.</strong>  Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor make-segment and selectors start-segment and end-segment that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the <em>x</em> coordinate and the <em>y</em> coordinate. Accordingly, specify a constructor make-point and selectors x-point and y-point that define this representation. Finally, using your selectors and constructors, define a procedure midpoint-segment that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you’ll need a way to print points:<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">print-point</span> p)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">newline</span></span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="string">"("</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="list">(<span class="keyword">x-point</span> p)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="string">","</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="list">(<span class="keyword">y-point</span> p)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="string">")"</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>点只需要记录 $x$，$y$。</p>
<p>线段只需要记录起点和终点。</p>
<p>直接用 <code>cons</code> 记录即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">make-point</span> x y)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> x y)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">x-point</span> p)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">car</span></span> p)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">y-point</span> p)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> p)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">print-point</span> p)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="string">"("</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="list">(<span class="keyword">x-point</span> p)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="string">","</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="list">(<span class="keyword">y-point</span> p)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">display</span></span> <span class="string">")"</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">newline</span></span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">make-segment</span> begin end)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> begin end)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">begin-segment</span> line)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">car</span></span> line)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">end-segment</span> line)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> line)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">mid-point</span> line)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">average</span> x y)</span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> <span class="list">(<span class="keyword"><span class="built_in">+</span></span> x y)</span> <span class="number">2</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">make-point</span> <span class="list">(<span class="keyword">average</span> <span class="list">(<span class="keyword">x-point</span> <span class="list">(<span class="keyword">begin-segment</span> line)</span>)</span> <span class="list">(<span class="keyword">x-point</span> <span class="list">(<span class="keyword">end-segment</span> line)</span>)</span>)</span></span><br><span class="line">              <span class="list">(<span class="keyword">average</span> <span class="list">(<span class="keyword">y-point</span> <span class="list">(<span class="keyword">begin-segment</span> line)</span>)</span> <span class="list">(<span class="keyword">y-point</span> <span class="list">(<span class="keyword">end-segment</span> line)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">print-point</span> <span class="list">(<span class="keyword">mid-point</span> <span class="list">(<span class="keyword">make-segment</span> <span class="list">(<span class="keyword">make-point</span> <span class="number">1</span> <span class="number">1</span>)</span> <span class="list">(<span class="keyword">make-point</span> <span class="number">2</span> <span class="number">2</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">;=&gt; (1.5 . 1.5)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-3">习题 2.3</h3><blockquote>
<p><strong>Exercise 2.3.</strong>  Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_thm_2.2" target="_blank" rel="external">2.2</a>.) In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?</p>
</blockquote>
<p>确定一个矩形，只需要对角线上的两点即可。</p>
<p>通过构建抽象屏障（接口）使得实现和抽象分离。这样即使换了矩形的实现方式也不会影响。</p>
<p>这里选择的抽象屏障是矩形的长和宽，也就是无论矩形底层怎么实现，只要实现了长和宽接口就行。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">make-rectangle</span> p1 p2)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> p1 p2)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">begin-point</span> rect)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">car</span></span> rect)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">end-point</span> rect)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> rect)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">x-length</span> rect)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">abs</span></span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="list">(<span class="keyword">y-point</span> <span class="list">(<span class="keyword">begin-point</span> rect)</span>)</span> <span class="list">(<span class="keyword">y-point</span> <span class="list">(<span class="keyword">end-point</span> rect)</span>)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">y-lenth</span> rect)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">abs</span></span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="list">(<span class="keyword">x-point</span> <span class="list">(<span class="keyword">begin-point</span> rect)</span>)</span> <span class="list">(<span class="keyword">x-point</span> <span class="list">(<span class="keyword">end-point</span> rect)</span>)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">perimeter</span> rect)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">2</span> <span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="list">(<span class="keyword">x-lenth</span> rect)</span> <span class="list">(<span class="keyword">y-length</span> rect)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">area</span> rect)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="list">(<span class="keyword">x-lenth</span> rect)</span> <span class="list">(<span class="keyword">y-length</span> rect)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">perimeter</span> <span class="list">(<span class="keyword">make-rectangle</span> <span class="list">(<span class="keyword">make-point</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">make-point</span> <span class="number">2</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; 6</span></span><br><span class="line"><span class="list">(<span class="keyword">area</span> <span class="list">(<span class="keyword">make-rectangle</span> <span class="list">(<span class="keyword">make-point</span> <span class="number">1</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">make-point</span> <span class="number">2</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; 2</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-4">习题 2.4</h3><blockquote>
<p><strong>Exercise 2.4.</strong>  Here is an alternative procedural representation of pairs. For this representation, verify that <code>(car (cons x y))</code> yields x for any objects x and y.</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> x y)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">m</span>)</span> <span class="list">(<span class="keyword">m</span> x y)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">car</span></span> z)</span></span><br><span class="line">  <span class="list">(<span class="keyword">z</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">p</span> q)</span> p)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>What is the corresponding definition of cdr? (Hint: To verify that this works, make use of the substitution model of section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.5" target="_blank" rel="external">1.1.5</a>.)</p>
</blockquote>
<p>按 Applicative-Order 展开即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">car</span></span> any-cons)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">any-cons</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">p</span> q)</span> p)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">m</span>)</span> <span class="list">(<span class="keyword">m</span> x y)</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">p</span> q)</span> p)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">p</span> q)</span> p)</span> x y)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span> y)</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; x</span></span><br></pre></td></tr></table></figure>
<p>观察 <code>(lambda (p q) p)</code> </p>
<p>把 <code>(p q)</code> 视为一个 <code>cons</code> 那么 <code>cdr cons</code> 就是 <code>cdr (p q)</code> </p>
<p>结果是 <code>q</code> ，写成 lambda 表达式</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> z)</span></span><br><span class="line">  <span class="list">(<span class="keyword">z</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">p</span> q)</span> q)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-5">习题 2.5</h3><blockquote>
<p><strong>Exercise 2.5.</strong>  Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair $a$ and $b$ as the integer that is the product $2^a$ $3^b$. Give the corresponding definitions of the procedures cons, car, and cdr.</p>
</blockquote>
<p>先写 <code>cons</code> ，根据 $a$ , $b$ 构造数字</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> a b)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="list">(<span class="keyword"><span class="built_in">expt</span></span> <span class="number">2</span> a)</span></span><br><span class="line">	   <span class="list">(<span class="keyword"><span class="built_in">expt</span></span> <span class="number">3</span> b)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>因为数字是由 $2^a \cdot 3^b$ 的形式构建的，所以一直除以 2 就能得到有多少个 2 相乘</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">cars</span> x)</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">odd?</span></span> x)</span></span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="list">(<span class="keyword">cars</span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> x <span class="number">2</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>类似的</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">cdrs</span> x)</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> <span class="list">(<span class="keyword"><span class="built_in">=</span></span> <span class="list">(<span class="keyword"><span class="built_in">remainder</span></span> x <span class="number">3</span>)</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="list">(<span class="keyword">cdrs</span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> x <span class="number">3</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-6">习题 2.6</h3><blockquote>
<p><strong>Exercise 2.6.</strong>  In case representing pairs as procedures wasn’t mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> zero <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> x)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">add-1</span> n)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="list">(<span class="keyword">n</span> f)</span> x)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>This representation is known as <em>Church numerals</em>, after its inventor, Alonzo Church, the logician who invented the $\lambda$ calculus.</p>
<p>Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate <code>(add-1 zero)</code>). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).</p>
</blockquote>
<p>直接代入展开</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">add-1</span> zero)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 为了方便这里先展开 add-1</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="list">(<span class="keyword">zero</span> f)</span> x)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 展开 zero 得</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> x)</span>)</span> f)</span> x)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 将 zero 中的 f 代入得</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> x)</span> x)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 将 x 带入得</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> x)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>所以定义 one 为</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> one <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> x)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>用类似的方法</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">add-1</span> one)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="list">(<span class="keyword">one</span> f)</span> x)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> x)</span>)</span>)</span> f)</span> x)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> x)</span>)</span> x)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="keyword">f</span> x)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>所以定义 two 为</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> two <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="keyword">f</span> x)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-7">习题 2.7</h3><blockquote>
<p><strong>Exercise 2.7.</strong>  Alyssa’s program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">make-interval</span> a b)</span> <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> a b)</span>)</span></span><br></pre></td></tr></table></figure>
<p>Define selectors upper-bound and lower-bound to complete the implementation.</p>
</blockquote>
<p>因为是 <code>cons</code> 结构。所以直接调用 <code>car</code> 和 <code>cdr</code> 即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">upper-bound</span> interval)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> interval)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">lower-bound</span> interval)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">car</span></span> interval)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-8">习题 2.8</h3><blockquote>
<p><strong>Exercise 2.8.</strong>  Using reasoning analogous to Alyssa’s, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called sub-interval.</p>
</blockquote>
<p>区间减法最小值为下界减上界</p>
<p>最大值为上界减下界</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">sub-interval</span> x y)</span></span><br><span class="line">  <span class="list">(<span class="keyword">make-interval</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="list">(<span class="keyword">lower-bound</span> x)</span> <span class="list">(<span class="keyword">upper-bound</span> y)</span>)</span></span><br><span class="line">                 <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="list">(<span class="keyword">upper-bound</span> x)</span> <span class="list">(<span class="keyword">lower-bound</span> y)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>还可以用 <code>(add-interval)</code> 实现。</p>
<h3 id="习题_2-9">习题 2.9</h3><blockquote>
<p><strong>Exercise 2.9.</strong>  The <em>width</em> of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.</p>
</blockquote>
<p>区间 $[2,4]$ 宽度为 $(4-2) \div 2 = 1$</p>
<p>区间 $[4,8]$ 宽度为 $(8-4) \div 2 = 2$</p>
<p>两个区间的乘积为 $[8,32]$ ，宽度为 $(32-8) \div = 12$</p>
<p>区间 $[4,6]$ 宽度为 $(6-4) \div 2 = 1$</p>
<p>区间 $[6,10]$ 宽度为 $(10-6) \div 2 = 2$</p>
<p>两个区间的乘积为 $[24,60]$ ，宽度为 $(60-24) \div 2 = 18$</p>
<p>可见同样的区间长度，一个是 $12$ ，另一个是 $18$ ，不仅仅由原本的区间宽度决定。   </p>
<h3 id="习题_2-10">习题 2.10</h3><blockquote>
<p><strong>Exercise 2.10.</strong>  Ben Bitdiddle, an expert systems programmer, looks over Alyssa’s shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa’s code to check for this condition and to signal an error if it occurs.</p>
</blockquote>
<p>区间包含零那么区间异号</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">div-interval</span> x y)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">or</span></span> <span class="list">(<span class="keyword"><span class="built_in">and</span></span> <span class="list">(<span class="keyword"><span class="built_in">&lt;</span></span> <span class="list">(<span class="keyword">lower-bound</span> x)</span> <span class="number">0</span>)</span></span><br><span class="line">               <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword">upper-bound</span> x)</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">          <span class="list">(<span class="keyword"><span class="built_in">and</span></span> <span class="list">(<span class="keyword"><span class="built_in">&lt;</span></span> <span class="list">(<span class="keyword">lower-bound</span> y)</span> <span class="number">0</span>)</span></span><br><span class="line">               <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword">upper-bound</span> y)</span> <span class="number">0</span>)</span>)</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">error</span> <span class="string">"interval span zero"</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">mul-interval</span> x </span><br><span class="line">                <span class="list">(<span class="keyword">make-interval</span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> <span class="number">1.0</span> <span class="list">(<span class="keyword">upper-bound</span> y)</span>)</span></span><br><span class="line">                               <span class="list">(<span class="keyword"><span class="built_in">/</span></span> <span class="number">1.0</span> <span class="list">(<span class="keyword">lower-bound</span> y)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-11">习题 2.11</h3><blockquote>
<p><strong>Exercise 2.11.</strong>  In passing, Ben also cryptically comments: ``By testing the signs of the endpoints of the intervals, it is possible to break mul-interval into nine cases, only one of which requires more than two multiplications.’’ Rewrite this procedure using Ben’s suggestion.</p>
</blockquote>
<p>假设有四个正数 $a$ , $b$ , $c$ , $d$ 组成两个区间 $x(a,b)$ ，$y(c,d)$ 。</p>
<p>理论上有 $ 2 \times 2 \times 2 \times 2 = 16$ 种排列组合。</p>
<p>但是 $(a,-b)$ 和 $(c,-d)$ 的情况不符合区间上界大于下界的要求。</p>
<p>排除这两种组合后有 $3 \times 3 = 9$ 种组合。</p>
<p>按符号分类讨论</p>
<table>
<thead>
<tr>
<th>组合</th>
<th>Max</th>
<th>Min</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(a,b)$ $(c,d)$</td>
<td>$b \cdot d$</td>
<td>$a \cdot c$</td>
</tr>
<tr>
<td>$(-a,b)$ $(c,d)$</td>
<td>$b \cdot d$</td>
<td>$-a \cdot d$</td>
</tr>
<tr>
<td>$(-a,-b)$ $(c,d)$</td>
<td>$-b \cdot c$</td>
<td>$-a \cdot d$</td>
</tr>
<tr>
<td>$(a,b)$ $(-c,d)$</td>
<td>$b \cdot d$</td>
<td>$b \cdot -c$</td>
</tr>
<tr>
<td>$(-a,b)$ $(-c,d)$</td>
<td>$-a \cdot -c$ 或 $b \cdot d$</td>
<td>$-a \cdot -c$ 或 $ b \cdot  d$</td>
</tr>
<tr>
<td>$(-a,-b)$ $(-c,-d)$</td>
<td>$-a \cdot -c$</td>
<td>$-b \cdot -d$</td>
</tr>
<tr>
<td>$(a,b)$ $(-c,-d)$</td>
<td>$a \cdot -d$</td>
<td>$b \cdot -c$</td>
</tr>
<tr>
<td>$(-a,b)$ $(-c,-d)$</td>
<td>$-a \cdot -c$</td>
<td>$b \cdot -c$</td>
</tr>
<tr>
<td>$(-a,-b)$ $(-c,-d)$</td>
<td>$-a \cdot -c$</td>
<td>$-b \cdot -d$</td>
</tr>
</tbody>
</table>
<h3 id="习题_2-12">习题 2.12</h3><blockquote>
<p><strong>Exercise 2.12.</strong>  Define a constructor make-center-percent that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector percent that produces the percentage tolerance for a given interval. The center selector is the same as the one shown above.</p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">make-center-percent</span> c p)</span></span><br><span class="line">  <span class="list">(<span class="keyword">make-interval</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> c <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="number">1</span> p)</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> c <span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> p)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">percent</span> x)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="list">(<span class="keyword"><span class="built_in">/</span></span> <span class="list">(<span class="keyword">upper-bound</span> x)</span> <span class="list">(<span class="keyword">center</span> x)</span>)</span> <span class="number">1</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题_2-13">习题 2.13</h3><blockquote>
<p><strong>Exercise 2.13.</strong>  Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.</p>
</blockquote>
<p>题目要求找出一个估计区间乘法误差的公式。</p>
<p>按题目中的假设有两个区间 $x(c_x,p_x)$ , $y(c_y,p_y)$ ，所有数都是正数。</p>
<p>那么乘法的最大值是 $(c_x + c_x p_x)(c_y + c_y p_y)$</p>
<p>展开为 $c_x c_y + c_x c_y p_y + c_x c_y p_x + c_x c_y p_x p_y$ </p>
<p>提取公因式 $c_x c_y(1 + p_y + p_x + p_x p_y)$ </p>
<p>乘法的最小值是 $(c_x - c_x p_x)(c_y - c_y p_y)$ </p>
<p>展开为 $c_x c_y (1 - p_y - p_x + p_x p_y)$ </p>
<p>跟最大值的式子很像。将两个式子改写为</p>
<p>最大值 $c_x c_y (1 + p_x p_y) + c_x c_y (p_x + p_y)$</p>
<p>最小值 $c_x c_y (1 + p_x p_y)  - c_x c_y (p_x + p_y)$</p>
<p>显然中点为 $c_x c_y (1 + p_x p_y)$ ，宽度为 $c_x c_y (p_x + p_y)$</p>
<p>所以乘法区间的误差为<br>$$<br>\begin{align}<br>\frac {c_x c_y (p_x + p_y)}{c_x c_y(1 + p_x p_y)} = \frac{p_x + p_y}{1 + p_x p_y} \approx p_x + p_y<br>\end{align}<br>$$</p>
<h3 id="习题_2-14">习题 2.14</h3><blockquote>
<p><strong>Exercise 2.14.</strong>  Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals <em>A</em> and <em>B</em>, and use them in computing the expressions <em>A</em>/<em>A</em> and <em>A</em>/<em>B</em>. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_thm_2.12" target="_blank" rel="external">2.12</a>).</p>
</blockquote>
<p>显然这种说法是对的</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">par1</span> <span class="list">(<span class="keyword">make-center-percent</span> <span class="number">5</span> <span class="number">0.01</span>)</span> <span class="list">(<span class="keyword">make-center-percent</span> <span class="number">10</span> <span class="number">0.01</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (3.2346534653465353 . 3.4346801346801343)</span></span><br><span class="line"><span class="list">(<span class="keyword">par2</span> <span class="list">(<span class="keyword">make-center-percent</span> <span class="number">5</span> <span class="number">0.01</span>)</span> <span class="list">(<span class="keyword">make-center-percent</span> <span class="number">10</span> <span class="number">0.01</span>)</span>)</span></span><br><span class="line"><span class="comment">; =&gt; (3.3 . 3.3666666666666663)</span></span><br></pre></td></tr></table></figure>
<p>最直接的原因是区间除法 $A / A \ne 1$ 。</p>
<p>所以 $\frac{1}{R_1}$ 通分的时候 $\frac{1}{R_1} \cdot \frac{R_2}{R_2} \ne \frac{R_2}{R_1R_2} $ 。</p>
<p>因此最后的结果会有偏差。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻车到坑里&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://en.ors-sro.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SICP" scheme="http://en.ors-sro.com/tags/SICP/"/>
    
  </entry>
  
  <entry>
    <title>Polyglot</title>
    <link href="http://en.ors-sro.com/Polyglot/"/>
    <id>http://en.ors-sro.com/Polyglot/</id>
    <published>2017-02-12T07:14:54.000Z</published>
    <updated>2017-02-12T08:40:19.350Z</updated>
    
    <content type="html"><![CDATA[<p>混源</p>
<a id="more"></a>
<h2 id="初见端倪">初见端倪</h2><p>同一个符号在不同的编程语言中意义不同。比如 <code>;</code> 在 C 语言家族中是语句的结束符，在 Lisp 语言家族中是注释符号。</p>
<p>这也就是一个语言的代码通常不能通过另一个语言编译的原因。</p>
<p>利用这一点，实现多语言混写。即一段能通过多语言编译的代码。</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define x u /*      v &#10;# :::::::::::::::::::&#62;&#62;&#62;&#62;&#62;&#62;&#62;$$$a&#34;muroftih&#34;#[&#62;:#,_@] &#10;eval &#39;echo &#34;hitforum&#34;;exit&#39;;sub echo &#123; print &#34;@_\n&#34;&#125;       &#10;__END__&#62;++++++++++&#62;++++++++++[&#62;+++++++++++&#62;++++++++++  &#10;+&#60;&#60;-]&#62;------.+.&#62;++++++.&#60;---.+++++++++.&#62;--.+++             &#10;.&#60;--.&#60;&#60;. */ &#10;main() &#123; printf (&#34;hitforum\n&#34;); &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可以在 C 、Shell 、Perl 、<a href="/BrainFuck">BrainFuck</a> 、Befunge 、<a href="/WhiteSpace">Whitespace</a>  6 个语言环境下运行。</p>
<p>在 C 语言相当于</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># define x u /*      v </span><br><span class="line"># :::::::::::::::::::&gt;&gt;&gt;&gt;&gt;&gt;&gt;$$$a"muroftih"#[&gt;:#,_@] </span><br><span class="line">eval 'echo "hitforum";exit';sub echo &#123; print "@_\n"&#125;       </span><br><span class="line">__END__&gt;++++++++++&gt;++++++++++[&gt;+++++++++++&gt;++++++++++  </span><br><span class="line">+&lt;&lt;-]&gt;------.+.&gt;++++++.&lt;---.+++++++++.&gt;--.+++             </span><br><span class="line">.&lt;--.&lt;&lt;. */ </span><br><span class="line">main() &#123; printf ("hitforum\n"); &#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>/**/</code> 是 C 语言的注释符号。</p>
<p>所以在 C 下代码相当于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># <span class="keyword">define</span> x u</span></span><br><span class="line">main() &#123; <span class="built_in">printf</span> (<span class="string">"hitforum\n"</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>在 Shell 下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define x u /*      v </span></span><br><span class="line"><span class="comment"># :::::::::::::::::::&gt;&gt;&gt;&gt;&gt;&gt;&gt;$$$a"muroftih"#[&gt;:#,_@] </span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">'echo "hitforum";exit'</span>;sub <span class="built_in">echo</span> &#123; <span class="built_in">print</span> <span class="string">"@_\n"</span>&#125;       </span><br><span class="line">__END__&gt;++++++++++&gt;++++++++++[&gt;+++++++++++&gt;++++++++++  </span><br><span class="line">+&lt;&lt;-]&gt;------.+.&gt;++++++.&lt;---.+++++++++.&gt;--.+++             </span><br><span class="line">.&lt;--.&lt;&lt;. */ </span><br><span class="line"><span class="function"><span class="title">main</span></span>() &#123; <span class="built_in">printf</span> (<span class="string">"hitforum\n"</span>); &#125;</span><br></pre></td></tr></table></figure>
<p><code>#</code> 是 Shell 的注释符号，所以后面的内容视为注释忽略了。</p>
<p><code>exit</code> 退出 Shell 。所以后面的内容没有意义了。</p>
<p>所以在 Shell 下代码相当于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">'echo "hitforum";exit'</span></span><br></pre></td></tr></table></figure>
<p>在 BrainFuck 下</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">define</span> <span class="comment">x</span> <span class="comment">u</span> <span class="comment">/*</span>      <span class="comment">v</span> </span><br><span class="line"><span class="comment">#</span> <span class="comment">:::::::::::::::::::</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="comment">$$$a"muroftih"#</span><span class="title">[</span>&gt;<span class="comment">:#</span><span class="string">,</span><span class="comment">_@</span><span class="title">]</span> </span><br><span class="line"><span class="comment">eval</span> <span class="comment">'echo</span> <span class="comment">"hitforum";exit';sub</span> <span class="comment">echo</span> <span class="comment">&#123;</span> <span class="comment">print</span> <span class="comment">"@_\n"&#125;</span>       </span><br><span class="line"><span class="comment">__END__</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>  </span><br><span class="line"><span class="literal">+</span>&lt;&lt;<span class="literal">-</span><span class="title">]</span>&gt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>             </span><br><span class="line"><span class="string">.</span>&lt;<span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&lt;&lt;<span class="string">.</span> <span class="comment">*/</span> </span><br><span class="line"><span class="comment">main()</span> <span class="comment">&#123;</span> <span class="comment">printf</span> <span class="comment">("hitforum\n");</span> <span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>因为 <a href="/Brainfuck">BrainFuck 的原语只有 8 个符号</a> 所以其他符号都会被忽略。</p>
<p>所以在 BrainFuck 下代码相当于</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="title">[</span>&gt;<span class="string">,</span><span class="title">]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span></span><br><span class="line"><span class="literal">+</span>&lt;&lt;<span class="literal">-</span><span class="title">]</span>&gt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span></span><br><span class="line"><span class="string">.</span>&lt;<span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&lt;&lt;<span class="string">.</span></span><br></pre></td></tr></table></figure>
<p>在 Whitespace 下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define x u /*      v &#10;# :::::::::::::::::::&#62;&#62;&#62;&#62;&#62;&#62;&#62;$$$a&#34;muroftih&#34;#[&#62;:#,_@] &#10;eval &#39;echo &#34;hitforum&#34;;exit&#39;;sub echo &#123; print &#34;@_\n&#34;&#125;       &#10;__END__&#62;++++++++++&#62;++++++++++[&#62;+++++++++++&#62;++++++++++  &#10;+&#60;&#60;-]&#62;------.+.&#62;++++++.&#60;---.+++++++++.&#62;--.+++             &#10;.&#60;--.&#60;&#60;. */ &#10;main() &#123; printf (&#34;hitforum\n&#34;); &#125;</span><br></pre></td></tr></table></figure>
<p>因为 <a href="/Whitespace">Whitespace 的原语只有空格，制表符，换行</a> ，所以其他字符都会被忽略。</p>
<p>所以在 Whitespace 下相当于</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Space][Space][Space][Space][Tab][Space][Space][LF]&#10;[Space][Space][LF]&#10;[Space][Space][Space][Space][Space][Space][Tab][Space][Space][LF]&#10;[Space][Space][LF]&#10;[Tab][Tab][Space][Space][Space][LF]&#10;[Space][Space][LF]&#10;[Space][Space][Space][Space][Tab][Space][Space][Space][Space][LF]&#10;[Space][Space][LF]&#10;[Tab][Tab][Space][Space][Space][LF]&#10;[Space][Space][LF]&#10;[Tab][Tab][Space][Space][Space][LF]&#10;[Space][Space][LF]&#10;[Tab][Tab][Space][Space][Space][LF]&#10;[Space][Space][LF]&#10;[Tab][Tab][Space][Space][Space][LF]&#10;[Space][Space][LF]&#10;[Tab][Tab][LF]&#10;[Space][Space][LF]&#10;[Space][Space][Space][LF]&#10;[LF]&#10;[LF]</span><br></pre></td></tr></table></figure>
<h2 id="百花齐放">百花齐放</h2><p>除了 C 语言的混源，还有更多语言的混合。</p>
<p>比如 40 中语言的混合</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    #  1"16" 3//v\(@#/;"14"\Dv</span><br><span class="line">#/*`3 auaaZ&lt;&gt;16/"&lt;"6/b.q@")(22)S#  ␉␉␉␉ </span><br><span class="line">#yy␉;36!@</span><br><span class="line">### ␉</span><br><span class="line">#=␉&gt;</span><br><span class="line">#[#yy#yy0l0mx01k1k0l0ix0jx0h0h1d111P0eU0bx0b0o1d0b0e0e00x1d0i0fx0g0n0n11x0o0n0cx0c0o0f0c0gx0g0f0h0j0j0i0001k10mx0m0l11111100(^_)</span><br><span class="line">#`&lt;`␉|</span><br><span class="line">print((eval("1\x2f2")and( 9 )or(13 ))-(0and 4)^1&lt;&lt;(65)&gt;&gt;(62))or'(\&#123;(\&#123;&#125;)(\&#123;&#125;[()])&#125;\&#123;&#125;\&#123;&#125;\&#123;&#125;)'#46(8+9+9+9+9+=!)#1111|=/=1/24=x=9[&lt;$+@+-@@@@=&gt;+&lt;@@@=&gt;+&lt;?#&gt;+.--.]/</span><br><span class="line">__DATA__=1#//</span><br><span class="line">#.\."12"*␉</span><br><span class="line">###; console.log  39</span><br><span class="line">""""#//</span><br><span class="line">=begin␉//</span><br><span class="line">#*/</span><br><span class="line">#define␉z  sizeof 'c'-1?"38":"37"</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()  /*/</span><br><span class="line">#()`#`\'*/&#123;puts(z);;&#125;/*'``</span><br><span class="line">$'main'␉//</span><br><span class="line">#-3o4o#$$$</span><br><span class="line">&lt;&gt;3N.&lt;&gt;␉//</span><br><span class="line">#xx\"R++++++++++++++++++\"++++++++++++++++++.----.</span><br><span class="line">#x%~~~+␉+~*ttt*.x</span><br><span class="line">#xx++U++++++++++++++++v&lt;L&gt;4n;</span><br><span class="line">=end   #//</span><br><span class="line">"""#"#//</span><br><span class="line">#0]#echo 21#/(\[FAC,1&lt;-#2FAC,1SUB#1&lt;-#52FAC,1SUB#2&lt;-#32FACLEGEREEX,1PLEASEGIVEUPPLEASE)  ap</span><br><span class="line">#_|#o51~nJ\   </span><br><span class="line">#0␛dggi2␛`␉|1|6$//''25  &gt;&gt;&gt;#&gt;27.say# =#print(17)###^_^_7LEintndus(&#123;&#125;)!&lt;&gt;+]/*///Z/&#125;23!@222999"26</span><br></pre></td></tr></table></figure>
<p>详情参见 <a href="http://codegolf.stackexchange.com/questions/102370/add-a-language-to-a-polyglot" target="_blank" rel="external">Polyglot 在 Stackoverflow 上的讨论</a> 。</p>
<h2 id="参考链接">参考链接</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Polyglot_(computing)" target="_blank" rel="external">polyglot</a></li>
<li><a href="http://www.retas.de/thomas/computer/programs/useless/misc/polyglot/index.html" target="_blank" rel="external">A polyglot in 6 different languages</a> </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;混源&lt;/p&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="polyglot" scheme="http://en.ors-sro.com/tags/polyglot/"/>
    
  </entry>
  
  <entry>
    <title>Whitespace</title>
    <link href="http://en.ors-sro.com/Whitespace/"/>
    <id>http://en.ors-sro.com/Whitespace/</id>
    <published>2017-02-05T08:47:48.000Z</published>
    <updated>2017-02-05T09:41:21.241Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一个很干净的语言。</p>
<pre style="background: initial;">




















</pre>

<a id="more"></a>
<h2 id="Hello_World">Hello World</h2><p>先看它的 Hello World 。</p>
<pre>






























</pre>

<p>没看错。这个 <strong>Whitespace</strong> 语言的原语只有空格，制表符，还有换行。</p>
<h2 id="语法">语法</h2><p>参考<a href="http://compsoc.dur.ac.uk/whitespace/tutorial.html" target="_blank" rel="external"> Whitespace 语言官方教程</a> 整理的 BNF 如下。</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">Program ::= &lt;Statement&gt;&#123;Statement&#125;</span><br><span class="line"></span><br><span class="line">Statement ::= &lt;IMP&gt;</span><br><span class="line"></span><br><span class="line">IMP :: = <span class="attribute">&lt;StackManipulation&gt;</span><span class="attribute">&lt;SMCommand&gt;</span> | <span class="attribute">&lt;Arithmetic&gt;</span><span class="attribute">&lt;AriCommand&gt;</span> | <span class="attribute">&lt;HeapAccess&gt;</span><span class="attribute">&lt;HACommand&gt;</span> | <span class="attribute">&lt;FlowControl&gt;</span><span class="attribute">&lt;FCCommand&gt;</span> | <span class="attribute">&lt;I/O&gt;</span><span class="attribute">&lt;IOCommand&gt;</span></span><br><span class="line"></span><br><span class="line">StackManipulation ::= &lt;Space&gt;</span><br><span class="line"></span><br><span class="line">SMCommand ::= &lt;Push&gt;&lt;Number&gt; | &lt;Duplicate&gt; | &lt;Swap&gt; | &lt;Discard&gt;</span><br><span class="line"></span><br><span class="line">Push ::= &lt;Space&gt;</span><br><span class="line"></span><br><span class="line">Number ::= &lt;Sign&gt;&lt;Digit&gt;&lt;End&gt;</span><br><span class="line"></span><br><span class="line">Sign ::= &lt;Space&gt; | &lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">Digit ::= &lt;Space&gt;&#123;Digit&#125;|&lt;Tab&gt;&#123;Digit&#125;</span><br><span class="line"></span><br><span class="line">End ::= &lt;LF&gt;</span><br><span class="line"></span><br><span class="line">Duplicate ::= &lt;LF&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">Swap ::= &lt;LF&gt;&lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">Discard ::= &lt;LF&gt;&lt;LF&gt;</span><br><span class="line"></span><br><span class="line">Duplicate ::= &lt;LF&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">Arithmetic ::= &lt;Tab&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">AriCommand ::= &lt;Addition&gt; | &lt;Subtraction&gt; | &lt;Multiplication&gt; | &lt;IntegerDivision&gt; | &lt;Modulo&gt;</span><br><span class="line"></span><br><span class="line">Addition ::= &lt;Space&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">Subtraction ::= &lt;Space&gt;&lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">Multiplication ::= &lt;Space&gt;&lt;LF&gt;</span><br><span class="line"></span><br><span class="line">IntegerDivision ::= &lt;Tab&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">Modulo ::= &lt;Tab&gt;&lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">HeapAccess ::= &lt;Tab&gt;&lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">HACommand ::= &lt;Store&gt;&lt;Retrieve&gt;</span><br><span class="line"></span><br><span class="line">Store ::= &lt;Space&gt;</span><br><span class="line"></span><br><span class="line">Retrieve ::= &lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">FlowControl ::= &lt;LF&gt;</span><br><span class="line"></span><br><span class="line">FCCommand ::= &lt;Mark&gt;&lt;Label&gt; | &lt;Call&gt;&lt;Label&gt; | &lt;Jmp&gt;&lt;Label&gt; | &lt;Jz&gt;&lt;Label&gt; | &lt;Js&gt;&lt;Label&gt; | &lt;SubroutineEnd&gt; | &lt;ProgramEnd&gt;</span><br><span class="line"></span><br><span class="line">Mark ::= &lt;Space&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">Label ::= &lt;LabelName&gt;&lt;End&gt;</span><br><span class="line"></span><br><span class="line">LabelName ::= &lt;Space&gt;&#123;LabelName&#125;|&lt;Tab&gt;&#123;LabelName&#125;</span><br><span class="line"></span><br><span class="line">Call ::= &lt;Space&gt;&lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">Jmp ::= &lt;Space&gt;&lt;LF&gt;</span><br><span class="line"></span><br><span class="line">Jz ::= &lt;Tab&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">Js ::= &lt;Tab&gt;&lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">SubroutineEnd ::= &lt;Tab&gt;&lt;LF&gt;</span><br><span class="line"></span><br><span class="line">ProgrameEnd ::= &lt;LF&gt;&lt;LF&gt;</span><br><span class="line"></span><br><span class="line">I/O ::= &lt;Tab&gt;&lt;LF&gt;</span><br><span class="line"></span><br><span class="line">IOCommand ::= &lt;OutputChar&gt; | &lt;OutputNumber&gt; | &lt;ReadChar&gt; | &lt;ReadNumber&gt;</span><br><span class="line"></span><br><span class="line">OutputChar ::= &lt;Space&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">OutputNumber ::= &lt;Space&gt;&lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">ReadChar ::= &lt;Tab&gt;&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">ReadNumber ::= &lt;Tab&gt;&lt;Tab&gt;</span><br><span class="line"></span><br><span class="line">Space ::= <span class="string">" "</span></span><br><span class="line"></span><br><span class="line">Tab ::= <span class="string">"\t"</span></span><br><span class="line"></span><br><span class="line">LF ::= <span class="string">"\n"</span></span><br></pre></td></tr></table></figure>
<p>不熟悉 BNF 可以直接看下面的图表。</p>
<table>
<thead>
<tr>
<th>IMP</th>
<th>Command</th>
<th>Meaning</th>
<th>IMP  Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Space]</td>
<td>[Space][Number]</td>
<td>Push the number onto the stack</td>
<td>Stack Manipulation</td>
</tr>
<tr>
<td>[Space]</td>
<td>[LF][Space]</td>
<td>Duplicate the top item on the stack</td>
<td>Stack Manipulation</td>
</tr>
<tr>
<td>[Space]</td>
<td>[LF][Tab]</td>
<td>Swap the top two items on the stack</td>
<td>Stack Manipulation</td>
</tr>
<tr>
<td>[Space]</td>
<td>[LF][LF]</td>
<td>Discard the top item on the stack</td>
<td>Stack Manipulation</td>
</tr>
<tr>
<td>[Tab][Space]</td>
<td>[Space][Space]</td>
<td>Addition</td>
<td>Arithmetic</td>
</tr>
<tr>
<td>[Tab][Space]</td>
<td>[Space][Tab]</td>
<td>Subtraction</td>
<td>Arithmetic</td>
</tr>
<tr>
<td>[Tab][Space]</td>
<td>[Space][LF]</td>
<td>Multiplication</td>
<td>Arithmetic</td>
</tr>
<tr>
<td>[Tab][Space]</td>
<td>[Tab][Space]</td>
<td>Integer Division</td>
<td>Arithmetic</td>
</tr>
<tr>
<td>[Tab][Space]</td>
<td>[Tab][Tab]</td>
<td>Modulo</td>
<td>Arithmetic</td>
</tr>
<tr>
<td>[Tab][Tab]</td>
<td>[Space]</td>
<td>Store</td>
<td>Heap access</td>
</tr>
<tr>
<td>[Tab][Tab]</td>
<td>[Tab]</td>
<td>Retrieve</td>
<td>Heap access</td>
</tr>
<tr>
<td>[LF]</td>
<td>[Space][Space]<label></label></td>
<td>Mark a location in    the program</td>
<td>Flow Control</td>
</tr>
<tr>
<td>[LF]</td>
<td>[Space][Tab]<label></label></td>
<td>Call a    subroutine</td>
<td>Flow Control</td>
</tr>
<tr>
<td>[LF]</td>
<td>[Space][LF]<label></label></td>
<td>Jump unconditionally to a label</td>
<td>Flow Control</td>
</tr>
<tr>
<td>[LF]</td>
<td>[Tab][Space]<label></label></td>
<td>Jump to a label if the top of the stack is zero</td>
<td>Flow    Control</td>
</tr>
<tr>
<td>[LF]</td>
<td>[Tab][Tab]<label></label></td>
<td>Jump to a label if the    top of the stack is negative</td>
<td>Flow    Control</td>
</tr>
<tr>
<td>[LF]</td>
<td>[Tab][LF]</td>
<td>End a subroutineand transfer control back to the caller</td>
<td>Flow Control</td>
</tr>
<tr>
<td>[LF]</td>
<td>[LF][LF]</td>
<td>End the program</td>
<td>Flow Control</td>
</tr>
<tr>
<td>[Tab][LF]</td>
<td>[Space][Space]</td>
<td>Output the character at the top of the stack</td>
<td>I/O</td>
</tr>
<tr>
<td>[Tab][LF]</td>
<td>[Space][Tab]</td>
<td>Output the number at the top of the stack</td>
<td>I/O</td>
</tr>
<tr>
<td>[Tab][LF]</td>
<td>[Tab][Space]</td>
<td>Read a character and place it in the location given by the top of the stack</td>
<td>I/O</td>
</tr>
<tr>
<td>[Tab][LF]</td>
<td>[Tab][Tab]</td>
<td>Read a number and place it in the location given by the top of the stack</td>
<td>I/O</td>
</tr>
</tbody>
</table>
<p>所以这是一个将特定序列的空白符转成指令的语言。</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Tab][LF][Space][Space]</span><br></pre></td></tr></table></figure>
<p>表示将栈顶数字以 ASCII 的形式输出。</p>
<h2 id="解析_Hello_World">解析 Hello World</h2><p>空白符看起来比较不方便，将 Hello World 代码中空格替换为 [Space] ，制表符替换为 [Tab] ，换行替换为 [LF] 。</p>
<p>整理后如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Space][Space][Space][Tab][Space][Space][Tab][Space][Space][Space][LF]&#10;&#25968;&#23383;&#21387;&#26632; 0100 1000 &#20063;&#23601;&#26159;&#25968;&#23383; 72 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 72 &#20063;&#23601;&#26159; H&#10;&#10;[Space][Space][Space][Tab][Tab][Space][Space][Tab][Space][Tab][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0110 0101 &#20063;&#23601;&#26159;&#25968;&#23383; 101 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 101 &#20063;&#23601;&#26159; e&#10;&#10;[Space][Space][Space][Tab][Tab][Space][Tab][Tab][Space][Space][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0110 1100 &#20063;&#23601;&#26159;&#25968;&#23383; 108 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 108 &#20063;&#23601;&#26159; l&#10;&#10;[Space][Space][Space][Tab][Tab][Space][Tab][Tab][Space][Space][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0110 1100 &#20063;&#23601;&#26159;&#25968;&#23383; 108 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 108 &#20063;&#23601;&#26159; l&#10;&#10;[Space][Space][Space][Tab][Tab][Space][Tab][Tab][Tab][Tab][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0110 1111 &#20063;&#23601;&#26159;&#25968;&#23383; 111 &#21387;&#26632; &#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 111 &#20063;&#23601;&#26159; o&#10;&#10;[Space][Space][Space][Tab][Space][Tab][Tab][Space][Space][LF]&#10;&#25968;&#23383;&#21387;&#26632; 0 0010 1100 &#20063;&#23601;&#26159;&#25968;&#23383; 44 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 44 &#20063;&#23601;&#26159; &#65292;&#10;&#10;[Space][Space][Space][Tab][Space][Space][Space][Space][Space][LF]&#10;&#25968;&#23383;&#21387;&#26632; 0 0010 0000 &#20063;&#23601;&#26159;&#25968;&#23383; 32 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 32 &#20063;&#23601;&#26159; &#31354;&#26684;&#10;&#10;[Space][Space][Space][Tab][Tab][Tab][Space][Tab][Tab][Tab][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0111 0111 &#20063;&#23601;&#26159;&#25968;&#23383; 119 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 119 &#20063;&#23601;&#26159; w&#10;&#10;[Space][Space][Space][Tab][Tab][Space][Tab][Tab][Tab][Tab][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0110 1111 &#20063;&#23601;&#26159;&#25968;&#23383; 111 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 111 &#20063;&#23601;&#26159; o&#10;&#10;[Space][Space][Space][Tab][Tab][Tab][Space][Space][Tab][Space][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0111 0010 &#20063;&#23601;&#26159;&#25968;&#23383; 114 &#36755;&#20986;&#23383;&#31526; r&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 114 &#20063;&#23601;&#26159; r&#10;&#10;[Space][Space][Space][Tab][Tab][Space][Tab][Tab][Space][Space][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0110 1100 &#20063;&#23601;&#26159;&#25968;&#23383; 108 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 108 &#20063;&#23601;&#26159; l&#10;&#10;[Space][Space][Space][Tab][Tab][Space][Space][Tab][Space][Space][LF]&#10;&#25968;&#23383;&#21387;&#26632; 00 0110 0100 &#20063;&#23601;&#26159;&#25968;&#23383; 100 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 100 &#20063;&#23601;&#26159; d&#10;&#10;[Space][Space][Space][Tab][Space][Space][Space][Space][Tab][LF]&#10;&#25968;&#23383;&#21387;&#26632; 0 0010 0001 &#20063;&#23601;&#26159;&#25968;&#23383; 33 &#21387;&#26632;&#10;[Tab][LF][Space][Space]&#10;&#36755;&#20986;&#26632;&#39030;&#23383;&#31526; ASCII 33 &#20063;&#23601;&#26159; &#65281;&#10;&#10;[LF][LF][LF]&#10;&#31243;&#24207;&#32467;&#26463;&#31526;&#21495;</span><br></pre></td></tr></table></figure>
<p>这个 Hello World 代码很简单，只是简单的入栈出栈，没有用到跳转等复杂的功能。</p>
<h2 id="最后">最后</h2><p>这个语言最大的作用是……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍一个很干净的语言。&lt;/p&gt;
&lt;pre style=&quot;background: initial;&quot;&gt;




















&lt;/pre&gt;
    
    </summary>
    
      <category term="玩" scheme="http://en.ors-sro.com/categories/%E7%8E%A9/"/>
    
    
      <category term="Whitespace" scheme="http://en.ors-sro.com/tags/Whitespace/"/>
    
  </entry>
  
</feed>
