<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> SICP 2.2 层级数据和闭包属性 · 拖鞋党的拖鞋摊</title><meta name="description" content="SICP 2.2 层级数据和闭包属性 - 拖鞋党"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://en.ors-sro.com/atom.xml" title="拖鞋党的拖鞋摊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/icon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/rss/" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">SICP 2.2 层级数据和闭包属性</h1><div class="post-info">Apr 30, 2017</div><div class="post-content"><p>好久没填坑都快忘了……</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><code>cons</code> 可以嵌套</p>
<p><code>(cons 1 (cons 2 (cons 3 (cons 4 nil))))</code> 相当于 <code>list(1 2 3 4)</code></p>
<p>那 <code>(cons 1 (cons 2 (cons 3 4)))</code> 呢？</p>
<p>原来 <code>nil</code> 来源于意大利语 <strong>nihil</strong> ，意为无，没有。</p>
<p><code>cons</code> 还可用于在列表前面附加元素</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cons</span> <span class="number">10</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment">; (10 1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<p>那要在列表后面附加元素呢，使用 <code>append</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">append</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span>) (<span class="name">list</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment">; (1 2 3 4)</span></span><br><span class="line"><span class="comment">;; 如果第二个不是列表而是一个元素的话，结果会是 cons</span></span><br><span class="line">(<span class="name">append</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)</span><br><span class="line"><span class="comment">; (1 2 . 3)</span></span><br></pre></td></tr></table></figure>
<p>用 <code>null?</code> 来判断列表是否为空。（为什么不是 <code>nil?</code> ……）</p>
<p><code>((1 2) 3 4)</code> 可以看成 <code>(cons (list 1 2) (list 3 4))</code> </p>
<p>也可以看成树状结构，取决于目标和解释方式。</p>
<p>在递归的过程中有时候需要判断参数是不是 pair 。可以用 <code>pair?</code> 来判断。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="习题-2-17"><a href="#习题-2-17" class="headerlink" title="习题 2.17"></a>习题 2.17</h3><blockquote>
<p><strong>Exercise 2.17.</strong>  Define a procedure last-pair that returns the list that contains only the last element of a given (nonempty) list:</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">last-pair</span> (<span class="name">list</span> <span class="number">23</span> <span class="number">72</span> <span class="number">149</span> <span class="number">34</span>))</span><br><span class="line">(<span class="number">34</span>)</span><br></pre></td></tr></table></figure>
<p>列表就是一系列的 pair 。最后一个元素一定处于 <code>(cons xxx nil)</code> 的类似列表。所以通过基本的操作 <code>car</code> 和 <code>cdr</code> 不断的取尾，最后一个元素为 <code>nil</code> 时所处的 pair 第一个元素就是整个列表的最后一个元素。最后再用 <code>list</code> 封装以达到题目要求。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">last-pair</span> alist)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? (<span class="name">cdr</span> alist))</span><br><span class="line">      (<span class="name">list</span> (<span class="name">car</span> alist))</span><br><span class="line">      (<span class="name">last-pair</span> (<span class="name">cdr</span> alist))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">last-pair</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment">; =&gt; (4)</span></span><br><span class="line">(<span class="name">last-pair</span> (<span class="name">list</span> <span class="number">1</span>))</span><br><span class="line"><span class="comment">; =&gt; (1)</span></span><br><span class="line">(<span class="name">last-pair</span> (<span class="name">list</span> <span class="number">23</span> <span class="number">72</span> <span class="number">149</span> <span class="number">34</span>))</span><br><span class="line"><span class="comment">; =&gt; (34)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-18"><a href="#习题-2-18" class="headerlink" title="习题 2.18"></a>习题 2.18</h3><blockquote>
<p><strong>Exercise 2.18.</strong>  Define a procedure reverse that takes a list as argument and returns a list of the same elements in reverse order:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">reverse</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>))</span><br><span class="line">(<span class="number">25</span> <span class="number">16</span> <span class="number">9</span> <span class="number">4</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>因为列表是一个递归嵌套 pair 的结构，所以很自然要用递归的方式处理。</p>
<p>用递归的方式处理，最基本的是先确定递归退出条件。通常是考虑最小子问题。</p>
<p>在这个例子中，最小的列表是空列表。</p>
<p>逆转空列表结果还是空列表。</p>
<p>接着就是找递归的递进条件，也就是怎么把问题变成更小的问题。</p>
<p>考虑到一个列表可以拆分为第一个元素和剩余列表。</p>
<p>那么逆转一个列表，相当于逆转过后的剩余列表拼接上第一个元素。</p>
<p>这样问题的规模就缩小了。只要同样地逆转剩余列表即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">reverse</span> alist)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? alist)</span><br><span class="line">      alist</span><br><span class="line">      (<span class="name">append</span> (<span class="name">reverse</span> (<span class="name">cdr</span> alist)) </span><br><span class="line">              (<span class="name">list</span> (<span class="name">car</span> alist)))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">reverse</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment">; =&gt; (4 3 2 1)</span></span><br><span class="line">(<span class="name">reverse</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>))</span><br><span class="line"><span class="comment">; =&gt; (25 16 9 4 1)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-19"><a href="#习题-2-19" class="headerlink" title="习题 2.19"></a>习题 2.19</h3><blockquote>
<p><strong>Exercise 2.19.</strong>  Consider the change-counting program of section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.2" target="_blank" rel="noopener">1.2.2</a>. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the procedure first-denomination and partly into the procedure count-change (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.</p>
<p>We want to rewrite the procedure cc so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> us-coins (<span class="name">list</span> <span class="number">50</span> <span class="number">25</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span>))</span><br><span class="line">(<span class="name">define</span> uk-coins (<span class="name">list</span> <span class="number">100</span> <span class="number">50</span> <span class="number">20</span> <span class="number">10</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>We could then call cc as follows:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cc</span> <span class="number">100</span> us-coins)</span><br><span class="line"><span class="number">292</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>To do this will require changing the program cc somewhat. It will still have the same form, but it will access its second argument differently, as follows:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">cc</span> amount coin-values)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">=</span> amount <span class="number">0</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name">or</span> (<span class="name">&lt;</span> amount <span class="number">0</span>) (<span class="name">no-more</span>? coin-values)) <span class="number">0</span>)</span><br><span class="line">        (<span class="name">else</span></span><br><span class="line">         (<span class="name">+</span> (<span class="name">cc</span> amount</span><br><span class="line">                (<span class="name">except-first-denomination</span> coin-values))</span><br><span class="line">            (<span class="name">cc</span> (<span class="name">-</span> amount</span><br><span class="line">                   (<span class="name">first-denomination</span> coin-values))</span><br><span class="line">                coin-values)))))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Define the procedures first-denomination, except-first-denomination, and no-more? in terms of primitive operations on list structures. Does the order of the list coin-values affect the answer produced by cc? Why or why not?</p>
</blockquote>
<p>题目要求实现 <code>first-denomination</code> 、<code>except-first-denomination</code> 和 <code>no-more?</code> 。</p>
<p>其实函数名字已经提示很多了。</p>
<p><code>first-denomination</code> 是取第一个货币单位。</p>
<p><code>except-first-denomination</code> 是排除第一个货币单位。</p>
<p><code>no-more?</code> 是判断是否还有货币单位。</p>
<p>参考列表的操作，很容易写出来</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> except-first-denomination cdr)</span><br><span class="line">(<span class="name">define</span> first-denomination car)</span><br><span class="line">(<span class="name">define</span> no-more? null?)</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cc</span> <span class="number">100</span> us-coins)</span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br><span class="line">(<span class="name">cc</span> <span class="number">100</span> uk-coins)</span><br><span class="line"><span class="comment">; =&gt; 104561</span></span><br></pre></td></tr></table></figure>
<p>题目还问改变货币列表中的顺序是否会影响结果。</p>
<p>考虑到换零钱的计算方式是换某种货币的组合数加上不换某种货币的组合数。</p>
<p>显然换 100 加上不换 100 的组合等于换 5 加上不换 5 的组合。因为要兑换的总额是一样的。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> us-coins2 (<span class="name">list</span> <span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">25</span> <span class="number">50</span>))</span><br><span class="line">(<span class="name">cc</span> <span class="number">100</span> us-coins2)</span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br><span class="line">(<span class="name">cc</span> <span class="number">100</span> us-coins)</span><br><span class="line"><span class="comment">; =&gt; 292</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-20"><a href="#习题-2-20" class="headerlink" title="习题 2.20"></a>习题 2.20</h3><blockquote>
<p><strong>Exercise 2.20.</strong>  The procedures +, *, and list take arbitrary numbers of arguments. One way to define such procedures is to use define with <strong>dotted-tail notation</strong>. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedure is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter’s value will be a <strong>list</strong> of any remaining arguments. For instance, given the definition<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">f</span> x y . z) &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>the procedure f can be called with two or more arguments. If we evaluate<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">f</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>then in the body of f, x will be 1, y will be 2, and z will be the list (3 4 5 6). Given the definition<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">g</span> . w) &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>the procedure g can be called with zero or more arguments. If we evaluate<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">g</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>then in the body of g, w will be the list <code>(1 2 3 4 5 6)</code>.<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_164" target="_blank" rel="noopener">11</a></p>
<p>Use this notation to write a procedure same-parity that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">same-parity</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span><br><span class="line">(<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span>)</span><br><span class="line">(<span class="name">same-parity</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span><br><span class="line">(<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>题目介绍了不定参数的函数定义方式，通过类似 pair 的形式来定义，还是很有趣的。</p>
<p><code>same-parity</code> 肯定要支持不定参数。那么最少有几个参数？</p>
<p>是 1 个。如果是 1 个直接返回该元素即可。</p>
<p>所以 <code>same-parity</code> 的定义如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">same-parity</span> element . alist) &lt;body&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 点两边都要有空格，不然会视作函数名为 same-parity.alist 的函数。</span></span><br></pre></td></tr></table></figure>
<p>第一个参数是 <code>alist</code> 的第一个元素。</p>
<p>第二个参数是剩余的列表。</p>
<p>然后考虑如何把子问题规模缩小。</p>
<p>比如对于列表 <code>(1 2 3 4)</code></p>
<p>可以拆分为 <code>(same-parity 1 2)</code> 和 <code>(same-parity 1 (3 4))</code></p>
<p>这样问题的规模就变小了。</p>
<p>因为 <code>(same-parity 1 2)</code> 会把参数收集为列表，这样递归不是很方便，所以创建一个 <code>(same-parity-iter)</code> 。</p>
<p>完整代码如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">same-parity</span> . alist)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">same-parity-iter</span> first rest result)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">null</span>? rest)</span><br><span class="line">        result</span><br><span class="line">        (<span class="name">if</span> (<span class="name">same-parity</span>? first (<span class="name">car</span> rest))</span><br><span class="line">            (<span class="name">same-parity-iter</span> first (<span class="name">cdr</span> rest) (<span class="name">append</span> result (<span class="name">list</span> (<span class="name">car</span> rest))))</span><br><span class="line">            (<span class="name">same-parity-iter</span> first (<span class="name">cdr</span> rest) result))))</span><br><span class="line">  (<span class="name">if</span> (<span class="name">or</span> (<span class="name">=</span> (<span class="name">length</span> alist) <span class="number">0</span>)</span><br><span class="line">          (<span class="name">=</span> (<span class="name">length</span> alist) <span class="number">1</span>))</span><br><span class="line">      alist</span><br><span class="line">      (<span class="name">same-parity-iter</span> (<span class="name">car</span> alist) (<span class="name">cdr</span> alist) (<span class="name">list</span> (<span class="name">car</span> alist)))))</span><br><span class="line">      </span><br><span class="line">(<span class="name">define</span> (<span class="name">same-parity</span>? a b)</span><br><span class="line"></span><br><span class="line">  (<span class="name">or</span> (<span class="name">and</span> (<span class="name">even</span>? a) (<span class="name">even</span>? b))</span><br><span class="line"></span><br><span class="line">      (<span class="name">and</span> (<span class="name">odd</span>? a) (<span class="name">odd</span>? b))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">same-parity</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span><br><span class="line"><span class="comment">; =&gt; (1 3 5 7)</span></span><br><span class="line">(<span class="name">same-parity</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span><br><span class="line"><span class="comment">; =&gt; (2 4 6)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-21"><a href="#习题-2-21" class="headerlink" title="习题 2.21"></a>习题 2.21</h3><blockquote>
<p><strong>Exercise 2.21.</strong>  The procedure <code>square-list</code> takes a list of numbers as argument and returns a list of the squares of those numbers.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">square-list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Here are two different definitions of <code>square-list</code>. Complete both of them by filling in the missing expressions:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? items)</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name">cons</span> &lt;??&gt; &lt;??&gt;)))</span><br><span class="line">(<span class="name">define</span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name">map</span> &lt;??&gt; &lt;??&gt;))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>仿照 <code>scale-list</code> 即可得到答案</p>
<p>第一种</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? items)</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name">cons</span> (<span class="name">*</span> (<span class="name">car</span> items) (<span class="name">car</span> items)) (<span class="name">square-list</span> (<span class="name">cdr</span> items)))))</span><br></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x x)) items))</span><br></pre></td></tr></table></figure>
<h3 id="习题-2-22"><a href="#习题-2-22" class="headerlink" title="习题 2.22"></a>习题 2.22</h3><blockquote>
<p><strong>Exercise 2.22.</strong>  Louis Reasoner tries to rewrite the first square-list procedure of exercise 2.21 so that it evolves an iterative process:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> things answer)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? things)</span><br><span class="line">      answer</span><br><span class="line">      (<span class="name">iter</span> (<span class="name">cdr</span> things) </span><br><span class="line">            (<span class="name">cons</span> (<span class="name">square</span> (<span class="name">car</span> things))</span><br><span class="line">                  answer))))</span><br><span class="line">  (<span class="name">iter</span> items <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Unfortunately, defining square-list this way produces the answer list in the reverse order of the one desired. Why?</p>
<p>Louis then tries to fix his bug by interchanging the arguments to cons:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> things answer)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? things)</span><br><span class="line">      answer</span><br><span class="line">      (<span class="name">iter</span> (<span class="name">cdr</span> things)</span><br><span class="line">            (<span class="name">cons</span> answer</span><br><span class="line">                  (<span class="name">square</span> (<span class="name">car</span> things))))))</span><br><span class="line">  (<span class="name">iter</span> items <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>This doesn’t work either. Explain.</p>
</blockquote>
<p>这么做显然是有问题的。用 Applicative Order 展开就清楚了</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">square-list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name">iter</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">iter</span> (<span class="name">list</span> <span class="number">2</span> <span class="number">3</span>) (<span class="name">cons</span> <span class="number">1</span> <span class="literal">nil</span>))</span><br><span class="line">(<span class="name">iter</span> (<span class="name">list</span> <span class="number">2</span> <span class="number">3</span>) (<span class="name">list</span> <span class="number">1</span>))</span><br><span class="line">(<span class="name">iter</span> (<span class="name">list</span> <span class="number">3</span>) (<span class="name">cons</span> <span class="number">4</span> (<span class="name">list</span> <span class="number">1</span>)))</span><br><span class="line">(<span class="name">iter</span> (<span class="name">list</span> <span class="number">3</span>) (<span class="name">list</span> <span class="number">4</span> <span class="number">1</span>))</span><br><span class="line">(<span class="name">iter</span> <span class="literal">nil</span> (<span class="name">cons</span> <span class="number">9</span> (<span class="name">list</span> <span class="number">4</span> <span class="number">1</span>)))</span><br><span class="line">(<span class="name">iter</span> <span class="literal">nil</span> (<span class="name">list</span> <span class="number">9</span> <span class="number">4</span> <span class="number">1</span>))</span><br><span class="line"><span class="comment">; (9 4 1)</span></span><br></pre></td></tr></table></figure>
<p>再看修正版，还是使用 Applicative Order 展开</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">square-list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name">iter</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">iter</span> (<span class="name">list</span> <span class="number">2</span> <span class="number">3</span>) (<span class="name">cons</span> <span class="literal">nil</span> <span class="number">1</span>))</span><br><span class="line">(<span class="name">iter</span> (<span class="name">list</span> <span class="number">3</span>) (<span class="name">cons</span> (<span class="name">cons</span> <span class="literal">nil</span> <span class="number">1</span>) <span class="number">4</span>))</span><br><span class="line">(<span class="name">iter</span> <span class="literal">nil</span> (<span class="name">cons</span> (<span class="name">cons</span> (<span class="name">cons</span> <span class="literal">nil</span> <span class="number">1</span>) <span class="number">4</span>) <span class="number">9</span>))</span><br><span class="line"><span class="comment">; (((1) . 4) . 9)</span></span><br></pre></td></tr></table></figure>
<p>这次他虽然调整了顺序，但是没有使用正确的方式附加元素。</p>
<p>按照提供的现有函数，如果想在列表后面附加元素应该使用 <code>append</code> 和 <code>list</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">append</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) (<span class="name">list</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<p>所以这么改就可以了。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-list</span> items)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> things answer)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? things)</span><br><span class="line">      answer</span><br><span class="line">      (<span class="name">iter</span> (<span class="name">cdr</span> things)</span><br><span class="line">            (<span class="name">append</span> answer</span><br><span class="line">                  (<span class="name">list</span> (<span class="name">square</span> (<span class="name">car</span> things)))))</span><br><span class="line">  (<span class="name">iter</span> items <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">square-list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">; =&gt; (1 4 9 16)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-23"><a href="#习题-2-23" class="headerlink" title="习题 2.23"></a>习题 2.23</h3><blockquote>
<p><strong>Exercise 2.23.</strong>  The procedure for-each is similar to map. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, for-each just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all – for-each is used with procedures that perform an action, such as printing. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">for-each</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">newline</span>) (<span class="name">display</span> x))</span><br><span class="line"> (<span class="name">list</span> <span class="number">57</span> <span class="number">321</span> <span class="number">88</span>))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>573<br>21<br>88</p>
<p>The value returned by the call to for-each (not illustrated above) can be something arbitrary, such as true. Give an implementation of for-each.</p>
</blockquote>
<p>比起 <code>map</code> ，<code>for-each</code> 更注重操作的副作用，而不是结果。</p>
<p>所以如果不介意返回值的话，完全可以把 <code>map</code> 当作 <code>for-each</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> for-each map)</span><br></pre></td></tr></table></figure>
<p>如果自己写是这样的。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">for-each</span> f alist)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? alist)</span><br><span class="line">      #t</span><br><span class="line">      (<span class="name">list</span>  (<span class="name">for-each</span> f (<span class="name">cdr</span> alist)) (<span class="name">f</span> (<span class="name">car</span> alist)))))</span><br></pre></td></tr></table></figure>
<p>注意把 <code>(f (car alist))</code> 放在后面，因为参数求值从后面开始。</p>
<h3 id="习题-2-24"><a href="#习题-2-24" class="headerlink" title="习题 2.24"></a>习题 2.24</h3><blockquote>
<p><strong>Exercise 2.24.</strong>  Suppose we evaluate the expression <code>(list 1 (list 2 (list 3 4)))</code>. Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree (as in figure <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_fig_2.6" target="_blank" rel="noopener">2.6</a>).</p>
</blockquote>
<p>表达式的结果是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">list</span> <span class="number">1</span> (<span class="name">list</span> <span class="number">2</span> (<span class="name">list</span> <span class="number">3</span> <span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">; =&gt; (1 (2 (3 4)))</span></span><br></pre></td></tr></table></figure>
<p>盒子图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+---+---+      +---+---+</span><br><span class="line"></span><br><span class="line">|   |   | +--&gt; |   |   |</span><br><span class="line"></span><br><span class="line">+-+-+---+      +-+-+---+</span><br><span class="line"></span><br><span class="line">  |              |</span><br><span class="line"></span><br><span class="line">  v              v</span><br><span class="line"></span><br><span class="line">+---+---+      +---+---+       +---+---+</span><br><span class="line"></span><br><span class="line">|   |   |      |   |   | +---&gt; |   |   |</span><br><span class="line"></span><br><span class="line">+-+-+---+      +-+-+---+       +-+-+---+</span><br><span class="line"></span><br><span class="line">  |              |               |</span><br><span class="line"></span><br><span class="line">  v              v               v</span><br><span class="line"></span><br><span class="line">+---+---+      +---+---+       +---+---+      +---+---+</span><br><span class="line"></span><br><span class="line">|   |   |      |   |   |       |   |   | +--&gt; |   |   |</span><br><span class="line"></span><br><span class="line">+-+-+---+      +-+-+---+       +-+-+---+      +-+-+---+</span><br><span class="line"></span><br><span class="line">  |              |               |              |</span><br><span class="line"></span><br><span class="line">  v              v               v              v</span><br><span class="line"></span><br><span class="line">+-+             +-+             +-+            +-+</span><br><span class="line"></span><br><span class="line">|1|             |2|             |3|            |4|</span><br><span class="line"></span><br><span class="line">+-+             +-+             +-+            +-+</span><br></pre></td></tr></table></figure>
<p>树状图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1 (2 (3 4)))</span><br><span class="line">├─1</span><br><span class="line">└──(2 (3 4))</span><br><span class="line">    ├──2</span><br><span class="line">    └──(3 4)</span><br><span class="line">        ├──3</span><br><span class="line">        └──4</span><br></pre></td></tr></table></figure>
<h3 id="习题-2-25"><a href="#习题-2-25" class="headerlink" title="习题 2.25"></a>习题 2.25</h3><blockquote>
<p><strong>Exercise 2.25.</strong>  Give combinations of <code>car</code>s and <code>cdr</code>s that will pick 7 from each of the following lists:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> <span class="number">3</span> (<span class="number">5</span> <span class="number">7</span>) <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">((<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span> (<span class="number">2</span> (<span class="number">3</span> (<span class="number">4</span> (<span class="number">5</span> (<span class="number">6</span> <span class="number">7</span>))))))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>由内往外，一步步使用 <code>car</code> 和 <code>cdr</code> 即可。</p>
<p>比如对于<code>(1 3 (5 7) 9)</code> 先从 <code>(5 7)</code>下手。</p>
<p>想要得到 <code>(5 7)</code> 中的 7 只需要 <code>(car (cdr (5 7))</code></p>
<p>对于 <code>(1 3 (5 7) 9)</code> 先要 <code>cdr</code> 得到 <code>(3 (5 7) 9)</code> </p>
<p>然后再 <code>cdr</code> 得到 <code>((5 7) 9)</code> </p>
<p>再 <code>car</code> 一下就能得到 <code>(5 7)</code>了。</p>
<p>所以答案如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; (1 3 (5 7) 9)</span></span><br><span class="line">(<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">cdr</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">3</span> (<span class="name">list</span> <span class="number">5</span> <span class="number">7</span>) <span class="number">9</span>))))))</span><br><span class="line"><span class="comment">; ((7))</span></span><br><span class="line">(<span class="name">car</span> (<span class="name">car</span> (<span class="name">list</span> (<span class="name">list</span> <span class="number">7</span>))))</span><br><span class="line"><span class="comment">; (1 (2 (3 (4 (5 (6 7))))))</span></span><br><span class="line">(<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">list</span> <span class="number">1</span> (<span class="name">list</span> <span class="number">2</span> (<span class="name">list</span> <span class="number">3</span> (<span class="name">list</span> <span class="number">4</span> (<span class="name">list</span> <span class="number">5</span> (<span class="name">list</span> <span class="number">6</span> <span class="number">7</span>))))))))))))))))))</span><br></pre></td></tr></table></figure>
<p>要注意 <code>cdr</code> 始终返回一个列表，所以 <code>(cdr (5 (6 7)))</code> 是 <code>((6 7))</code> 不是 <code>(6 7)</code> 。</p>
<h3 id="习题-2-26"><a href="#习题-2-26" class="headerlink" title="习题 2.26"></a>习题 2.26</h3><blockquote>
<p><strong>Exercise 2.26.</strong>  Suppose we define <code>x</code> and <code>y</code> to be two lists:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name">define</span> y (<span class="name">list</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>What result is printed by the interpreter in response to evaluating each of the following expressions:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">append</span> x y)</span><br><span class="line">(<span class="name">cons</span> x y)</span><br><span class="line">(<span class="name">list</span> x y)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>答案如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name">define</span> y (<span class="name">list</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>))</span><br><span class="line">(<span class="name">append</span> x y)</span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4 5 6)</span></span><br><span class="line">(<span class="name">cons</span> x y)</span><br><span class="line"><span class="comment">; =&gt; ((1 2 3) 4 5 6)</span></span><br><span class="line">(<span class="name">list</span> x y)</span><br><span class="line"><span class="comment">; =&gt; ((1 2 3) (4 5 6))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-27"><a href="#习题-2-27" class="headerlink" title="习题 2.27"></a>习题 2.27</h3><blockquote>
<p><strong>Exercise 2.27.</strong>  Modify your <code>reverse</code> procedure of exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_thm_2.18" target="_blank" rel="noopener">2.18</a> to produce a <code>deep-reverse</code> procedure that takes a list as argument and returns as its value the list with its elements reversed and with all subsists deep-reversed as well. For example,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x (<span class="name">list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span>) (<span class="name">list</span> <span class="number">3</span> <span class="number">4</span>)))</span><br><span class="line">x</span><br><span class="line">((<span class="number">1</span> <span class="number">2</span>) (<span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name">reverse</span> x)</span><br><span class="line">((<span class="number">3</span> <span class="number">4</span>) (<span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name">deep-reverse</span> x)</span><br><span class="line">((<span class="number">4</span> <span class="number">3</span>) (<span class="number">2</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>首先定义规则，深度反转空列表还是空列表。</p>
<p>深度反转单个叶子节点还是单个叶子节点。</p>
<p>深度反正一棵树等于反转剩余列表拼接上反转第一个列表。</p>
<p>翻译成代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">deep-reverse</span> tree)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? tree) ())</span><br><span class="line">        ((<span class="name">not</span> (<span class="name">pair</span>? tree)) (<span class="name">list</span> tree))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">append</span> (<span class="name">deep-reverse</span> (<span class="name">cdr</span> tree))</span><br><span class="line">                      (<span class="name">deep-reverse</span> (<span class="name">car</span> tree))))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x (<span class="name">list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span>) (<span class="name">list</span> <span class="number">3</span> <span class="number">4</span>)))</span><br><span class="line">(<span class="name">deep-reverse</span> x)</span><br><span class="line"><span class="comment">; =&gt; ((4 3) (2 1))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-28"><a href="#习题-2-28" class="headerlink" title="习题 2.28"></a>习题 2.28</h3><blockquote>
<p><strong>Exercise 2.28.</strong>  Write a procedure <code>fringe</code> that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x (<span class="name">list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span>) (<span class="name">list</span> <span class="number">3</span> <span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">fringe</span> x)</span><br><span class="line">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">fringe</span> (<span class="name">list</span> x x))</span><br><span class="line">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>类似上一题， <code>fringe</code> 空列表为空列表</p>
<p><code>fringe</code> 单个元素为单个元素。</p>
<p><code>fringe</code> 一棵树为<code>fringe</code> 第一个列表拼接上 <code>fringe</code> 剩余元素。</p>
<p>翻译成代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">fringe</span> tree)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? tree) ())</span><br><span class="line">        ((<span class="name">not</span> (<span class="name">pair</span>? tree)) (<span class="name">list</span> tree))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">append</span> (<span class="name">fringe</span> (<span class="name">car</span> tree))</span><br><span class="line">                      (<span class="name">fringe</span> (<span class="name">cdr</span> tree))))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x (<span class="name">list</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span>) (<span class="name">list</span> <span class="number">3</span> <span class="number">4</span>)))</span><br><span class="line">(<span class="name">fringe</span> x)</span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4)</span></span><br><span class="line">(<span class="name">fringe</span> (<span class="name">list</span> x x))</span><br><span class="line"><span class="comment">; =&gt; (1 2 3 4 1 2 3 4)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-29"><a href="#习题-2-29" class="headerlink" title="习题 2.29"></a>习题 2.29</h3><blockquote>
<p><strong>Exercise 2.29.</strong>  A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using <code>list</code>):</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-mobile</span> left right)</span><br><span class="line">  (<span class="name">list</span> left right))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A branch is constructed from a <code>length</code> (which must be a number) together with a <code>structure</code>, which may be either a number (representing a simple weight) or another mobile:</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-branch</span> length structure)</span><br><span class="line">  (<span class="name">list</span> length structure))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>a.  Write the corresponding selectors <code>left-branch</code> and <code>right-branch</code>, which return the branches of a mobile, and <code>branch-length</code> and <code>branch-structure</code>, which return the components of a branch.</p>
<p>b.  Using your selectors, define a procedure <code>total-weight</code> that returns the total weight of a mobile.</p>
<p>c.  A mobile is said to be <strong>balanced</strong> if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate that tests whether a binary mobile is balanced.</p>
<p>d.  Suppose we change the representation of mobiles so that the constructors are</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-mobile</span> left right)</span><br><span class="line">  (<span class="name">cons</span> left right))</span><br><span class="line">(<span class="name">define</span> (<span class="name">make-branch</span> length structure)</span><br><span class="line">  (<span class="name">cons</span> length structure))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>How much do you need to change your programs to convert to the new representation?</p>
</blockquote>
<p>问题 a 。只需要看数据结构的定义，所以四个选择器的定义如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> left-branch car)</span><br><span class="line">(<span class="name">define</span> (<span class="name">right-branch</span> tree) (<span class="name">car</span> (<span class="name">cdr</span> tree)))</span><br><span class="line">(<span class="name">define</span> branch-length car)</span><br><span class="line">(<span class="name">define</span> (<span class="name">branch-structure</span> branch) (<span class="name">car</span> (<span class="name">cdr</span> branch)))</span><br></pre></td></tr></table></figure>
<p>接着实现问题 b 要求的 <code>total-weight</code> 。</p>
<p>分支的最基本类型是形如 <code>(5 3)</code> 这种第一个是长度，第二个是重量的类型。</p>
<p>这种情况分支的重量为 3</p>
<p>其他情况下分支的重量等于左子树的重量加上右子树的重量。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">total-weight</span> mobile)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">not</span> (<span class="name">pair</span>? mobile))</span><br><span class="line">      mobile</span><br><span class="line">      (<span class="name">+</span> (<span class="name">total-weight</span> (<span class="name">branch-structure</span> (<span class="name">left-branch</span> mobile)))</span><br><span class="line">         (<span class="name">total-weight</span> (<span class="name">branch-structure</span> (<span class="name">right-branch</span> mobile))))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> l (<span class="name">make-branch</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name">define</span> r (<span class="name">make-branch</span> <span class="number">6</span> <span class="number">7</span>))</span><br><span class="line">(<span class="name">define</span> s (<span class="name">make-branch</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name">define</span> x (<span class="name">make-mobile</span> s (<span class="name">make-branch</span> <span class="number">7</span> (<span class="name">make-mobile</span> l r))))</span><br><span class="line">x</span><br><span class="line"><span class="comment">; =&gt; ((1 2) (7 ((3 4) (6 7))))</span></span><br><span class="line">(<span class="name">total-weight</span> x)</span><br><span class="line"><span class="comment">; =&gt; 13</span></span><br><span class="line">(<span class="name">total-weight</span> (<span class="name">make-mobile</span> l r))</span><br><span class="line"><span class="comment">; =&gt; 11</span></span><br></pre></td></tr></table></figure>
<p>问题 c 中定义平衡为所有的左右子数长度和重量的乘积相等。</p>
<p>对于最基本的 mobile 比如 2 。因为没有左右子树，所以认为是相等的。</p>
<p>对于其他的 mobile 比如 <code>((1 2) (3 4))</code> 判断左右重量和长度的乘积是否相等。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">balanced</span>? mobile)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">not</span> (<span class="name">pair</span>? mobile))</span><br><span class="line">      #t</span><br><span class="line">      (<span class="name">=</span> (<span class="name">*</span> (<span class="name">branch-length</span> (<span class="name">left-branch</span> mobile))</span><br><span class="line">            (<span class="name">total-weight</span> (<span class="name">branch-structure</span> (<span class="name">left-branch</span> mobile))))</span><br><span class="line">         (<span class="name">*</span> (<span class="name">branch-length</span> (<span class="name">right-branch</span> mobile))</span><br><span class="line">            (<span class="name">total-weight</span> (<span class="name">branch-structure</span> (<span class="name">right-branch</span> mobile)))))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> l (<span class="name">make-branch</span> <span class="number">3</span> <span class="number">4</span>)) </span><br><span class="line">(<span class="name">define</span> r (<span class="name">make-branch</span> <span class="number">6</span> <span class="number">7</span>)) </span><br><span class="line">(<span class="name">define</span> s (<span class="name">make-branch</span> <span class="number">1</span> <span class="number">2</span>)) </span><br><span class="line">(<span class="name">define</span> x (<span class="name">make-mobile</span> s (<span class="name">make-branch</span> <span class="number">7</span> (<span class="name">make-mobile</span> l r))))</span><br><span class="line">(<span class="name">balanced</span>? x)</span><br><span class="line"><span class="comment">; =&gt; #f</span></span><br><span class="line">(<span class="name">balanced</span>? (<span class="name">make-mobile</span> l l))</span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br><span class="line">(<span class="name">balanced</span>? (<span class="name">make-mobile</span> r r))</span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br><span class="line">(<span class="name">balanced</span>? (<span class="name">make-mobile</span> (<span class="name">make-branch</span> <span class="number">3</span> <span class="number">4</span>) (<span class="name">make-branch</span> <span class="number">2</span> <span class="number">6</span>)))</span><br><span class="line"><span class="comment">; =&gt; #t</span></span><br></pre></td></tr></table></figure>
<p>问题 d 。如果改变了定义中的数据结构，需要改动哪些。</p>
<p>基本的选择子肯定要改，还有要改的地方是 <code>total-weight</code> 和 <code>balanced?</code> 中判断是否为最基本的 mobile 的 语句。</p>
<p>也就是 <code>(not (pair? mobile))</code> 。</p>
<p>之所以要该这里是因为这里没有引入抽象屏障，<code>total-weight</code> 和 <code>balanced?</code> 知道了 mobile 的实现。</p>
<h3 id="习题-2-30"><a href="#习题-2-30" class="headerlink" title="习题 2.30"></a>习题 2.30</h3><blockquote>
<p><strong>Exercise 2.30.</strong>  Define a procedure <code>square-tree</code> analogous to the <code>square-list</code> procedure of exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.21" target="_blank" rel="noopener">2.21</a>. That is, <code>square-list</code> should behave as follows:</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">square-tree</span></span><br><span class="line"> (<span class="name">list</span> <span class="number">1</span></span><br><span class="line">       (<span class="name">list</span> <span class="number">2</span> (<span class="name">list</span> <span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>)</span><br><span class="line">       (<span class="name">list</span> <span class="number">6</span> <span class="number">7</span>)))</span><br><span class="line">(<span class="number">1</span> (<span class="number">4</span> (<span class="number">9</span> <span class="number">16</span>) <span class="number">25</span>) (<span class="number">36</span> <span class="number">49</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Define <code>square-tree</code> both directly (i.e., without using any higher-order procedures) and also by using <code>map</code> and recursion.</p>
</blockquote>
<p>仿照 <code>scale-tree</code> 来做即可。</p>
<p>第一种，不使用高阶函数的类型</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-tree</span> tree)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? tree) ())</span><br><span class="line">        ((<span class="name">not</span> (<span class="name">pair</span>? tree)) (<span class="name">square</span> tree))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">cons</span> (<span class="name">square-tree</span> (<span class="name">car</span> tree))</span><br><span class="line">                    (<span class="name">square-tree</span> (<span class="name">cdr</span> tree))))))</span><br></pre></td></tr></table></figure>
<p>第二种，使用 <code>map</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-tree</span> tree)</span><br><span class="line">  (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">sub-tree</span>)</span><br><span class="line">        (<span class="name">if</span> (<span class="name">not</span> (<span class="name">pair</span>? sub-tree))</span><br><span class="line">            (<span class="name">square</span> sub-tree)</span><br><span class="line">            (<span class="name">square-tree</span> sub-tree)))</span><br><span class="line">      tree))</span><br></pre></td></tr></table></figure>
<h3 id="习题-2-31"><a href="#习题-2-31" class="headerlink" title="习题 2.31"></a>习题 2.31</h3><blockquote>
<p><strong>Exercise 2.31.</strong>  Abstract your answer to exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.30" target="_blank" rel="noopener">2.30</a> to produce a procedure <code>tree-map</code> with the property that <code>square-tree</code> could be defined as</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-tree</span> tree) (<span class="name">tree-map</span> square tree))</span><br></pre></td></tr></table></figure>
<p>只要照着上题把用到 <code>square</code> 的替换即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">tree-map</span> f tree)</span><br><span class="line">  (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">sub-tree</span>)</span><br><span class="line">        (<span class="name">if</span> (<span class="name">not</span> (<span class="name">pair</span>? sub-tree))</span><br><span class="line">            (<span class="name">f</span> sub-tree)</span><br><span class="line">            (<span class="name">tree-map</span> f sub-tree)))</span><br><span class="line">      tree))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">square-tree</span> '(<span class="number">1</span> (<span class="number">2</span> (<span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>) (<span class="number">6</span> <span class="number">7</span>)))</span><br><span class="line"><span class="comment">; =&gt; (1 (4 (9 16) 25) (36 49))</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-32"><a href="#习题-2-32" class="headerlink" title="习题 2.32"></a>习题 2.32</h3><blockquote>
<p><strong>Exercise 2.32.</strong>  We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is <code>(1 2 3)</code>, then the set of all subsets is <code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code>. Complete the following definition of a procedure that generates the set of subsets of a set and give a clear explanation of why it works:</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">subsets</span> s)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? s)</span><br><span class="line">      (<span class="name">list</span> <span class="literal">nil</span>)</span><br><span class="line">      (<span class="name">let</span> ((<span class="name">rest</span> (<span class="name">subsets</span> (<span class="name">cdr</span> s))))</span><br><span class="line">        (<span class="name">append</span> rest (<span class="name">map</span> &lt;??&gt; rest)))))</span><br></pre></td></tr></table></figure>
<p>对于 <code>(subset (list 1 2 3))</code> 中 <code>rest</code> 为 <code>(subset (list 2 3))</code> </p>
<p>即 <code>((3) (2) (2 3) () )</code> 。对比 <code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code></p>
<p>发现少了 <code>(1) (1 3) (1 2)</code>。</p>
<p>所以需要用 <code>map</code> 把每一个元素拼接成子集。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">subsets</span> s)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">null</span>? s)</span><br><span class="line">        (<span class="name">list</span> '())</span><br><span class="line">        (<span class="name">let</span> ((<span class="name">rest</span> (<span class="name">subsets</span> (<span class="name">cdr</span> s))))</span><br><span class="line">            (<span class="name">append</span> rest (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">x</span>)</span><br><span class="line">                                (<span class="name">cons</span> (<span class="name">car</span> s) x))</span><br><span class="line">                              rest)))))</span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>()</code> 的子集是 <code>(())</code>。</p>
<h3 id="习题-2-33"><a href="#习题-2-33" class="headerlink" title="习题 2.33"></a>习题 2.33</h3><blockquote>
<p><strong>Exercise 2.33.</strong>  Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">map</span> p sequence)</span><br><span class="line">  (<span class="name">accumulate</span> (<span class="name">lambda</span> (<span class="name">x</span> y) &lt;??&gt;) <span class="literal">nil</span> sequence))</span><br><span class="line">(<span class="name">define</span> (<span class="name">append</span> seq1 seq2)</span><br><span class="line">  (<span class="name">accumulate</span> cons &lt;??&gt; &lt;??&gt;))</span><br><span class="line">(<span class="name">define</span> (<span class="name">length</span> sequence)</span><br><span class="line">  (<span class="name">accumulate</span> &lt;??&gt; <span class="number">0</span> sequence))</span><br></pre></td></tr></table></figure>
<p>注意到 <code>accumulate</code> 中的函数第一个参数 <code>x</code> 是当前 <code>sequance</code> 的值，<code>y</code> 是累积的值。</p>
<p>所以只需要运算后拼接起来就可以了。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">map</span> p sequence)</span><br><span class="line">  (<span class="name">accumulate</span> (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">cons</span> (<span class="name">p</span> x) y)) <span class="literal">nil</span> sequence))</span><br></pre></td></tr></table></figure>
<p>对于 <code>append</code> 只需要将 <code>seq1</code> 中的元素一个个 <code>cons</code> 上去即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">append</span> seq1 seq2)</span><br><span class="line">  (<span class="name">accumulate</span> cons seq2 seq1))</span><br></pre></td></tr></table></figure>
<p>计算长度，每个元素 + 1 长度。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">length</span> sequence)</span><br><span class="line">  (<span class="name">accumulate</span> (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">+</span> y <span class="number">1</span>)) <span class="number">0</span> sequence))</span><br></pre></td></tr></table></figure>
<h3 id="习题-2-34"><a href="#习题-2-34" class="headerlink" title="习题 2.34"></a>习题 2.34</h3><blockquote>
<p><strong>Exercise 2.34.</strong>  Evaluating a polynomial in $x$ at a given value of $x$ can be formulated as an accumulation. We evaluate the polynomial<br>$$<br>a_nr^n + a_{n-1}r^{n-1} + \cdots + a_1r + a_0<br>$$<br>using a well-known algorithm called <strong>Horner’s rule</strong>, which structures the computation as<br>$$<br>(\cdots(a_nr + a_{n-1})r + \cdots + a_1)r + a_0<br>$$<br>In other words, we start with $a_n$ multiply by $x$, add $a_{n-1}$, multiply by $x$, and so on, until we reach $a_0$.<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_186" target="_blank" rel="noopener">16</a> Fill in the following template to produce a procedure that evaluates a polynomial using Horner’s rule. Assume that the coefficients of the polynomial are arranged in a sequence, from $a_0$ through $a_n$.</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">horner-eval</span> x coefficient-sequence)</span><br><span class="line">  (<span class="name">accumulate</span> (<span class="name">lambda</span> (<span class="name">this-coeff</span> higher-terms) &lt;??&gt;)</span><br><span class="line">              <span class="number">0</span></span><br><span class="line">              coefficient-sequence))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>For example, to compute $1+3x+5x^3+x^5$ at  $x = 2$ you would evaluate</p>
<p><code>(horner-eval 2 (list 1 3 0 5 0 1))</code></p>
</blockquote>
<p>注意到 <code>accumulate</code> 的计算顺序是从右到左。所以只需要重复计算 $a_nr+a_{n-1}$ 即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">horner-eval</span> x coefficient-sequence)</span><br><span class="line">  (<span class="name">accumulate</span> (<span class="name">lambda</span> (<span class="name">this-coeff</span> higher-terms)   (<span class="name">+</span> (<span class="name">*</span> higher-terms x)</span><br><span class="line">                                                       this-coeff))</span><br><span class="line">              <span class="number">0</span></span><br><span class="line">              coefficient-sequence))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">horner-eval</span> <span class="number">1</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment">; =&gt; 10</span></span><br><span class="line">(<span class="name">horner-eval</span> <span class="number">2</span> (<span class="name">list</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span>))</span><br><span class="line"><span class="comment">; =&gt; 79</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-35"><a href="#习题-2-35" class="headerlink" title="习题 2.35"></a>习题 2.35</h3><blockquote>
<p><strong>Exercise 2.35.</strong>  Redefine <code>count-leaves</code> from section <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.2" target="_blank" rel="noopener">2.2.2</a> as an accumulation:</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">count-leaves</span> <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">accumulate</span> &lt;??&gt; &lt;??&gt; (<span class="name">map</span> &lt;??&gt; &lt;??&gt;)))</span><br></pre></td></tr></table></figure>
<p>用 <code>map</code> 遍历数，如果是叶子就长度 + 1，不是就计算叶子数量。这样累加就能得到答案。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">count-leaves</span> <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">accumulate</span> + <span class="number">0</span> (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">sub-tree</span>)</span><br><span class="line">                         (<span class="name">if</span> (<span class="name">not</span> (<span class="name">pair</span>? sub-tree))</span><br><span class="line">                             <span class="number">1</span></span><br><span class="line">                             (<span class="name">count-leaves</span> sub-tree)))</span><br><span class="line">                       <span class="literal">t</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="习题-2-36"><a href="#习题-2-36" class="headerlink" title="习题 2.36"></a>习题 2.36</h3><blockquote>
<p><strong>Exercise 2.36.</strong>  The procedure <code>accumulate-n</code> is similar to <code>accumulate</code> except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation procedure to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results. For instance, if <code>s</code> is a sequence containing four sequences, <code>((1 2 3) (4 5 6) (7 8 9) (10 11 12))</code>, then the value of <code>(accumulate-n + 0 s)</code> should be the sequence <code>(22 26 30)</code>. Fill in the missing expressions in the following definition of <code>accumulate-n</code>:</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">accumulate-n</span> op init seqs)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? (<span class="name">car</span> seqs))</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name">cons</span> (<span class="name">accumulate</span> op init &lt;??&gt;)</span><br><span class="line">            (<span class="name">accumulate-n</span> op init &lt;??&gt;))))</span><br></pre></td></tr></table></figure>
<p>对于空的序列 <code>(())</code> 结果为 <code>()</code>。</p>
<p>对于非空序列 <code>((1 2) (3 4))</code> 结果是 <code>(cons (list 1 3) (list 2 4))</code></p>
<p>所以要得到序列中的每一个元素，使用 <code>map car</code> 。</p>
<p>剩下的类似</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">accumulate-n</span> op init seqs)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? (<span class="name">car</span> seqs))</span><br><span class="line">      ()</span><br><span class="line">      (<span class="name">cons</span> (<span class="name">accumulate</span> op init (<span class="name">map</span> car seqs))</span><br><span class="line">            (<span class="name">accumulate-n</span> op init (<span class="name">map</span> cdr seqs)))))</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">accumulate-n</span> + <span class="number">0</span> '(()))</span><br><span class="line"><span class="comment">; =&gt; ()</span></span><br><span class="line">(<span class="name">accumulate-n</span> + <span class="number">0</span> '((<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) (<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>) (<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>)))</span><br><span class="line"><span class="comment">; =&gt; (12 15 18)</span></span><br></pre></td></tr></table></figure>
<h3 id="习题-2-37"><a href="#习题-2-37" class="headerlink" title="习题 2.37"></a>习题 2.37</h3><blockquote>
<p><strong>Exercise 2.37.</strong>  Suppose we represent vectors $v = (v_i)$  as sequences of numbers, and matrices $m = (m_{ij})$ as sequences of vectors (the rows of the matrix). For example, the matrix<br>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 &amp; 4\<br>4 &amp; 5 &amp; 6 &amp; 6\<br>6 &amp; 7 &amp; 8 &amp; 9<br>\end{bmatrix}<br>$$<br>is represented as the sequence <code>((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>. With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:</p>
<table>
<thead>
<tr>
<th><code>(dot-product v w)</code></th>
<th>returns the sum $\sum_{i} v_iw_i$</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(matrix-*-vector m v)</code></td>
<td>returns the vector $t$, where $t_i = \sum_j m_{ij}v_j$</td>
</tr>
<tr>
<td><code>(matrix-*-matrix m n)</code></td>
<td>returns the matrix $p$, where $p_{ij} = \sum_{k} m_{ik}n_{kj}$</td>
</tr>
<tr>
<td><code>(transpose m)</code></td>
<td>returns the matrix $n$, where $n_{ij} = m_{ji}$</td>
</tr>
</tbody>
</table>
<p>We can define the dot product as<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#footnote_Temp_190" target="_blank" rel="noopener">17</a></p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">dot-product</span> v w)</span><br><span class="line">  (<span class="name">accumulate</span> + <span class="number">0</span> (<span class="name">map</span> * v w)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Fill in the missing expressions in the following procedures for computing the other matrix operations. (The procedure <code>accumulate-n</code> is defined in exercise <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.36" target="_blank" rel="noopener">2.36</a>.)</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">matrix-*-vector</span> m v)</span><br><span class="line">  (<span class="name">map</span> &lt;??&gt; m))</span><br><span class="line">(<span class="name">define</span> (<span class="name">transpose</span> mat)</span><br><span class="line">  (<span class="name">accumulate-n</span> &lt;??&gt; &lt;??&gt; mat))</span><br><span class="line">(<span class="name">define</span> (<span class="name">matrix-*-matrix</span> m n)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">cols</span> (<span class="name">transpose</span> n)))</span><br><span class="line">    (<span class="name">map</span> &lt;??&gt; m)))</span><br></pre></td></tr></table></figure>
<p>先看 <code>matrix-*-vector</code> 中 <code>map</code> 后是一个 vector ，根据矩阵和向量乘法的定义，需要两个向量相乘。</p>
<p>所以需要使用 <code>dot-product</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">matrix-*-vector</span> m v)</span><br><span class="line">  (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">mi</span>) (<span class="name">dot-product</span> v mi)) m))</span><br></pre></td></tr></table></figure>
<p>对于转置 <code>transpose</code> ，每个元素之间只需要 <code>cons</code> </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">transpose</span> mat)</span><br><span class="line">  (<span class="name">accumulate-n</span> cons '() mat))</span><br></pre></td></tr></table></figure>
<p>然后是矩阵相乘，<code>matrix-*-matrix</code> 中的 <code>map</code> 后是一个 vector，而 $n$ 转置后还是一个矩阵。</p>
<p>将转置过后 $n$ 的每一行和 $m$ 每一行相乘。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">matrix-*-matrix</span> m n)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">cols</span> (<span class="name">transpose</span> n)))</span><br><span class="line">    (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">mi</span>) (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">ni</span>) (<span class="name">dot-product</span> ni mi)) cols) m)))</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/Prototype-base-object-oriented-programming/" class="prev">上一篇</a><a href="/Lexical-scope-and-Dynamic-scope/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://en.ors-sro.com">拖鞋党</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold; animation: breathe 3s infinite">Coding Pages</a></p></div></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [ ['$','$'], ["\\\(","\\)"] ],
    processEscapes: true
    }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});
</script></body></html>