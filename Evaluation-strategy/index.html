<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 求值策略 · 拖鞋党的拖鞋摊</title><meta name="description" content="求值策略 - 拖鞋党"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://en.ors-sro.com/atom.xml" title="拖鞋党的拖鞋摊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/icon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/rss/" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">求值策略</h1><div class="post-info">Dec 25, 2016</div><div class="post-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>有多少人写过这样的交换函数，然后发现调用后并不能交换。老师告诉我们因为这是按值调用。</p>
<p>按值调用是求值策略中的一种。</p>
<p><a href="https://en.wikipedia.org/wiki/Evaluation_strategy" target="_blank" rel="noopener">求值策略</a>是一种表达式求值时的时机（严格求值，非严格求值等）和求值的内容（传值，传引用，传指针，传名等）的策略。</p>
<h2 id="严格求值"><a href="#严格求值" class="headerlink" title="严格求值"></a>严格求值</h2><p>严格求值是指参数总在函数调用前求值。也就是指明了求值策略的<strong>时机</strong>。</p>
<p>根据求值的<strong>内容</strong>划分，常见的形式有<strong>按值调用</strong>和<strong>按引用调用</strong>。</p>
<p>按值调用（call by value），参数传递的是值的副本，不能改变原本的值。实现方式有值传递（pass by value）</p>
<p>按引用调用（call by reference），参数传递的是引用的副本，也就是<strong>关注的值</strong>的引用。能改变<strong>关注的值</strong>。实现方式有传引用（pass by reference），传指针（pass by pointer）等。</p>
<p>所以要从<strong>行为</strong>上区分，如果只从数据上看，所有都是按值调用，区分求值策略也就没有意义了。</p>
<p>求值策略跟语言语法无关，实现方式才跟语言语法有关。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以 C ++ 为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  second = second + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusOneByReference</span><span class="params">(<span class="keyword">int</span>&amp; second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  second = second + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">  plusOne(a);            <span class="comment">// 按值调用</span></span><br><span class="line">  plusOneByReference(b); <span class="comment">// 按引用调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>plusOne</code> 调用，关注的值 <code>a</code> 没法变化。所以是按值调用。</p>
<p><code>plusOneByReference</code> 调用，关注的值 <code>b</code> 可以变化，所以是按引用调用。</p>
<p>在 C++ 里并不能通过只看函数签名就能得出求值策略。也就是同一个函数可能有不同的求值策略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minusOne</span><span class="params">(<span class="keyword">int</span>* second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *second = *second - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>  c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>* d = &amp;c;</span><br><span class="line">  minusOne(&amp;c); <span class="comment">// 按引用调用</span></span><br><span class="line">  minusOne(d);  <span class="comment">// 按值调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个 <code>minusOne</code> 调用，关注的值 <code>c</code> 可以变化，所以是按引用调用。</p>
<p>第二个 <code>minusOne</code> 调用，关注的值 <code>d</code> 没法变化，所以是传值调用。</p>
<p>所以一个函数不能直接从签名上得出求值策略。需要从行为上考虑。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>还有按名调用（call by name）和 按未来调用（call by future ）我懒得说了（逃</p>
<p>参考链接 <a href="http://zhihu.com/question/20628016/answer/28970414" target="_blank" rel="noopener">传值还是传引用</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/Continuation-passing-style/" class="prev">PREV</a><a href="/Promise/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://en.ors-sro.com">拖鞋党</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold; animation: breathe 3s infinite">Coding Pages</a></p></div></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [ ['$','$'], ["\\\(","\\)"] ],
    processEscapes: true
    }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});
</script></body></html>